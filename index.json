[{"categories":null,"contents":" 程序语言  理论  语言设计 类型系统   环境  编译器 Runtime system   应用  程序分析 程序验证      背景：过去几十年，语言的内核只有很少的变化，但是语用环境变化，程序变得越来越大并且更加复杂\n挑战：如何保证可靠性、安全性和其他期望在更大范围和更复杂的程序中\n 为什么需要静态分析：  程序可靠性：空指针，内存泄漏等 程序安全性：私有信息泄露，injection attack，etc 编译优化：Dead code elimination，code motion，etc Program Understanding： IDE call hierarchy，type indication，etc    Static Analysis Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P . 但是根据Rice ‘s Theorem，并没有一个方法能够准确的判断有或没有。动态运行时行为有关的行为无法准确判断，即perfect static analysis 不存在。\n  perfect static analysis：同时满足sound 和 complete\n sound： over approximate，报出来的一定包括所有truth但是可能有假的 complete： under approximate，报出来的一定没有假的但不完全包括truth    Useful Static Analysis\n compromise soundness（false negatives）：妥协soundness保证completeness，会带来漏报 compromise completeness（false positives）：妥协completeness，会带来误报 在绝大多数分析中，几乎所有都是妥协completeness保证sound    Static Analysis： Bird’s Eye View if(input) x=1; else x=0 -\u0026gt; x = ? 上有两种分析结果：\n when input is true, x=1 when input is false, x=0 x = 0 or x = 1  这两种结论都是正确的，前者是sound，precise，expensive，后者是sound，imprecise，cheap，甚至可以说x=0 or 1 or 2 or 3这种结果也是正确的，因为保证了sound\nStatic Analysis：在保证soundness的情况下，在precision和analysis speed之间做出一个平衡\nOver-approximation Transfer Functions   transfer functions 在抽象指令上进行定义\n  根据程序的语义来设计\n  unknown: $\\top$\nundefined: $\\bot$\nControl Flows ","permalink":"http://tristonk.com/notes/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/chap1/","tags":null,"title":"导论"},{"categories":null,"contents":"两种人工智能\n  强人工智能\n  弱人工智能：（“科学人工智能”）\n  人工智能不是人造智能，是受智能启发的计算\n典型的机器学习过程：训练数据(类别标记) -\u0026gt; 使用学习算法训练 -\u0026gt; 模型\n机器学习（数据分析技术） + 数据库（数据存储技术）-\u0026gt; 数据挖掘\n人工智能包括机器学习，深度学习是机器学习的一个分支\n计算学习理论最重要的理论模型：PAC(概率近似正确): $P(|f(x)-y|\\leq \\epsilon)\\geq 1- \\delta$\n数据集：训练，测试 示例（instance）是无结果的，样例（example）是有结果的\n样本（sample）：有可能指示例，也可能指样例，也可能指整个数据集，根据上下文\n一个学习器（learner）是一个学习算法在数据集训练后的结果\n 监督学习：数据集中含有的输出信息就是监督信息 无监督学习：数据集中不含有输出信息，但是可以进行聚类等操作  未见样本（unseen instance）\n未知分布：训练数据和未来数据都是用同一种未知分布生成出来的\n泛化(generalization) ：预测未知的能力\n  假设空间：\n  版本空间(version space)：与训练集一致的假设集合（可能会有多种假设和训练集一致）\n  归纳偏好(inductive bias)：机器学习算法在学习过程中对某种类型假设的偏好\n 一般原则：奥卡姆剃刀（Ocam's razor）, 选择尽可能简单的    NFL定理\n  ","permalink":"http://tristonk.com/notes/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/chap0/","tags":null,"title":"绪论"},{"categories":null,"contents":"编译器的作用 编译器： 读入某种语言（源语言）编写的程序，输出等价的用另一种语言（目标语言）编写的程序\n解释器 ：直接利用用户的输入，执行源程序中指定的操作\nJava语言结合了编译（用javac编译成class文件）与解释\n编译器的结构 编译器：分为分析和综合部分\n前端 分析部分\n机器无关\n把源程序分成组成要素和相应语法结构，利用结构构建源程序的中间表示，同时收集相关信息存放到符号表\n字符流 --词法分析--\u0026gt; 符号流 --语法分析--\u0026gt;语法树 --语义分析--\u0026gt; 语法树 --中间代码生成器--\u0026gt; 中间表示形式\n在前端和后端之间，有一个可选的机器无关的代码优化。\n后端 综合部分\n机器相关\n根据中间表示和符号表信息构造目标程序\n中间表示形式--代码生成器--\u0026gt;目标机器语言--机器相关代码优化--\u0026gt;目标机器语言\n词法分析 读入源程序字符流，输出有意义的词素 (Lexeme)\n词素： \u0026lt;token-name, attribute-value\u0026gt;, 如变量position可能为\u0026lt;id, 1\u0026gt;, 其中1是指向符号表对应的条目\n语法分析 根据各个词法单元的第一个分量来创建树形的中间表示形式，通常是语法树\n语义分析 利用语法树和符号表中的信息，检查源程序是否满足语言定义的语义约束\n同时收集类型信息，用于代码生成，类型检查，类型转换\n中间代码生成 根据语义分析输出来生成类机器语言的中间表示\n中间代码优化 代码生成 把中间表示形式映射到目标语言\n 寄存器的分配 指令选择  强制式语言：指明如何完成，如C，java\n声明式语言：指明要完成哪些计算，如Prolog\n程序设计语言的基础概念 静态语言：支持编译器静态决定某个问题\n动态语言：允许在程序运行时刻做出决定\n作用域：变量的一个声明的作用域指程序文本的一个区域，对这个变量的使用都指向这个声明\n环境：名字到存储位置的映射\n状态：存储位置到他们值的映射\nC语言使用静态作用域\n","permalink":"http://tristonk.com/notes/compiler/lesson1/","tags":null,"title":"引论"},{"categories":null,"contents":"数据挖掘是从巨量数据中获取正确的、新颖的、潜在有用的、最终可理解的模式的非平凡过程\n可以用于数据挖掘的数据类型\n  \u0026quot;flat\u0026quot; data: table or data matrix\n  data warehouse(数据仓库)\n  multimedia data\n  web data\n  social network data\n  temporal and spatial data\n数据挖掘类型：\n  描述型数据挖掘任务\n  预测型数据挖掘任务\n  常见的数据挖掘任务：\n 描述型数据挖掘  characterization：刻画主要特征 discrimination：找到对比类相对之下的主要特征 Association：进行关联分析 Clustering：聚类分析，讲数据按照一定的相似度分成几个簇，难点在于怎么衡量相似度和如何将数据分开   预测型数据挖掘  Classification：预测进行分类，难点在于如何刻画清楚分类之间的边界 Regression：从有限数据中挖掘出一个模式 Outlier analysis：检测并分析异常，难点在于outlier的数量是很少的，如何让模型对微弱的信号有敏感性 Trend and evolution analysis：预测趋势    如何衡量一个挖掘数据的有用程度：\n Interestingness Objective measures: Based on statistics and structure of patterns Subjective measures: Based on user's beliefs in data  数据挖掘：\n Machine Learning : practical Data analysis techniques Statistics: Data analysis method with Mathematically validity shown Database: Data management techniques  ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/1introduction/","tags":null,"title":"Introduction"},{"categories":null,"contents":"","permalink":"http://tristonk.com/notes/csmissingsemester/section1/","tags":null,"title":"1. Name"},{"categories":null,"contents":"他们都把家庭看作是实现个人幸福的地方，而且家庭成员之间的情感是维系家庭的主要途径。同时，他们还相信理想的家庭幸福可以通过家庭成员之间努力增进的理解和感情来实现。 包含的意义有两重，一个是家庭生活中个人幸福的重要性，一个是每个个体本身的重要性，但是在现有的中国家庭研究中，这两重意义都没有得到应有的重视。\n","permalink":"http://tristonk.com/notes/%E7%A7%81%E4%BA%BA%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8F%98%E9%9D%A9/chap0/","tags":null,"title":"导论：中国家庭模式与私人生活的研究"},{"categories":null,"contents":"根据物体导电能力(电阻率)的不同，来划分导体、绝缘体、半导体\n半导体是一种导电能力介于导体和绝缘体之间的物质，他的导电能力和温度，光照或掺杂浓度有关\n典型的半导体：硅Si、锗Ge、砷化镓GaAs\n  本征半导体：化学成分纯净的半导体，在物理结构上呈现单晶体形态(纯度达到9个9)\n  本征激发：半导体受热或者光照激发时，某些电子从外界获得能量而挣脱共价键的束缚，离开原子称为自由电子，同时在共价键中留下相当数量的空穴\n 空穴：共价键中的空位 电子空穴对：由热激发而产生的自由电子和空穴对    本征半导体的缺点：载流子少，导电性差，温度稳定性差\n  载流子：可以自由移动的带电粒子\n  导电率：与材料单位体积中所包含的载流子数有关，载流子浓度越高，电导率越高\n  空穴的运动是靠相邻共价键中的价电子依次填充空穴来实现的。复合\n在温度一定时，本征激发和复合会达到动态平衡\n半导体的重要特性：\n 本征半导体中的自由电子和空穴总成对产生，由自由电子-空穴对随温度增高而显著增加 空穴的导电作用  杂质半导体 杂质半导体：在本征半导体中掺入某些微量元素作为杂质，可使半导体的导电性发生显著变化。掺入的杂质主要是三价或者五价元素，掺入杂质的本征半导体称为杂质半导体\n P型半导体：掺入三价杂质元素(硼、镓、铟等) N型半导体：掺入五价杂质元素(磷等)  N型半导体  因为五价杂质原子中只有四个价电子能和周围四个半导体原子中价电子形成共价键，而多余的价电子因为无共价键束缚而容易形成自由电子 自由电子(n)是多数载流子（所以是Negative），主要由杂质原子提供 空穴(p)是少数载流子，由热激发产生 如果一个半导体性质和多子有关，那他和温度关系不大，如果只和少子有关，那受温度影响很大 五价杂质离子称为施主离子：$n=p+N_D$  P型半导体  因为在形成共价键时缺少价电子在共价键中留下了一个空穴 空穴是多数载流子 自由电子是少数载流子 三价杂质称为受主杂质:$N_A+n=p$  载流子的漂移与扩散  漂移电流：电场作用下，载流子在电场作用下的漂移运动形成的电流 扩散电流：因为浓度差载流子从浓度高处向浓度低处扩散形成的电流  PN结 将一个N型半导体和一个P型半导体联结在一起： 因为浓度差导致了多子的扩散运动，从而产生了由杂质例子形成的空间电荷区，从而产生了内电场，内电场促使少子漂移，阻止多子扩散，最后多子的扩散和少子的漂移达到了动态平衡\n对于在P型半导体和N型半导体结合面，离子薄层所形成的空间电荷区称为PN结，在空间电荷区，由于缺少多子，也称为是耗尽层\nPN结 = 空间电荷区 = 耗尽层 = 势垒区 = 非线性电阻\nPN结的单向导电性   正向电压(正偏)：与内电场方向相反。低电阻，大的正向扩散电流。\n  反向电压(反偏)：与内电场反向相同。高电阻，很小的反向漂移电流。使得PN结越来越大。\n 在一定温度情况下，由本征激发决定的浓度是一定的，故而少子形成的漂移电流恒定，基本与反向电压大小无关，电流称为反向饱和电流    V-I特性： $i = I_s(e^{U/U_T}-1)$ 其中$U_T$是一个温度的电压当量，室温下$U_T=26mV$，U是所加的电压，$I_S$是反向饱和电流，\n导通电压：Ge 0.2-0.3V ； Si: 0.6-0.7V\nPN结的反向击穿 Ge管的反向饱和电流比Si大\n反向电压增加导一定数值，反向电压突然快速增加，称为PN结的反向击穿\n 电击穿(可逆)  雪崩击穿：较大的电场与PN结宽度让载流子获得动能，继而与晶体原子碰撞导致束缚在共价键中的价电子碰撞出来，具有正的温度系数 齐纳击穿：发生在掺杂浓度比较高的PN结中，此时空间电荷层比较薄，此时一个很小的反向电压就可以在空间电荷区内建立一个很强的电场，能够把价电子从共价键中拉出来，具有负的温度系数   热击穿(不可逆)  因为PN结的反向电流在很大的电压范围内电流不变，所以可以做稳压电路\nPN结的扩散电容 扩散电容$C_D$:取决于少子，正向偏置时较大，反向偏置时较小。(非平衡少子的变化)\n势垒电容$C_B$:取决于多子，不是线性变化的\n PN结正向偏置时，结电容较大，主要取决于扩散电容 PN结反向偏置时，结电容较小，主要取决于势垒电容  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86%E5%9F%BA%E7%A1%80/","tags":null,"title":"半导体物理基础"},{"categories":null,"contents":"Twelvfold way    Elements of N Elements of M Any f (unstricted) Injective (1-1) f Surjective (on-to) f     不同的 不同的 $m^n$ $(m)_n$ $m!{{n \\atop m}}$   相同的 不同的 $\\big(\\binom{m}{n}\\big)$ $\\binom{m}{n}$ $\\binom{n-1}{m-1}$   不同的 相同的 $\\sum_{k=1}^m{{n \\atop k}}$ $\\begin{cases} 1\u0026amp;\\text{if } n\\leq m\\0\u0026amp;\\text{if }n\u0026gt;m \\end{cases}$ ${{n \\atop m}}$   相同的 相同的 $\\sum_{k=1}^mp_k(n)$ $\\begin{cases} 1\u0026amp;\\text{if } n\\leq m\\0\u0026amp;\\text{if }n\u0026gt;m \\end{cases}$ $p_m(n)$    Basic Enumeration 三条基本规则：\n the sum rule: 对于不相交集合S,T，有$|S\\cup T| = |S|+|T|$ the product rule: 有限集合：$|S\\cdot T|=|S|\\cdot |T|$ bijiection rule: 如果S,T构成双射，则$|S|=|T|$  1.1 Tuples $[m] = {0,1,2,..m-1}$\n相当于n个不同的球随机放到不同的盒子中，为$[m]^n = m^n$\n1.2 Functions Num of functions from $[n]$ to $[m]$ is $m^n$\n如果是单射的话，则是有$(m)_n = m(m-1)..(m-n+1)=\\frac{m!}{(m-n)!}$种可能性\n1.3 subsets 幂集:$2^{[n]}={S|S\\subseteq [n]}$\n幂集的大小：对应一个n位的数可以去0或1，大小为$2^n$\n1.4 subsets of fixed size $\\binom{n}{k}=\\frac{n!}{k!(n-k)!}$\n1.5 binomial coeffcient Binomial theorem: $(1+x)^{n}=\\sum _{k=0}^{n}{n \\choose k}x^{k}$\n1.6 compositions of an integer 把一个整数分成若干个有序（即区分盒子）的正整数之和。\n $\\binom{n-1}{k-1}$ 隔板法 也可以考虑建立对应关系 如果是分成非负数(Weak k-composition)  先补充成正整数再隔板 $\\binom{n+k-1}{k-1}$    1.7 multisets multiset: 允许元素重复的集合\nk-multiset：\n 等价于n个篮子放k个相同的球 使用m(x)标识x在k-multiset中出现的次数 故而问题转化为$m(x_1)+..+m(x_n)=k$ 相当于一个weak n-compostion of k 记为$\\big(\\binom{n}{k}\\big)=\\binom{n+k-1}{n-1}=\\binom{n+k-1}{k}$  1.8 multinomial coeddicients 将n个不同球放到k个不同的篮子中，第i个篮子中有$m_i$个\n$\\binom{n}{m_1,m_2,..m_k}=\\frac{n!}{m_1!m_2!..m_k!}$\n${n \\choose a_{1},a_{2},\\ldots ,a_{m}}$ is the coefficient of $ x_{1}^{a_{1}}x_{2}^{a_{2}}\\cdots x_{m}^{a_{m}}$ in $(x_{1}+x_{2}+\\cdots +x_{m})^{n}$.\n1.9 partions of a set 类似于把n个人分到k艘不同的船上\n${{n \\atop k}}$: $#$ of k-partition of an n-set（Stirling number of the second kind）\n存在性质${{n\\atop k}} = k{{n-1 \\atop k}}+{{n-1\\atop k-1}}$ （理解：可以考虑最后一个元素{n}如果他是单独的一个子集，则是后一种，否则是式子中前面一种情况，可以考虑把他放到k个子集中的一个）\n令$B(n)=\\sum_{k=1}^n{{n \\atop k}}$,即一个n-set的所有种分法(**bell number**)\n1.10 partitions of a number 令$p_k(n)$表示把整数n分成k个正整数之和的分法（与1.6的区别在于此处不区分顺序类比的即不区分盒子）\n不失一般性的，我们不妨假设$x_1\\geq x_2..\\geq x_k \\geq 1$\n令$p(n)=\\sum_{k=1}^np_k(n)$ 为**partition number**\n存在性质$p_k(n)=p_{k-1}(n-1)+p_{k}(n-k)$（考虑$x_k$是大于1还是等于1，若等于1为前者，若大于1则考虑把每个数都减去1即后者）\n1.11 ferrers diagram 考虑将上面整数的分解看成若干个格子的拼凑，现在将其翻转一下就从可以分成k份变成了可以分成若干份，最大的一份为k\n$p_k(n)=\\sum_{j=1}^kp_j(n-k)$\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/basic-enumeration/","tags":null,"title":"Basic Enumeration"},{"categories":null,"contents":"计算机网络与因特网 1.1 什么是因特网 回答什么是因特网：\n 因特网的具体构成，即因特网的基本硬件与软件组件 根据为分布式应用提供服务的联网基础设施来描述  1.1.1 具体构成描述 主机或者端系统: 与因特网相连的设备\n端系统通过通信链路(不同类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱)与分组交换机(常见类型有路由器和链路层交换机，其中链路层交换机常用于接入网中，而路由器通常用于网络核心中)连接在一起\n链路的传输速度：比特/秒(bit/s或者bps)\n分组：端系统向其他端系统发送信息时，发送端系统将数据分段，并为每段加上首部字节，由此形成的数据包叫做分组\n一个分组经过的一系列通信链路和分组交换机称为通过该网络的路径\n因特网服务提供商：ISP\n每个ISP就是一个多台分组交换机和多段通信链路组成的网络\n端系统、分组交换机和其他因特网部件要运行一系列协议，这些协议控制因特网中信息的接收和发送。TCP(传输控制协议)和IP(网际协议)是最重要的两个协议。因特网的主要协议统称为TCP/IP协议。\n因特网标准由IETF研发，IETF的标准文档被称为请求评论(RFC).但也有其他组织在研发，如IEEE 802 LAN/WLAN提出的以太网和无线WIFI的标准\n1.1.2 服务描述 分布式应用程序：设计多个相互交换数据的端系统\n因特网应用程序运行在端系统上而不在网络核心的分组交换机(加速数据交换)上\n端系统提供了套接字接口，规定了运行在一个端系统上的程序请求基础设施向另一个端系统上的特定目的地程序交付数据的方式。\n1.1.3 什么是协议 协议定义了在两个或多个通信实体之间交换报文的格式与顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。\n1.2 网络边缘 端系统位于网络边缘\n主机有时进一步分为两类：主机与服务器\n1.2.1 接入网 接入网：端系统物理连接到其边缘服务器的网络\n边缘路由器：端系统到任何其他远程端系统路径上的第一台路由器\n家庭接入网  数字用户线(digital subscriber Line,DSL)  从本地电话公司获取，ISP：本地电话公司 DSL调制调解器利用现有的电话线(双绞铜线)与位于电话公司本地中心局(CO)中的数字用户接入复用器(DSLAM)交换数据。DSL调制调解器得到数字数据后转化为高频音，以通过电话线传输给本地中心局。 使用频分复用技术(不同频率编码)使得电话呼叫和因特网连接共享一根线   电缆因特网接入(cable Internet access)  使用有线电视公司的有线电视基础设施，应用光纤和同轴电缆，称为混合光纤同轴系统(HFC) 需要特殊的调制调解器：电缆调制调解器 电缆调制调解器系统(CMTS)将HFC分为上行和下行两个信道 共享广播媒体，故而需要一个分布式多路访问协议来细条传输和避免碰撞   光纤到户(FTTH)  从中心局直接到家庭提供一条光纤路径 直接光纤：从本地中心局到每户设置一根光纤，或者中心局出来的每个光纤多个家庭共享一直到接近家庭的位置光纤猜分成每户一根。分配方案有两种  主动光纤网络(AON)：本质上是交换因特网 被动光纤网络(PON) ：每个家庭有一个光纤网络端接器(ONT),由专门的光纤连接到附近的分配器，分配器把一些家庭集结到一根共享的光纤，这根光纤连接本地电话和公司的中心局中的光纤线路端接器(OLT)，该OLT提供了光信号和电信号之间的转换。     卫星链路  企业(和家庭)接入 局域网:LAN\n以太网是最流行的局域网接入技术\n基于IEEE 802.11技术的无线LAN接入：WiFi\n广域无线接入：3G与LTE 1.2.2 物理媒体 物理媒体包括了导引型媒体(电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆)和非导引型媒体(在空气或者外层空间传播，如无线局域网)\n1.3 网络核心 网络核心：互联网端系统的分组交换机和链路构成的网状网络\n1.3.1 分组交换 端系统彼此交换报文(message)。源将长报文分成较小的数据块，称之分组。每个分组经过通信链路和分组交换机交换，分组以等于该链路最大传输速率的速度通过通信链路。假设传输 L 比特的分组，链路速度为 R bps，那么传输该分组时间为 L/R 秒\n存储转发传输 多数分组交换机在链路的输入端使用存储转发传输机制，即在交换机能够开始向输出链路传输该分组的第一个比特之前须接收到整个分组。\n如果不考虑传播时延，通过N哥速率为R的链路组成的路径，端到端时延为N(L/R)\n排队时延与分组丢失 每个分组交换机有多条链路，对于每条链路分组交换机有一个输出缓存(也叫输出队列)，用于存储路由器准备发完那条链路的分组。如果链路正在传输其他的分组，那么该分组必须在输出缓存中等待。如果到达的分组发现缓存已经充满了，那么会出现丢包现象，到达的分组或者队列中的分组之一将被丢弃。（接近满时概率丢包）\n转发表与路由选择协议 每个端系统有一个IP地址，路由器有一个转发表，将目的地址或目的地址的一部分映射成输出链路。分组到达时，利用目的地址搜索转发表，找到出链路，路由器将这个分组导向该出链路。\n路由选择协议用于自动的设置转发表。\n1.3.2 电路交换 端系统的通信会话期间，预留了端系统间沿路径通信所需要的资源(如缓存、链路传输速率)。\n例子:传统的电话网络\n电路交换网络在能够发送信息之前，必须在发送方和接收方之间建立一条连接，此时沿着发送方和接收方之间路径上的交换机都会为该连接维护连接状态。该连接称为一条电路(circuit)。创建电路时，在连接期间为该网络预留了恒定的传输速率，发送方以确保的恒定速率向接收方传送数据。\n复用现象：\n  频分复用(FDM):频谱由所有连接共享，连接期间每条连接专用一个频段。频段宽度称为带宽\n  时分复用(TDM):时间划分为固定的帧，每个帧划分成固定数量的时隙，创建连接时，网络在每个帧中指定一个时隙提供给这个连接单独使用。电路的传输速率为帧速率乘以一个时隙中的比特数。\n  TDM较FDM的好处在于FDM 需要相应的硬件设施来将信号转化为合适的频段，而TDM 只需要选择帧中合适的时隙就\n可以了。\n  分组电路和交换电路的对比：\n 电路交换电路是确保传输的，而分组交换是尽最大努力以实时方式交付分组但是不做任何保证 分组交换的优点：  1)提供了更好的带宽共享，电路交换预先分配使得已分配而不需要的链路时间未被利用，而分组交换按需分配使用电路 2)比电路交换更简单有效，创建端到端电路和预留带宽是复杂的，需要复杂的信令软件来协调   但是分组时延的端到端时延是可变和不可预测的，而电路交换保证能以确定速率传输  1.3.3 网络的网络 除了第一层ISP之外，任何ISP可以选择多宿,即选择多个提供商ISP连接\n1.4 分组交换网中的时延、丢包与吞吐量 吞吐量：每秒可以传送的数据量\n1.4.1 分组交换网中的时延概述 节点总时延：\n 节点处理时延：检查分组首部和决定分组导向何处，检查比特级别差错，处理后导向路由器B之前的队列 排队时延：在链路上等待传输。微秒到毫秒级。 传输时延：将所有分组的比特推向链路需要的时间，为L/R。毫秒级到微秒级 传播时延：链路起点到路由器B的传播时延  1.4.2 排队时延和丢包 假设a表示分组到达队列的速率(分组/秒)，L表示分组的大小(bit),那么La表示比特到达队列的平均速率(bps). 假设R表示传输速率(即队列中推出比特的速率，bps)。\n定义流量强度：La/R。在流量工程中，流量强度不能大于1.随着流量强度接近1，平均排队时延快速增长。\n1.4.3 端到端时延 如果不考虑排队时延 $$d_{end-end} = N(d_{proc}+d_{trans}+d_{prop})$$\n1.4.4 吞吐量 瞬时吞吐量：接收文件的瞬时速率\n平均吞吐量：F/T（接收F比特用了T秒)\n瓶颈链路：吞吐量是各个子链路的最小值\n1.5 协议层次及其服务类型 1.5.1 分层的结构体系 协议分层 每层向他的上一层提供服务，即所谓一层的服务模型，每层都在该层执行操作或者直接使用下层的服务来提供服务。\n协议栈：各层的所有协议\n 应用层  网络应用层序及他们的应用层协议停留的地方(HTTP,SMTP,FTP) 应用层的信息分组：报文(message)   运输层  在应用程序端点之间传送应用层报文 TCP：面向连接的服务(确保传递与流量控制)，提供拥塞控制 UDP：无连接服务,不提供不必要服务，没有可靠性，没有流量控制与拥塞控制 分组：报文段(segment)   网络层  运输层协议向网络层细一递交运输层报文段与目的地址，网络层负责将**数据报(datagram)**的网络层分组从一台主机移动到另一台主机 网际协议：IP协议 路由选择协议   链路层  网络层将数据报下传给链路层，链路层沿着路径将整个帧传给下一个节点，在下一个节点，链路层将数据报上传给网络层 链路层分组：帧(frame)   物理层  将帧中的比特从一个节点移动到另一个节点，这一层的协议与链路的实际传输媒体相关    OSI模型  应用层 表示层  使得通信的应用程序能够解释交换数据的含义   会话层  数据交换的定界与同步功能，包括了建立检查点和恢复方案的方法   运输层 网络层 链路层 物理层  1.5.2 封装 链路层交换机：实现了1-2层(尽管不能识别IP地址，但是可以识别第二层地址如以太网地址)\n路由器：实现了1-3层\n主机：实现了所有的5个层次\n每一个分组：首部字段+有效载荷字段(上一层的分组)\n运输层首部信息：允许接收端运输层向上向适当的应用程序交付报文的信息；差错位检测信息\n网络层首部信息：源和目的端系统系统地址\n链路层首部信息：-\n1.6 面对攻击的网络 僵尸网络：\n 病毒：需要某种形式的用户交互 蠕虫：不需要明显用户交互就能进入设备  拒绝攻击服务(DOS):使得基础设施部分不能由合法用户使用\n 弱点攻击：向目标主机运行的易受攻击的应用程序或者操作系统发送制作精细的报文 带宽洪泛：向目标主机发送大量分组 连接洪泛：向目标主机创建大量的半开或者全开的TCP连接  分组嗅探：记录每个流经的分组副本\nIP哄骗：将具有虚假源地址的分组注入因特网（解决方式：端点鉴别）\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ji-suan-ji-wang-luo-yu-yin-te-wang/","tags":null,"title":"计算机网络与因特网"},{"categories":null,"contents":"数据库系统概述  复习重点\n1.1基本概念\n 数据库，数据库管理系统，数据库系统，数据库管理员 相互之间的关系  1.2数据库系统的特点\n 数据集成化，数据独立性，数据共享，数据冗余，数据的安全性，完整性和一致性，并发控制和故障恢复  1.3数据库内部结构体系\n 数据模式 三级模式 \u0026amp; 二级映射 三级模式与数据独立性的关系   基本概念 数据库(DB): 是数据集合，具有统一的结构形式并存放在统一的存储介质中，由多种应用数据集成，并可以被应用所共享\n数据库管理系统（DBMS）：一种管理数据库的系统软件，是数据库的应用程序与数据库的接口\n数据子语言：数据定义语言（DDL）,数据操纵语言（DML）,数据控制语言（DCL）\n数据库管理员（DBA）：对数据库进行规划、设计、维护与监视的专职人员\n数据库系统（DBS）：一个以海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统。组成部分：数据库、数据库管理系统、软件平台、硬件平台\n数据库应用程序（DBAS）：利用数据库系统做应用开发所构成的集成化的独立运行系统，包括：数据库系统、应用软件、应用界面、用户\n数据库用户：最终用户（终端查询用户、应用程序的使用者），应用程序开发人员、数据库管理员\n两层C/S架构：数据库和DBMS运行在数据库服务器中，数据库运用程序运行在客户机中\n三层C/S架构：数据库和DBMS运行在数据库服务器中，数据库应用程序运行在应用服务器（Web服务器）中，用户客户端只需要安装浏览器\n数据库的基本特点 集成性：集多种应用数据为一体，表现为采用统一数据结构，建立一个全局统一的数据模式，根据每个应用的数据需要构作局部模式\n数据独立性：指数据库中的数据与使用数据的应用之间互不依赖，包括物理独立性（数据的物理结构的改变不影响数据库的逻辑结构，从而不引起应用程序变化）与逻辑独立性（数据库总体逻辑的改变，如修改数据模式、增加新的数据类型，不需要修改应用程序）\n高共享性与低冗余性：数据共享，避免数据冗余，这使得可以避免数据的不一致性（一致性：同一数据在不同出现保持相同的值）\n数据的安全性：对数据库访问者做检查以防止非法访问\n完整性：对数据库中的数据正确性做检查\n并发控制：多个应用并发访问所产生的互相干扰做控制\n故障恢复：对遭受破坏的数据具有恢复能力\n数据库内部结构体系 三级模式 外模式（也称 子模式、用户模式，对应用户数据库）：关于某个（组）用户所需数据的逻辑结构的描述，它可以由概念模式推导而出，是概念模式的一个子集，一个概念模式可以对应多个外模式。\n概念模式（简称 模式，对应概念数据库）：关于整个数据库中的数据的全局逻辑结构的描述，利用DBMS提供的数据定义语言DDL描述数据的类型、长度、特征，数据间的联系，安全性、完整性等方面的要求\n内模式（也称 物理模式，对应物理数据库）：关于数据库中数据的物理存储结构和物理存储方法的描述\n两种映射： 外模式-概念模式映射：概念模式是全局的，而外模式是用户的局部模式，每个外模式是概念模式的一个基本视图，可实现逻辑独立性\n概念模式-内模式映射：对应了概念模式中全局逻辑结构与数据的物理存储结构之间的关系，可实现物理独立性\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/introduction/","tags":null,"title":"数据库系统概述"},{"categories":null,"contents":"1 Introduction 本文档中的示例代码并不作为规范。即虽然示例代码是遵循 Google 编程风格，但并不意味着这就是是展现这些代码的唯一方式。\n2 Src基础 2.1 文件名 根据最顶层的类名来命名，大小写敏感，使用.java格式\n2.2 文件编码 UTF-8\n2.3 特殊字符 空白字符 除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，即：\n  所有其它字符串中的空白字符都要进行转义。\n  制表符不用于缩进。\n  特殊转义序列 对于具有特殊转义序列的字符(\\b, \\t, \\n, \\f, \\r)，使用其转移序列而不是使用相应的八进制或者Unicode转义\n非ASCII字符 是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。\n在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释\n{% note warning %} Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that should happen, those programs are broken and they must be fixed. {% endnote %}\n3 Src结构 一个源文件应当包括（以下按照顺序包括）：\n 许可证与版权信息（如需要） package语句 import语句 一个顶级类（只有一个）  以上每个部分用一个空行隔开\n3.2 package语句 package 语句不换行，列限制(4.4节)并不适用于 package 语句。(即package 语句写在一行里)\n3.3 import语句 不要使用通配符，即不要使用类似import java.util.*这样的语句\n按照以下顺序与间距将其分为几组，每组之间一个空行，同组import不换行，组内按字典序排序：\n 所有静态导入独立成组 com.google 包下的 第三方的包，每个顶级包为一组，如android,sun等 java import javax import  3.4 类声明 只有一个顶级类 每个文件中只有一个与文件名同名的顶级类\n类成员顺序 应当按照某种逻辑进行排序而不是添加时间\n重载 一个类有多个构造函数或同名方法时们这些函数/方法应当按顺序放在一起\n4 格式 4.1 使用大括号 大括号与 if,else,for,do,while 语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。\n非空块（K\u0026amp;R） 对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):\n 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。  举例：\nreturn () -\u0026gt; { while (condition()) { method(); } }; return new MyClass() { @Override public void method() { if (condition()) { try { something(); } catch (ProblemException e) { recover(); } } else if (otherCondition()) { somethingElse(); } else { lastThing(); } } }; 但也有一些例外，如4.8中的enum类\n空块 一个空的块状结构里什么也不包含，大括号可以简洁地写成 {}，不需要换行。\n但是如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。\n4.2 块缩进 每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。\n4.3 一行一个语句 每个语句后换行\n4.4 列限制 每一列只能由80或100个字符，超过则自动换行\n以下为例外情况：\n  不可能满足列限制的行(例如，Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。\n  package和 import语句(见3.2节和3.3节)。\n  注释中那些可能被剪切并粘贴到shell中的命令行。\n  4.5 自动换行 换行断点 自动换行的基本准则是：更倾向于在更高的语法级别处断开。\n  如果在 非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。\n注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的\u0026amp;（ \u0026lt;TextendsFoo\u0026amp;Bar\u0026gt;)，catch块中的管道符号( catch(FooException|BarExceptione)\n  如果在 赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于 foreach语句中的分号。\n  方法名或构造函数名与左括号留在同一行。\n  逗号(,)与其前面的内容留在同一行。\n  一般而言不会再lambda语句的箭头后断开，除非是箭头后面的是一个没有大括号的表达式\n  缩进后至少+4个空格 自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。\n当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。\n4.6 空白 垂直空白 以下几种情况需要一个空行：\n  类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。\n例外：\n 两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。 在enum类的常量间    要满足本文档中其他节的空行要求(比如section 3 中的文件结构 与 3.3节中的import语句)\n  类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。\n水平空白 除了语言需要与规则，单个空白同样出现在以下地方：\n  分隔任何保留字与紧随其后的左括号( ( )(如 if,for,catch等)。\n  分隔任何保留字与其前面的右大括号( })(如 else, catch)。\n  在任何左大括号前( {)，两个例外：\n @SomeAnnotation({a,b})(不使用空格)。 String[][]x={{\u0026quot;foo\u0026quot;}};(大括号间没有空格)。    任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：\n 类型界限中的 \u0026lt;T extends Foo \u0026amp; Bar\u0026gt;。 catch块中的管道符号catch (FooException | BarException e。 foreach语句中的分号。 lambda语句的箭头后面  但是也有例外：\n 两个冒号后的方法的引用，如Object::toString .之后的，如object.toString()    在 ,:;及右括号( ))后\n  如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。\n  类型和变量之间：List\u0026lt;string\u0026gt;list。\n  数组初始化中，大括号内的空格是可选的，即 new int[] {5, 6}和 new int[] { 5, 6 }都是可以的。\n  水平对齐：不做要求  Tip: Alignment can aid readability, but it creates problems for future maintenance.\n 4.7 Grouping parentheses 除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。\n4.8 几种具体的结构 枚举类 枚举常量间用逗号隔开，换行可选,多余的空行也是允许的（通常一行）\n没有方法和文档的枚举类可写成数组初始化的格式：\nprivate enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } 变量声明 每一个变量声明只声明一个变量，如int a,b 是不可行的 （for循环的初始化条件除外）\n需要时才声明变量，并尽快的初始化，不要在一个代码块的开头将所有局部变量一次性声明\n数组 数组的初始化可以写成块状结构，如写成以下形式都是可行的：\nnew int[] { 0, 1, 2, 3 } new int[] { 0, 1, 2, 3 } new int[] { 0, 1, 2, 3 } new int[] {0, 1, 2, 3} {% note warning %}\n没有使用C语言类型的声明 中括号是类型的一部分，而不是变量，应当使用String[] args, 而不是String args[]\n{% endnote %}\nSwitch语句 与其它块状结构一致，switch 块中的内容缩进为 2 个空格。每个 switch 标签后新起一行，再缩进2个空格，写下一条或多条语句。\n在一个 switch 块内，每个语句组要么通过 break,continue,return 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用 // fall through)。这个特殊的注释并不需要在最后一个语句组(一般是 default)中出现。\n示例：\nswitch (input) { case 1: case 2: prepareOneOrTwo(); // fall through  case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input); } 每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。\n注解（annotations） 注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。\n例外：单个的注解可以和签名的第一行出现在同一行。例如：\n@Override public int hashCode() { ... } 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：\n@Partial @Mock DataLoader loader; 注释 块注释与其周围的代码在同一缩进级别。它们可以是 /* ... */风格，也可以是 // ...风格。\n对于多行的 /* ... */注释，后续行必须从 *开始， 并且与前一行的 *对齐。\n修饰符 若类和成员的 modifiers 如果存在，则按 Java 语言规范中推荐的顺序出现。顺序如下：\n public protected private abstract static\tfinal transient\tvolatile\tsynchronized native strictfp\n 5 命名 5.1 通用规则 标识符使用ASCII字母与数字，使得每个有效的标识符都可以使用\\w+来正则匹配\n在其他规范中使用的特殊前缀或后缀，如 name_, mName, s_name 和 kName，在 Java 编程风格中都不再使用。\n5.2 标识符类型 包名 全部小写，连续的单词简单的连接起来而不使用下划线\n类名 使用UpperCamelCase的格式（关于UpperCamelCase在5.3介绍）\n测试类的命名使用其要测试的类的名字+Test，例如HashTest\n方法名 使用lowerCamelCase风格\n方法名通常使用动词或者动词短语\n下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test\u0026lt;MethodUnderTest\u0026gt;_\u0026lt;state\u0026gt;，例如 testPop_emptyStack。但是并不存在唯一正确的方式来命名测试方法。\n常量名 全部字母大写，用下划线分隔单词\n每个常量都是一个静态的final字段，但是不是所有的静态final字段都是常量\n名字一般为名词或者名词短语\n非常量字段 使用lowerCamelCase风格\n参数名 使用lowerCamelCase风格\n避免使用单个字符命名\n局部变量 使用lowerCamelCase风格，除了临时变量和循环变量之外要避免用单字符进行命名\n即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。\n类型变量 两种方式皆可：\n 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。  5.3 CamelCase 移除所有的单引号\n将所有字母都小写(包括缩写)，然后将单词的第一个字母大写\n UpperCamelCase：每个单词的第一个字母都大写，来得到大驼峰式命名 lowerCamelCase：除了第一个单词，每个单词的第一个字母都大写   Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名 checkNonempty和 checkNonEmpty也都是正确的。\n 6 代码实践 6.1 尽量使用@override 只要是合法的，就把 @Override 注解给用上。\n6.2 不能忽略捕获的异常 对捕获的异常不做响应很少是正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError重新抛出。)\n如果它确实是不需要在catch块中做任何响应，需要做注释加以说明。\n但是，在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。\n6.3 静态成员的调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。\n举例：\nFoo aFoo = ...; Foo.aStaticMethod(); // good aFoo.aStaticMethod(); // bad somethingThatYieldsAFoo().aStaticMethod(); // very bad 6.4 禁用finalizers 一般极少override Object.finalize\n Tip: Don't do it. If you absolutely must, first read and understand \u0026lt;em\u0026gt;Effective Java\u0026lt;/em\u0026gt; Item 7,\u0026quot;Avoid Finalizers,\u0026quot; very carefully, and then don't do it.\n 7 JavaDoc 7.1 格式 Javadoc 块的基本格式如下所示：\n/** * Multiple lines of Javadoc text are written here, * wrapped normally... */ public int method(String p1) { ... } 或者是以下单行形式：\n/** An especially short bit of Javadoc. */ 基本格式总是 OK 的。\n当整个 Javadoc 块能容纳于一行时(且没有 Javadoc 标记，比如@return)，可以使用单行形式。\n空行(即，只包含最左侧星号的行)会出现在段落之间和 Javadoc 标记(@XXX)之前(如果有的话)。除了第一个段落，每个段落第一个单词前都有标签 \u0026lt;p\u0026gt;，并且它和第一个单词间没有空格。\n标准的 Javadoc 标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。当描述无法在一行中容纳，连续行需要至少再缩进4个空格。\n7.2 摘要片段 每个类或成员的 Javadoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下它是唯一出现的文本，比如在类和方法索引中。\n这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 A{@codeFoo}isa...或 This method returns...开头, 它也不会是一个完整的祈使句，如 Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。\n一个常见的错误是把简单的Javadoc写成 /\\*\\* @return the customer ID \\*/，这是不正确的。它应该写成 /\\*\\* Returns the customer ID. \\*/。 7.3 需要书写Javadoc的地方 至少在每个public类及它的每个 public 和 protected 成员处使用 Javadoc\n以下为例外情况：\n  不言自明的方法，对于简单明显的方法单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。\n 如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由    override，如果一个方法重写了超类中的方法，那么 Javadoc 并非必需的。\n  对于包外不可见的类和方法，如有需要，也是要使用 Javadoc 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 Javadoc，这样更统一更友好。\n","permalink":"http://tristonk.com/notes/google%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/style-javaguide/","tags":null,"title":"Java代码规范"},{"categories":null,"contents":"{% note info no-icon %} 社会学的学习是激情之旅，让我们一起努力，接触那些饱受争议的概念与理论，试图打开那些紧闭着的大门，去发现我们非常熟悉的日常世界之幽暗玄冥的一面\t----Peter Berger {% endnote %}\n课程基本目标：\n略（略略略）\n 明白定义背后的争议 世界有很多种表达方式 社会学特点： 超越自身内部的分歧\n {% note primary %}\n本讲阅读文献 C.Wright Mills “The promise of Sociology”\nPeter Berger. Invitation to Sociology\n{% endnote %}\n课程阅读文献： 《社会学教程》，主编王思斌\n接触不同的表述： 吉登斯社会学 邱泽奇《社会学是什么》\n米尔斯《社会学的想象力》 费孝通《乡土中国》 涂尔干《自杀论》（“自杀，往往与时代的病症相关联，并不仅是个人问题”） 马克斯·韦伯《新教伦理与资本主义精神》 彼得·伯格 《与社会学同游：人文主义的视角》（有较强的个人风格）\n从社会学发展的历史看社会学的视角 诞生于社会需求之中\n社会学之父 - 孔德（August Comte） 1838年 其对于 社会学的定义： 对于社会现象所固有的全基本规律的实证研究 一开始想用social physics（社会物理学）来指代\n观察一个社会事件：-偶然性 -事件背后的可理解性\n1838年经历过的背景：\n 启蒙运动，理性的年代，将科学用于社会的研究 双元革命（法国大革命与工业革命）社会学产生从社会意义讲是双元革命之子 法国大革命：追求平等与博爱，用理性改变不合理的旧制度，混乱 工业革命：冲破了惯例与习俗，物质丰富背后的肮脏，素来遵从的观念烟消云散  孔德：用理性找出社会内在规律，恢复社会的美德，解救社会的困境，“人性的宗教”\n社会学的创立有着很强烈的乌托邦色彩，传统的社区邻里关系 “奥古斯特·孔德想象了一个由社会学家领导的家庭式秩序”--麦克布罗维《公共社会学》\n涂尔干设想了一种建立在具有劳动分工的法团主义组织基础上的有机团结-一种行会社会主义的形式\n孔德之后的三位奠基人：卡尔·马克思，埃米尔·涂尔干，马克思·韦伯\n马克思研究社会学角度：阶级分工\n涂尔干：使得社会学学院化，研究社会学的观点：社会是一个整体，社会事实外在于个体（可以参考其《自杀论》）\n韦伯：现代社会学与公共社会学，重要的资本主义研究：资本主义的出现与兴起，从“精神氛围”研究资本主义的兴起，提出科层制，科层化-理性化的来安排生产生活，工具理性与价值理性，社会分层\n 工具理性：通过实践的途径确认工具或手段的有用性，从而追求事物的最大功效，为人的某种功利的实现服务\n价值理性：通过有意识地对一个特定的行为—伦理的、美学的、宗教的或作任何其他阐释的——无条件的固有价值的纯粹信仰，不管是否取得成就\n “世界无可避免的进入了铁笼之中”\n马克思认为经济基础决定上层建筑，而韦伯将宗教文化放在了一个独立的地位，进行比较宗教研究\n社会学的三大理论视角：\n 冲突理论 --马克思 结构功能主义 --涂尔干 符号互动论 --韦伯（符号互动论成形于米德，但其很大部分的受到了韦伯的影响）  韦伯强调微观的社会行动者，而不是整体去讨论整体的宗教，文化\n","permalink":"http://tristonk.com/notes/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E6%A6%82%E8%AE%BA/shxgl1/","tags":null,"title":"社会学概论-社会学的视角"},{"categories":null,"contents":"Compilers and Static Analyzers Source Code\nAST vs. IR IR: Three-Address Code(3AC) 3AC in Real Static Analyzer: Soot Static Single Assignment(SSA) Basic Blocks(BB) Control Flow Graphs ","permalink":"http://tristonk.com/notes/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/chap2/","tags":null,"title":"Intermediate Representation"},{"categories":null,"contents":" 在没有一个共同权力使大家慑服的时候，人们便处在所谓的战争状态之下。这种战争是每一个人对每个人的战争。——托马斯·霍布斯\n 岛屿的寓言  考虑这样一个情况，一群正在上课的老师和学生被突然丢在了一个岛屿上，岛上有各种资源，但是失去了与外界联络且不考虑之后会有救援，这群人如何生存下来？\n 可能的考虑方向：资源分配、领袖、分工与产权、生存秩序的问题\n  谁来统治呢？ --\u0026gt;基于传统进行统治：选择老师作为统治者\n  如何评判是不是一个公正的统治者呢？公正的秩序、合理的份额、行政机关、知人善任、教育\n  成为统治者之后\n 变得贪图享乐和不知节制：偏离公正有为的标准，政治秩序逐渐败坏，众人发出抱怨甚至反抗的呼声。这时候，护卫队在政治上越来越重要。  护卫队推翻了统治，这时候新建立的政治秩序的基础在于暴力，这种统治的统治者可能是暴君也可能是明君。 此时他同样面临死后统治者的问题，同时更大的问题在于他要任命新的护卫队队长，而在之前的政变中护卫队的政治作用极大，那么他就要时刻提防新的护卫队长发起政变。   自制的统治者：统治者死掉会如何呢？后代继承还是指定呢？  如果选取一个具有卡里斯玛型特质(超凡魅力型的)的人作为统治者，随着身份变化，他是否会变得贪婪呢？      那如何考虑的一种合理的政治制度呢？\n  一种看法是法理型统治\n 不管谁统治，首先要建立基本的规则。这个基本规则决定了无论是谁掌握政治权力，他只能按确定的规则来统治，统治者不能随心所欲、为所欲为。我们首先要明确基本规则，明确统治者和统治机构能够做什么和不能做什么，然后再来讨论谁来统治和具体如何统治的问题。 所有岛上公民的基本权利要有切实的保障。无论谁做统治者，他都不能破坏岛上公民的基本权利，其中最重要的是生命权、财产权与自由权。 要通过一种和平的、寻求岛上多数公民支持的方式来选择统治者。当然，这意味着一种投票制度，但投票制度的具体形式则存在多种选择。    而这种方式有的国家实施的很好，有的确是一场政治悲剧\n 如果你让公众投票来决定谁统治他们，结果是该国的精英阶层马上四分五裂了，形成大量的派系。极常见的情形是，那得势的一方往往想方设法压制失势的一方，而那失势的一方总喜欢制造混乱的局面，使那得势的一方也难以统治。那样的话，不要说好的治理，就是连和平与秩序都难有保障了。 统治的问题，不是你想要怎样设计就能怎样设计。实际上，现有的政治就是我们这些年来自己造成的。不是我过于悲观，我只是一个务实的人。要我说，我们大概只能在现有的状态里生活。你们若问我如何变得更好，我直接的想法是我们可能很难有办法变得更好    两者关心的是同一个问题：一个社会如何构建合理的政治秩序？然而，前者更多关注“什么是可欲的政治秩序”，后者更多关注“什么是可得的政治秩序”。用更学理的方式来说，第一个问题是我们在岛上应该构建何种政治秩序？第二个问题是我们在岛上能够构建何种政治秩序？前者是“应然”的问题，关注应该怎样；后者是“实然”的问题，关注事实怎样。\n  如果回到经验世界，还会发现，一种政治秩序的构建较少取决于智者的思考，较多取决于政治参与者的行动。不是政治哲学原理决定了一个国家的政治秩序是怎样的，而是主要政治集团的观念、行为、选择以及互相之间的政治博弈决定了一个国家的政治秩序是怎样的。\n如果想作进一步的讨论，我们还可以超越一个岛屿的政治秩序问题，转而来思考诸岛竞争的问题。为什么诸岛之间会形成如此巨大的差异？如果深入探究应该能发现，这种差异的根源在于政治秩序的不同。\n什么是政治学 三种不同的传统（发展脉络）：哲学传统，经验传统，科学传统\n哲学传统 认为是哲学或者历史学的分支，重视规范研究，更多地进行哲学思辨式的探索，关注应该怎样的问题。这些问题一般都是规范性思考。他们更多地以哲学思辨方式来研究应该怎样，其核心仍然是人类社会应该构建何种政治秩序。\n经验传统 关心的不是应该怎样，而是现实世界中的不同国家、不同城邦、不同政体的政治实际上是怎样的。这种研究以经验事实为基础，关注的“是什么”，而非“应该是什么”。亚里士多德是政治学经验研究的开创者。\n科学传统 科学传统并不是独立于经验传统的路径，而是在经验研究中更多地采用科学方法。在科学传统中，学者们更关心对因果关系的探究，即何种原因导致何种结果，通常还包括对因果机制与过程的解释。好的社会科学研究基本上都是从问为什么开始的，关注的是为什么某种特定的原因会导致某种特定的结果。\n20世纪之后，政治学研究更多地走向科学传统，政治学研究更加专业化，政治科学成为整个政治学研究的主流。\n四个主要研究领域   政治哲学，有时又被称为政治理论——特别是在英国。政治哲学关心的仍然是自西方的柏拉图和亚里士多德以及中国的孔子和韩非以来经久不衰的重要问题。即探究政治思想史上不同重要人物对这些问题的观点，并对这些观点进行梳理和比较。\n  比较政治学，这是目前政治学研究最重要的领域。比较政治学是对不同国家和地区的政体制度、政治运行、公共治理与治理绩效的比较研究\n  本国政治。在美国，本国政治就是美国政治；在中国，本国政治就是中国政治。有人认为，本国政治研究是比较政治学的一部分。为什么本国政治通常又被归入一个独立的研究领域呢？主要是两个原因：一是任何政治学研究都存在“以我为主”的问题，所以本国政治研究通常会跟国别比较研究区别开来；二是本国政治研究一般会做得比较精细，不仅论文和著作的产量非常大，而且通常会比跨国研究更为专门和深入。\n  国际政治，又称国际关系。这是很多人都会关心的领域。国际政治研究不只是关心本国与他国的国际关系，同时还研究别的国家和地区之间的国际关系。\n  古希腊与古罗马的传统 古希腊 有文字记载的政体类型学的最早起源：希罗多德《历史》\n 欧塔涅斯: 民主制的支持者、独裁制的反对者。认为独裁统治带来了种种坏处，主张让全体波斯人参与国家的统治和管理:   当一个人愿意怎样做便怎么做而对自己所做的事情又可以毫不负责任的时候，那末这种独裁的统治又有什么好处呢？把这种权力给世界上最优秀的人，他也会脱离他正常的心情的。……不过，相反的，人民的统治的优点首先在于他的最美好的名声，那就是，在法律面前人人平等。其次，那样便不会产生一个国王所容易犯的任何错误。一切职位由抽签决定，任职的人对他们任上所做的一切事情负责，而一切意见均交由人民大众加以裁决。\n  美伽比佐斯并不看好民主制，他是寡头制的拥护者。他既不信任独裁的君主，亦不信任普通大众。   但是，当他主张要你把权力给予民众的时候，他的见解便不是最好的见解了。没有比不好对付的群众更愚蠢和横暴无礼的了。把我们自己从一个暴君的横暴无礼的统治之下拯救出来，却又用它来换取那肆无忌惮的人民大众的专擅，那是不能容忍的事情。……只有希望波斯会变坏的人才拥护民治；还是让我们选一批最优秀的人物，把政权交给他们罢。\n  大流士认为应该推行独裁统治，理由在于无论民主制还是寡头制都会带来不好的结果，而等到这种结果显现的时候都要靠独裁制来解决问题。   若实施寡头制，则许多人虽然愿意给国家做好事，但这种愿望却常常在他们之间产生剧烈的敌对情绪，因为每个人都想在所有的人当中为首领，都想使自己的意见占上风，这结果便引起了激烈的倾轧，互相之间的倾轧产生了派系，派系产生流血事件，而流血事件的结果仍是独裁之治；因此可以看出，这种统治方式乃是最好的统治方式。再者，民众的统治必定会产生恶意，而当在公共的事务中产生恶意的时候，坏人便不会因为敌对而分裂，而是因巩固的友谊而团结起来；因为那些对大众做坏事的人是会狼狈为奸地行动的。这种情况会继续下去，直到某个人为民众的利益起来进行斗争并制止了这样的坏事。于是，他便成了人民崇拜的偶像，而既然成了人民崇拜的偶像，也便成了他们的独裁的君主；在这样的情况下也可以证明独裁之治是最好的统治办法。\n   伯里克利：雅典政治领袖\n 雅典民主制是多数人的统治，“城邦是由大多数人而不是由极少数人加以管理的”； 公共领域与私人领域的划分，他提到了“公共生活”与“私人关系”两个不同概念 雅典公民既享有自由，又懂得服从法律和权威。    柏拉图\n 政治哲学经典话题“什么是正义”：公平对待每个人，服从等级秩序，以及使每个人各安其位。 非常理想的国家必须妇女共有、儿童共有、全部教育共有。他们的王则必须是那些被证明为文武双全的最优秀人物。 哲学王的统治  凡人皆有弱点，而多数人易于堕落。 认为任何事情都需要专门的技艺，统治亦不例外。 卡尔·波普尔在《开放社会及其敌人》中把柏拉图视为现代极权主义思想的滥觞。   在《政治家》和《法律篇》等著作中退了一步认为哲学王的统治实际上是较难实现的。所以，混合政体被他视为一种次优选择。    亚里士多德\n 对政体类型进行了研究，并首创了比较研究的方法  六种政体，按照统治者数目多寡和统治目的是否为服务全城邦(如果只服务于统治者则为变态政体) 僭主政体为君主政体的变态 寡头政体为贵族政体的变态 平民政体为共和政体的变态   讨论了阶级斗争问题，论述了贫富冲突的危害以及中产阶级的重要性  平民群众和财富阶级之间时时发生党争，他们把政治特权看做党争胜利的果实，抢占到自己的手中后，就各自宁愿偏向平民主义或寡头主义而独行其是。 以中产阶级为基础才能组成最好的政体。中产阶级（小康之家）比任何其他阶级都较为稳定。最好的政治团体必须由中产阶级来执掌政权。      古罗马  西塞罗  较为重要的贡献是对混合政体思想的发展，最优良的政体是把这三种政体的有利特性结合起来。 实际上古罗马共和国的政体构造体现了混合政体的思想。古罗马共和国的执政官就代表君主的因素，元老院代表贵族的因素，公民大会及保民官则代表了平民的因素，使得各方的利益都够得到兼顾，这是混合政体的最早实践。    从“黑暗时代”到启蒙时代 西罗马帝国覆灭之后，欧洲就进入了漫长的中世纪（过去中世纪被称为“黑暗时代”，但今天的很多历史学家正在改变这一观点，甚至有人把中世纪视为欧洲从古希腊、古罗马的文明到现代文明的一个重要转换）\n  托马斯·阿奎那：神学政治哲学家，重要工作是把亚里士多德的作品系统地介绍给西方基督教世界。\n  马基雅维利：著有《君主论》和《论李维》，是政治现实主义的代表人物。阐述了将政治与道德相分离的原则，同时也敏锐地嗅觉到了欧洲民族国家革命即将拉开序幕。\n 马基雅维利并不能被简单地视为一个君主论者——即便他在《君主论》一书中的思想亦非完全如此。可以确定无疑地说，马基雅维利有着清晰的古典共和主义思想。    欧洲政治思想的重要转换是16—17世纪宗教改革的兴起。当时的天主教会成了一个特权机构——既是一个思想控制机构，又是一个利益分配机构。\n  马丁·路德和约翰·加尔文：对天主教会当时的很多做法和腐败提出了尖锐批评，他们希望重新定义信徒与教会的关系、国家与教会的关系。\n  让·博丹：主权学说（主权是超越其他权力之上的、不受法律约束的最高权力）。\n 这种主权思想跟古希腊和古罗马的传统很不一样，跟后来启蒙运动时代的政治哲学差异就更大了 主权的出现乃是把国家同包括家庭在内的所有其他群体区别开来的标志，把公民身份定义为对主权者的服从。 把主权定义为“不受法律约束的、对公民和臣民进行统治的最高权力”，并对最高权力的概念进行分析。 认为凡是未陷于无政府状态的统治，凡是“秩序良好的国家”，在其间的某处肯定存在着这样一种不可分割的权威渊源。 把主权理论适用于他对国家从属机构的讨论。在一个君主制的国家里，议会的职能必须是咨询性质的。同样，行政官员所行使的权力也是主权者授予的。 还包含着自相矛盾和含糊不清的成分。总体上认为，主权是不受任何约束的最高权力，但他同时认为“主权者是受上帝之法和自然法约束的”    托马斯·霍布斯：《利维坦》，从学理上阐明了国家的必要性。他的论证从自然状态出发，开创性地引入了个人主义方法论，结论是国家乃人类社会所必需。\n  约翰·洛克：早期自由主义的杰出代表，他认为统治应该基于被治理者的同意，提出了立法权与行政权两权分立的思想，认为政府的首要职责是保卫人们的生命权、自由权与财产权。\n  孟德斯鸠：某种程度上是对洛克的继承，他一方面反对专制和捍卫自由，另一方面论证了三权分立的必要性。\n  卢梭: 完善了社会契约论，并提出了主权在民的学说。被视为系统阐明民主理论的重要源头。他把社会契约视为组织政治社会的条件\n   人是生而自由的，却无往不在枷锁之中。自以为是其他一切的主人的人，反而比其他一切更是奴隶。--《社会契约论》\n   卢梭的这种民主观意味着他更强调直接民主，而非代议制民主。\n    《联邦党人文集》：“野心必须用野心来对抗”，“在组织一个人统治人的政府时，最大困难在于必须首先使政府能够管理被统治者，然后再使政府管理自身。毫无疑问，依靠人民是对政府的主要控制；但是经验教导人们，必须有辅助性的预防措施。”\n 由于被视为分权思想的经典作品，《联邦党人文集》常常被忽视的是这部作品对强有力的联邦政府的倡导和对政府效能的重视。“决定行政管理是否完善的首要因素就是行政部门的强而有力。”    经验研究范式的兴起 19世纪政治学的主要特征是整体上向经验研究的转向。实证主义（positivism）哲学开始兴起。\n实证主义：以实际验证为核心的哲学思想，注重以科学方法来观察和研究经验事实，通过这种观察和研究来探究事物的本源及事物与事物间的联系。\n基于经验观察基础上的研究，而非纯粹的逻辑演绎和推导，成为19世纪政治学的新趋势。与19世纪之前的政治哲学和政治思想研究不同，政治学的经验研究试图在事物和事物之间、现象和现象之间建立一种因果联系，发掘政治现象背后的因果机制\n从政治科学到研究范式的多样化 20世纪以来，政治学研究迎来了政治科学的时代。\n 卡尔·波普尔《猜想与反驳》：社会科学研究的一个标准是研究者提出的理论假说应该具有**“可证伪性”（falsifiability）**，也就是具有证伪机制。“一个系统只有作出可能与观察相冲突的论断，才可以看作是科学的；实际上通过设法造成这样的冲突，也即通过设法驳倒它，一个系统才受到检验。”。  举例：有人提出这样的一个假说——“所有天鹅都是白的”。对于这个假说，证伪就在于找到一只非白天鹅，中间的证伪机制是明确的。    政治科学研究的核心是探索政治现象背后的因果关系，而不是别的什么研究。在政治科学研究中，这种因果关系的理论形式经常表述为一个理论假说——即何种原因导致何种结果。\n20世纪向政治科学研究的转向，美国开始取代欧洲成为政治学研究的中心。\n20世纪10到30年代，美国政治学研究中开始兴起了芝加哥学派，用交叉学科的研究战略，开始在政治学领域引入定量研究方法，同时开始为定量研究收集大规模的调查数据。\n这场政治科学的革命也被称为行为主义革命。过去，政治学的研究重点是政治制度和政治秩序等。到了行为主义革命阶段，研究重点变成人的政治行为。行为主义既不赞同政治哲学的思辨方法，亦不认可对政治制度的静态描述，而是认为政治学应该研究实际存在并且可以观察到的人的政治行为。因此，行为主义比较重视数据的收集和整理。\n（ps. 后来，芝加哥学派的研究方法在美国一流高校里开始传播。很多早期在芝加哥大学受过训练的学者后来前往密歇根大学任教，并把密歇根大学发展成了美国政治学调查研究的重镇和行为主义革命的基地。直到今天，密歇根大学仍然维持着这一领域的强大优势。）\n 行为主义革命的进一步发展也引起了学术界的反思。行为主义革命强调恪守价值中立原则，反对做价值判断，认为应该专注于事实和经验。  列奥·斯特劳斯认为：“（那种认为）价值判断不是主观的，归根到底是受理性控制的观点，导致了在涉及正确与错误、善与恶时出现一种做出不负责任的判断的倾向。”行为主义研究意味着价值被放弃了. 戴维·里西《政治科学的悲剧》: 作为一门实证科学，如果政治科学无法系统性地吸收道德和伦理价值的因素，也无法对政治行为承担责任，它注定是要令人失望的。    行为主义革命之后，到20世纪70年代左右，经济学研究方法在其他社会科学研究领域的扩展，推动了理性选择范式的兴起。这股潮流被称为**“经济学帝国主义”。**\n理性选择理论（Rational Choice Theory）：美国政治科学领域最有影响的研究范式与理论流派。核心是用经济学理论和方法研究政治，特别是借鉴新古典经济学的视角，它把政治领域类比为市场，把政治活动（比如选举）视为交易。\n理性选择范式基于经济人假设，有三个基本属性：（1）人是自利的；（2）人是理性的；（3）人追求效用最大化。\n 安东尼·唐斯《民主的经济理论》：把民主政治过程视为政治家和选民之间的理性选择与市场交易的过程。在政治市场上，政治家为了获得选票，选民为了获得政策收益，两者之间形成了类似于政治市场的交易行为。 詹姆斯·布坎南：姆斯·布坎南，他在研究中认为，政治家、官僚和选民都是理性经济人，政治过程同样被视为政治家作为厂商与选民作为顾客之间的交易。认为财政赤字植根于民主政治的运作机制当中，是民主政体选举竞争条件下政治家与选民互相博弈的结果。  与理性选择学派相关的：\n 新古典经济学研究分支：新制度主义经济学。  诺思把国家视为“使福利或效用最大化的统治者”。国家通过作为一个统治者，追求的是通过提供安全与秩序来获取统治租金收入的最大化   博弈论：把政治视为不同政治参与者博弈的过程。  ","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap2/","tags":null,"title":"政治学：智者如何思考"},{"categories":null,"contents":"泛化误差：在“未来”样本上的误差\n经验误差：在训练集上的误差，也称为训练误差\n泛化误差越小越好，但是经验误差不一定越小越好，因为可能出现过拟合\n 留出法：将数据集划分为训练集和测试集  保持数据分布一致性(如分层采样) 多次重复划分 测试集不能太大也不能太小(1/5 - 1/3)     k-折交叉验证法  ","permalink":"http://tristonk.com/notes/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/chap1/","tags":null,"title":"模型选择"},{"categories":null,"contents":"词法分析器的作用 读入字符流，组成词素，输出词法单元序列\n过滤空白，换行，制表符，注释等\n将词素添加到符号表中\n逻辑上独立于语法分析，但是通常在同一趟完成\n词法单元：\u0026lt;词法单元名，属性值（可选）\u0026gt;\n模式：描述了一类词法单元的词素可能具有的形式\n词素：源程序中的字符序列\n一个模式匹配多个词素的时候，必须通过属性来传递附加的信息，属性值用来语义分析、代码生成，属性值通常是一个结构化数据。比如词法单元id的属性有词素，类型，第一次出现的位置等。\n词法单元的规约（正则表达式） 正则表达式可以高效简洁的描述词法单元式用到的模式类型。\n字符表：一个有穷的符号集合\n串：字母表中符号的有穷序列\n语言：某个给定字母表上的串的可数集合\nL的Kleene闭包：$L^*=\\cup_{i=0}^{∞}L^i$\n正则运算的优先级：* \u0026gt; 连接 \u0026gt; |\n正则集合：可以用一个正则表达式定义的语言\n正则定义\n正则表达式的基本运算符：选择，连接，Kleene闭包\n扩展的运算符：\n 单目后缀：+ 零个或一个实例：？ 字符类：[a1a2..an]等价于a1|a2|..|an  词法单元的规约（状态转换图） 状态转换图  状态：在识别词素时可能出现的情况  可以看作已处理部分的总结 某些状态为接受状态或最终状态     词法分析器生成工具及设计 有穷自动机 ","permalink":"http://tristonk.com/notes/compiler/lesson2/","tags":null,"title":"词法分析"},{"categories":null,"contents":"对于这里的村民来说，下岬村的意义远远不止于其行政功能。这里也是他们生存的精神空间，是他们的本土道德世界。借用Kleinman夫妇的话，在这个世界里，“权力、地位、威望、物质资源、民族认同、社会秩序等等生存的基本要素得到了确实的体现。由于涉及人们的根本利益与价值体系，所有社会行为都与道德有关。”\n村干部与国家角色的变迁 从更高的层面上看，村庄基层领导的变迁是国家与农民关系变化的最好标志。在下岬人看来，中央政府所体现的社会主义政权远在1000公里之外的北京，因此与他们之间只有抽象的关系。而由村、镇干部所代表的地方政府才是国家政策的真正执行者与各种运动的真正推动者。对于村民来说，国家政策如果不在当地推行就没有重要性，中央政府只有在对他们的生活产生影响时才体现出权力。\n下岬村干部在执行国家政策时从原来的加码转变为减码（1995）。在五六十年代，出于意识形态与对革命的忠诚，村干部会努力将国家政策执行到极端的程度。70年代至80年代初，那批非常实际的干部总是试图在国家政策与地方利益之间寻求平衡。非集体化之后的干部就尽可能不去执行国家的政策，只是去完成一些税收与计划生育之类的“硬指标”。这种情况在90年代持续发展，日益令上级担忧。而且，到90年代末期，村干部完成硬指标的手段越来越粗暴、生硬，同时还完全不顾甚至抵制其他方面的政策，包括减轻农民负担与村民选举。虽说收上来的税费并非完全上缴中央政府，但是在农民看来，国家征税的手段越来越具强迫性。同时，政府具有的诸如制定、推行法规等其他功能却严重退化，因为地方基层干部只顾自身利益。在我看来，村干部已经变成了一个特殊利益集团，借用Duara的话，是成了一批“唯利是图的经纪人”（1988: 42-57）。在许多情况下，基层干部的所作所为违背了国家政权的长远利益，尽管他们在短期内能够替国家收上税。\n在非集体化之后，国家对地方的渗入可以说在某些层面上加强了，而在另一些层面上却被削弱了。可以肯定的是，国家对村民的日常生活无论是在公众还是私人层面上的干预都比过去少得多，而且也不再管经济方面的活动。不过，中央一系列分权与财政改革的措施导致国家对地方公共设施与社会文化生活的支持大大削减，因此公共事业方面的资金与地方政府经费也随之大为减少。地方政府为了筹集经费，就不得不通过行政司法手段（包括动用警察与法庭）以及依靠作威作福的村干部（包括黑势力）来征收税费，从而使得国家政权更深地渗入村一级的基层社会。\n90年代的情形却是上述两种状况的最坏结合：政府一方面增加税收，另一方面提供的服务却越来越少。的确，重新分田到户使农民得以避免国家通过集体化来高度盘剥农民，但是农民如今却是眼睁睁地看着国家拿走他们的大部分收成。因此，许多村民抱怨说，国家当初把农民当作革命的主力，现在却抛弃了农民。政府由原先那种事事插手的家长式统治向只管收税而不问民生的方向转变，在下岬人中间造成了极大的思想混乱，在公共生活方面尤其如此。\n公众生活的起落 人们越来越多的空闲时间都是在家里过的，除了看电视、打麻将，在村里就找不到更好的事去做了。不断有人告诉我说，村里已经多年没有任何公共活动。村干部对组织公共文化活动和村民会议根本没有兴趣\n非集体化之后，在政治参与、公共物品分配、文化、道德价值等各方面，下岬村的公共生活都大大衰退。\n亲缘结构与社会关系 ","permalink":"http://tristonk.com/notes/%E7%A7%81%E4%BA%BA%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8F%98%E9%9D%A9/chap1/","tags":null,"title":"下岬村的经济体制、公众生活喝社会关系"},{"categories":null,"contents":" 二极管：功能，结构类型，符号， 重点：PN结的结构形成与他的工作原理，伏安特性 二极管的简化模型，如何运用模型分析 齐纳二极管的工作原理\n 二极管 在PN结上加上引线和封装，就成为一个二极管\n二极管的功能  PN结单向导电性：整流、检波、开关 PN结压降：温度传感器、参考电压 非线性电流-电压特性：调节电压、限制电压、无线电调谐、产生射频振荡、发光  二极管的分类  结构：  点接触型：结面积小、结电容小、用于检波和变频 面接触型：结面积大，用于工频大电流整流电路 平面型：往往用于集成电路制造工艺中，面积可大可小    二极管的伏安特性  二极管的伏安特性曲线和PN结的伏安特性曲线接近，但是有所变化  体电阻的存在，电流比PN结较小一点 反向电流大一点 但是在NJU的PPT上给出的伏安特性曲线    死区：指的从正向电压0到正向电流开始快速变化的区域\n  硅Si的死区电压：$V_{th} = 0.5-0.8V$\n  锗Ge二极管的死区电压：$V_th = 0.1-0.3V$\n  温度升高，伏安特性曲线正向左移，反向下移(粒子运动加剧，本征激发加强)\n  室温下，上升一度，正向压降2-2.5mv，上升十度，反向电流增大一倍\n  二极管的主要参数  最大整流电流$I_F$: 二极管连续工作时，允许流过的最大整流电流的平均值 **反向击穿电压$V_{BR}$和最大反向工作电压$V_{RM}$**: 二极管反向电流急剧增加对应的反向电压值为反向击穿电压，为安全，最大反向工作电压为反向击穿电压的一半 反向电流$I_R$: 室温下最大反向工作电压的反向电流值。硅二极管一般时纳安级，锗二极管时微安级 极间电容$C_d=C_B+C_D$ **反向恢复时间$T_{RR}$**:从正向偏置的导通状态转为反向偏置状态，需要一定的时间才能变成截止状态。 主要原因时扩散电容的影响 正向压降$V_F$：规定正向点留下，二极管的正向电压降  Si:0.6-0.8V Ge:0.2-0.3V    二极管基本电路与分析 图解分析 使用欧姆原理得到的直线与二极管V-I特性曲线的交点\n数学上将方程与指数模型联立，使用迭代法求解\n简化模型 理想模型  近似条件：电源电压远大于电压降 正向偏置：管压降为0V 反向偏置：电阻无限大 理想二极管和实际的二极管的符号差别在于没有中间那条线 （但是ppt上原本也没有，用涂色表示  恒压降模型  管的恒压降恒定：  硅管0.7V，锗管0.3V   近似条件：$i_D$近似等于或者大于1mA 相当于理想模型和一个电压串联  折线模型 $v_D=0.5V$（硅管）\n相当于理想二极管、电源、电阻串联\n小信号模型 二极管在正向特性的某一小范围内时，正向特性可以等效为一个微变电阻\n$r_d = \\frac{V_T}{I_D}$，常温下$V_T=26mV$\n模型分析法的应用 整流电路 利用二极管的单向导电性\n静态工作状态分析 限幅电路 开关电路 判断二极管处于导通还是截止状态，然后观察阳、阴两极之间时正向电压还是反向电压，前者则二极管导通，否则二极管截止\n低电压稳压电路 利用二极管的正向压降特性获得较好的稳压性能\n 硅管：0.7V 锗管：0.3V  小信号工作情况 齐纳二极管(稳压管) 图中的$V_Z$表示反向击穿电压，即稳压管的稳定电压\n作用在于：$\\Delta I_Z$ 很大，但是只引起很小的电压变化$\\Delta V_z$, 动态电阻越小，稳压管的稳压性能越好\n$\\alpha$: 温度每变化一度，$U_z$的变化\n$$V_Z=V_{Z0}+r_ZI_Z$$\n限定工作电流$I_Z(min)\u0026lt;I_Z\u0026lt;I\u0026lt;Z(max)$\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E4%BA%8C%E6%9E%81%E7%AE%A1/","tags":null,"title":"二极管"},{"categories":null,"contents":"Generating functions 生成函数的作用：在计数问题中，利用性质构造生成函数，利用生成函数求解系数，系数对应了选择的种数\norinary generating function(OGF): $G(x)=\\sum_{n\\geq 0 }a_nx^n$\nusing \u0026quot;+\u0026quot; to represent \u0026quot;OR\u0026quot;, using the multiplication to denote \u0026quot;AND\u0026quot;\n例如如果有3个红球，4个蓝球，相同颜色球不可区分，那么我们的选择为$(1+x+x^2+x^3)(1+x+x^2+x^3+x^4)$，如果是需要选择k个球，则不同的选择方式种数就是 $x^k$ 的系数\nsloving recurrences 求解生成函数的四步方法：\n 写出 $a_n$ 的递归定义（如 $a_n = a_{n-1} + a_{n-2}$ 两边同时乘以$x^n$, ，左边即为生成函数G(x)，并将右边化为G(x)的形式 求解G(x)，得到关于x的函数 对G(x)进行级数展开，得到$a_n$  algebric operations on generating functions Let $G(x)=\\sum_{n\\geq 0}g_nx^n$, $F(x)=\\sum_{n\\geq 0}f_nx^n$\nshift : $x^kG(x)=\\sum_{n\\geq k}g_{n-k}x^n$\naddition : $F(x)+G(x)=\\sum_{n\\geq 0}(f_n+g_n)x^n$\nconvolution : $F(x)G(x)=\\sum_{n\\geq 0}\\sum_{k=0}^nf_kg_{n-k}x^n$\ndifferentiation : $G'(x) = \\sum_{n\\geq 0}(n+1)g_{n+1}x^n$\nexpanding generating functions 泰勒级数：$G(x)=\\sum_{n\\geq 0}\\frac{G^{(n)}(0)}{n!}x^n$\n几何级数：$\\frac{1}{1-x}=\\sum_{n\\geq 0}x^n$，所以对于$\\frac{a_1}{1-b_1x}+\\frac{a_2}{1-b_2x}+..$对应的$x^k$的系数就是$a_1(b_1)^k+a_2(b_2)^k+..$\nNewton's formular：若$|x|\u0026lt;1$,则$(1+x)^{\\alpha}=\\sum_{n\\geq 0}\\binom{\\alpha}{n}x^n$\nCatalan Number $C_n$等价情况\n 括号匹配 有(n+1)个叶子的完全二叉树 不越过对角线的大小为n的正方形格子的两个对点之间的路径数 n个+1，n个-1数的排列顺序使得前缀和永远为非负数  可以考虑完全二叉树的情况，假设对于根节点，左边有$k+1$个叶子,右边有$n+1-(k+1)$个叶子，那么也就对应着$$C_n=\\sum_{k=0}^{n-1}C_kC_{n-1-k}$$\n可以利用生成函数解得： $$C_n=\\frac{1}{n+1}\\binom{2n}{n}$$\nQuicksort 略\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/generating-functions/","tags":null,"title":"Generating Functions"},{"categories":null,"contents":"应用层 不考\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ying-yong-ceng/","tags":null,"title":"应用层"},{"categories":null,"contents":"数据模型  第二章 数据模型\n2.1 数据模型的基本概念\n 数据模型及其组成成分：数据结构，数据操作，数据约束 数据模型的核心，不同类型数据模型的区分依据 三个抽象层次上的数据模型概念：概念数据模型，逻辑数据模型，物理数据模型  2.2 数据模型的四个世界\n 现实世界，概念世界，信息世界，计算机世界  2.3 概念世界与概念模型\n E-R模型与E-R图（包括扩充E-R模型） 实体，属性，联系 多值属性（multi-valued attribute） \u0026amp; 组合属性（composite attribute） 联系上的函数对应关系 \u0026amp; 参与方式（Cardinality of Entity Participation in a Relationship） IS-A联系，弱实体 面向对象模型：对象，对象标识符，类，方法，超类和子类，聚合和分解，继承和合成  2.4 信息世界和逻辑模型\n 关系模型：关系，属性，值域（域），元组，关系数据库，关键字  2.5 计算机世界与物理模型\n 逻辑模型的物理存储：项，记录，文件，索引，集簇 提高文件访问效率的常用方法：索引，集簇，HASH   数据模型的基本概念 数据模型： 描述数据的结构，定义在该数据结构上可执行的操作以及数据之间必须满足的约束条件\n组成：数据结构、数据操作、数据约束\n数据结构 描述数据的类型、内容、性质以及数据间的联系\n是一个数据模型的基础，也被称为数据模式，数据模式是划分不同数据模型的依据，是数据模型的核心\n数据操作 不同数据结构上不同的操作方式与操作类型\n数据约束 描述数据结构之间数据的相互联系，包括语法/语义关系，数据间的制约与依存关系、动态变化规则\n不同层次的数据模型 概念数据模型：按照用户的观点实现世界中的数据和信息进行建模，刻画内在结构与关系，但是不涉及具体的描述细节与实现，如实体-联系(E-R)模型、面向对象模型\n逻辑数据模型（对应了外模式与概念模式）：DBMS实现，按数据库系统观点对数据建模，现在一半分为结构化与非结构化，常见的有关系模型、对象关系模型\n物理数据模型（对应了内模式）：DBMS实现，按照计算机系统观点对数据进行建模\n数据模型的四个世界 使用数据模型概念可以将现实中的反映到计算机中数据库的实现，是一个逐步反映的过程，包括现实世界、概念世界、信息世界、计算机世界\n现实世界：根据用户需求（数据需求与处理要求）而划定边界的一个应用环境\n概念世界：E-R模型，OO模型，这些与具体的DBMS和计算机无关\n信息世界：以概念世界为基础，选定特定的DBMS构造而成的逻辑数据模型\n计算机世界：在计算机中物理实现，侧重于数据库物理存储结构的描述，包括存储结构的设计、存取路径的设计(文件结构：堆/直接/索引)、存储空间的分配\n概念世界与概念模型 是一个较为抽象、概念化的世界\nE-R模型（实体-联系模型） 核心概念：实体、属性、联系\nER图：实体：矩形； 属性：椭圆形； 联系：菱形；连接实体集与属性，联系与属性，实体集与联系\n实体：客观存在且能相互区别的事物，概念世界中的基本单位，每个实体都有一个实体名用于区分\n属性：实体所具有的某种特性或者特征，属性可以有值，一个属性可以取的值的集合称作该属性的域，每个属性有一个属性名，所有属性的属性名构成了这个实体的实体型，具有共性的实体指的是有相同的实体型\n联系：一个实体集中的实体与另一个实体集中的实体存在的对应关系，包括二元联系，多元联系，单个实体集内部的联系\n函数对应关系：\n 1:1 1:m m:n  联系也可以具有属性\n属性的描述：属性名\n实体的描述：实体+实体型\n实体集（具有相同实体型的实体的集合）的描述：实体名+实体型+关键字\n扩充E-R模型 IS-A联系：若实体集B是实体集A的一个子集，且具有比实体集A更多的属性，称两者存在IS-A联系，其中实体集A称为超实体集，实体集B称为子实体集，实体集B可以继承A中所有属性\n在EE-R图中，用子实体集指向超实体集的单项箭头表示该联系\nIS-A具有继承性与传递性\n要求子实体集的并集等于超实体集(覆盖约束)与任意两个子实体集不相交（不相交约束）\n弱实体：实体A的存在需要依赖其他某个实体（如职工vs家属），在EE-R图中表示为从弱实体到联系的有向箭头\n属性的划分：标识符(关键字)、描述符、组合属性（多个简单的属性用来描述一个属性，如fname,lname用来描述name这个属性）、多值属性（多值的，如hobbies，双线段表示）\n属性基数：二元组(x,y)描述属性上的取值数量特征\n (0,?) 可以取空值 (1,?) 不允许取空值 (?,1) 每一个实体在该属性上最多只有一个值，即单值属性 (?,N) 每个实体在该属性上可以取多值，即多值属性  参与基数：（实体,联系）\n 最大参与基数：max-card(E,R)，为1表示最多与F中实体一个有联系(单值参与)，为N是可能多个实体有联系(多值参与) min-card(E,R)：为0可能与另一个实体集中的无联系(可选参与)，为1至少与一个有联系(强制参与) 参与基数：Card(E,R)=(min-card(),max-card())  面向对象模型 对象：能相互区分的事物,由对象标识符、静态特性（对象中的属性）、动态特性（可以施加在对象上的方法/操作）组成\n对象标识符：每个对象均具有的一个能相互区别的名字\n类：具有相同属性、方法的对象集合\n方法\n超类和子类（IS-A关系）\n聚合和分解（IS-PART-OF关系）\n继承和合成：单继承/多继承（子类有1/多个超类）\n谓词模型 P(x,y,z):为true当且仅当存在一个元组(x,y,z)满足谓词P\n信息世界和逻辑模型 E-R模型可以对应的逻辑模型：层次模型、网状模型、关系模型\nEE-R模型可以对应的逻辑模型：对象关系模型\n面向对象模型对应的逻辑模型：面向对象模型\n关系模型 基本数据结构：二维表\n数据操纵：对一张表/多张表间的查询，对一张表的删除、插入与修改\n关系模式：关系的关系名及其属性名的集合\n关系数据库模式：关系数据库中所有关系的关系模式的集合\n元组：关系中的每一行\n关键字：属性集中唯一标识关系中的一个元组\n主关键字：候选关键字中选一个\n外关键字：关系R中的属性集F取值来自于关系S中的主关键字K，称属性集F是关系R的外关键字\n计算机世界与物理模型 项：文件系统中最小基本单位，项内符号不能继续分割\n记录：若干项组成，记录内的各项间有内在语义联系\n文件：记录的集合\n提高读写操作效率 索引：文件的记录与物理地址间建立一张对应关系表(可以有多级索引)\n集簇：查找记录时按照某项的项值查找，将具有相同或者相邻的项值的记录聚集在相同磁盘块内\nHASH：通过hash间查找的记录转换成物理地址\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/data-model/","tags":null,"title":"数据模型"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 2\n 这个读书笔记建立在已经看完了西瓜书第16章的基础上，略过了很多东西\n 部分该章节西瓜书笔记可点击, 因为太懒了，后面一部分的笔记还没抄\n nonsassociative problem: one that does not involve learning to act in more than one situation associative problem: when actions are taken in more than one situation\n本章主要围绕Multi-armed Bandits（多臂老虎机问题）展开讨论，以此为例介绍几种算法\n2.1 A k-armed Bandit Problem Problem definition You are faced repeatedly with a choice among k different options, or actions. After each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. Your objective is to maximize the expected total reward over some time period\n记号 第t步的动作：$A_t$, 对应奖赏$R_t$ 对于一个动作，预期奖赏为$q_*(a) = E[R_t | A_t = a]$ 第t步选择动作a的估计奖赏为$Q_t(a)$\n选择最优：exploiting 选择非最优：exploring\n然后就是探索与利用的关系，看西瓜书就行\n2.2 Action-value Methods 计算Q：取平均值\n有多种方式求解：\n greedy（全利用） $\\epsilon - greedy$  2.3 The 10-armed Testbed 比较了一下$\\epsilon - greedy$与$greedy$的差异，优缺点以及优化看西瓜书即可\n2.4 Incremental Implementation 如何快速更新Q估计值： $Q_{n+1} = Q_n + 1/n(R_n-Q_n)$\n上为以下公式的一种形式\n$$NewEstimate\\leftarrow OldEstimate + StepSize [Target − OldEstimate]$$\n$[Target − OldEstimate] $被称为是估计中的$error$ 将$StepSize$表示为$\\alpha$, 更一般的，表示为$\\alpha_t(a)$\n2.5 Tracking a Nonstationary Problem stationary: the reward probabilities do not change over time\n对于Nonstationary的问题，我们要给更多的权重给最近得到的rewards。 一种常见的方式是给$\\alpha$设置一个常数值（展开可知$Q_{n+1} = (1-\\alpha)^nQ_1+\\sum_{i=1}^n\\alpha(1-\\alpha)^{n-i}R_i$），我们称其为weighted average，因为其权重和为1.有时候也称其为exponential recency-weighted average.\n有时候让$\\alpha$随时间变化而变化，用$\\alpha_n(a)$第n次选择动作a时的stepsize。 要保证在数量足够大的情况下能够让估计值趋向于真实值，根据随机近似理论(stochastic approximation),要满足以下条件：\n$$\\sum_{n=1}^\\infin a_n(a) = \\infin ,,\\sum_{n=1}^\\infin a_n^2(a) \u0026lt; \\infin $$\nThe first condition is required to guarantee that the steps are large enough to eventually overcome any initial conditions or random fluctuations. The second condition guarantees that eventually the steps become small enough to assure convergence.\n可以看出我们之前让$\\alpha$为一个常数时是满足第一个条件而不满足第二个条件的，这导致其会一直变化，这也正是我们希望在Nonstationary的情况下做到的\n值得说明的是，满足两个条件的参数一般都收敛的比较慢，需要仔细的调参。故而虽然在理论分析时考虑这个，但是实际应用时很少考虑这个\n2.6 Optimistic Initial Values 之前提到的所有的方式都某种程度上依赖于初始值的估计$Q_1(a)$, 可以说这些方式都有初始值的偏差（biased by their initial estimates.）对于sample-average methods而言，只需要每个动作试一遍就可以消除这种误差了，但是对于step size为常数的方式而言，这种误差是一直存在的（虽然会不断缩小，理由可见表达式）。\n初始值有时也可以被用于促进exploration，如将其初始值设定的比估计值都大，那么就可以使得会优先把所有的动作都尝试一遍，我们称呼这种为Optimistic Initial Values\n但这种方式不适用于nonstationary的情况，因为任务一旦变化，所有的初始值都不可能始终适用\n2.7 Upper-Confidence-Bound Action Selection 探索是必要的， 但是$\\epsilon - greedy$并没有给出一个偏向性，使得尽可能去探索接近greedy的或者是探索次数还不够多导致并不确定的动作。所以有了upper confidence bound (UCB) action selection\n$$A_t = arg,max[Q_t(a)+c\\sqrt{\\frac{\\ln t }{N_t(a)}}]$$\n其中$N_t(a)$表示动作a在第t次前被执行的次数，the number c \u0026gt; 0 controls the degree of exploration，c可以看作是对于估计的信任程度\n UCB often performs well, as shown here, but is more difficult than \u0026quot;-greedy to extend beyond bandits to the more general reinforcement learning settings considered in the rest of this book. One difficulty is in dealing with nonstationary problems; methods more complex than those presented in Section 2.5 would be needed. Another difficulty is dealing with large state spaces, particularly when using function approximation as developed in Part II of this book. In these more advanced settings the idea of UCB action selection is usually not practical.\n 2.8 Gradient Bandit Algorithms 构建一个数值类型的函数$H_t(a)$使得对于每一个动作a有一定的偏向性\nsoft-max distribution:\n$$Pr{A_t = a} = \\frac{e^{H_t(a)}}{\\sum_{b=1}^k e^{H_t(b)}} = \\pi_t(a)$$\n对于第t步选择了$A_t$之后，更新各个概率为\n$H_{t+1}(A_t) = H_t(A_t) + \\alpha (R_t - \\overline{R_t})(1-\\pi_t(A_t))$ and\n$H_{t+1}(a) = H_t(a) - \\alpha (R_t - \\overline{R_t})\\pi_t(a)$\n其中$ \\overline{R_t}$ 表示除去第t步之外的所有奖赏的平均值，其相当于一个baseline，如果奖赏高于这个baseline，那么对应动作$A_t$的在未来被选择的概率将增加，否则将减少\n2.9 Associative Search (Contextual Bandits)  However, in a general reinforcement learning task there is more than one situation, and the goal is to learn a policy: a mapping from situations to the actions that are best in those situations.\n  associative search task, so called because it involves both trial-and-error learning to search for the best actions, and association of these actions with the situations in which they are best. Associative search tasks are often now called contextual bandits in the literature.\n  Associative search tasks are intermediate between the k-armed bandit problem and the full reinforcement learning problem.If actions are allowed to affect the next situation as well as the reward, then we have the full reinforcement learning problem.\n ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl2/","tags":null,"title":"Multi-armed Bandits"},{"categories":null,"contents":"{% note primary %}\n阅读文献 金耀基：“中国人对私隐权的-中国人文鼎细等线的公私观念”\n林语堂：《中国人》第四章 “人生的理想”\nHorace Miner. Body Ritual among the Nacirema\n{% endnote %}\n汉语中的社会 社：土地之主也。“左祖右庙”。后社由最初的土地之主发展为一种乡村基层组织：里社、乡社。后又发展成志趣相同的人的一个团体，如茶社\n会：集会\n 汉语中一开始社与会是分开的，不怎么连用(就算连用也是表示一个小团体，和社字意思类似)，后日本在翻译society的时候使用了社会一词，之后引入时中国也开始使用社会这个词语\n 社会学中的社会 马克思定义的社会：社会是人们交互作用的产物，生产关系的总合起来就构成了社会关系\n马克思定义的社会是一个实体概念，但不是一个具体的实体概念，是那种通过观察、体会其效用才能证明存在的实体\n社会的“发现”\n村庄社会，民族国家，世界社会、全球社会\n在几百多年前，我国其实并没有民族主义形成，经过战争后才逐渐形成\n社会模型  系统模型，最典型的是结构功能主义，代表人物：帕雷托、斯宾塞、涂尔干、帕森斯 。社会形象：有秩序的整体，共识，一套功能机构 冲突模型，人与人之间相互冲突，争夺资源，最典型的是马克思，意识形态(在系统模型中称为共识，意识形态某种形式上也是一种共识)，“在每一个时代，统治阶级的思想就是这个时代的思想”，意识形态也被叫做“虚假意识”，原因如之前引用的话，只是部分人的共识。 互动模型，最典型的是符号互动论，社会是一种谈判，互动模型与系统模型和冲突模型都不同，他不从宏观角度理解社会，而是从微观角度去理解社会，从人的活动来理解，把社会看作是相互作用、沟通和谈判  文化 \u0026quot;有文化\u0026quot;，“没文化”的语境相关：教育\n社会学意义上的文化 社会学意义上的定义：一个社会或群体共同承认的价值观，遵从的规范，连同他们所创造的物质产品\n“没有文化的人类，事实上根本不存在” --克里福德·格尔兹\n人是“意义”型的动物, 人是“文化型”动物\n文化意义的演变：从泰勒到格尔兹 泰勒:\n 文化或文明是一个复杂的整体，它包括知识、信仰、艺术、法律、伦理道德、风俗和作为社会成员的人通过学习而获得的任何其他能力和习惯 ---E.B.Taylor\n 马林诺夫斯基：在泰勒的基础上增加了物质文化\n格尔兹抛弃了大而全的文化的定义，方便于研究\n 文化是人类用来解释他们的经验，指导他们行动的意义结构 ——格尔兹《文化的解释》\n“我与马克思·韦伯一样，认为人是悬挂在由他们自己编织的意义之网上的动物，我把文化看作这些网。”\n 当代社会学与人类学研究中，主要采用的是格尔兹改造过的文化的定义\n格尔兹将文化看作可以为大众获得的象征(符号)形态，人们通过这些象征形态来体验和表达意义。这一界定将文化的定义从泰勒无所不包的定义缩小，集中到了意义系统\n意义系统——共享的，分享的\n研究文化的其他方向 一些人探索文化的遗传密码，探索人类的大脑结构\n亚文化 当在社会的某一群体中，形成一种既包括一些主流文化特征，也包括某些独特的文化要素时，这一群体的文化，就叫做亚文化\n\u0026quot;亚文化举例\u0026quot;：DISCO，黑人文化\n亚文化应当包括主流文化特征的核心价值观，亚文化与主流文化是相对的，亚文化可能被主流文化所吸收\n反文化 从根本上与社会主流文化相对立的文化，它有意识的对抗社会上的某些最重要的价值和规范，并为此感到自豪\n举例：嬉皮士，披头士\n文化的构成 价值观：社会成员关于好坏、对错、符合或违背人们愿望等的共同看法。是文化中最为核心的部分\n规范：人们共同遵守的对特定环境中人的正当行为方式所作出规定的准则\n主要规范类型：社会习俗，道德，法律\n规范是具体的准则，价值观是抽象的一般观念，价值观是判断规范的尺度，规范是价值观的体现\n物质文化：社会已有的物质形式\n奥格本：文化堕距\n文化是一个整体，牵一发而动全身\n","permalink":"http://tristonk.com/notes/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E6%A6%82%E8%AE%BA/shxgl2/","tags":null,"title":"社会学概论-社会与文化"},{"categories":null,"contents":"政治观点背后的意识形态   亚当·斯密在《国富论》：他信奉的意识形态被称为自由主义，有人喜欢称之为古典自由主义。\n 人都是自利的，人所有行为的动机都是出于他们自利的打算。 作者把市场机制的力量比喻成“一只看不见的手”——自利的个人会受到这只“看不见的手”的引导“有效地促进社会的利益”。    马克思和恩格斯《共产党宣言》：“科学社会主义”或“共产主义”\n 尽管马克思本人受到了亚当·斯密的很大影响，但两人对市场机制和产权制度的主要观点完全不同。马克思在劳资关系中发明了剩余价值的概念，提出了剥削学说。 按照这种观点，很多毕业生争相到世界500强公司工作，不过是在努力争取一种被“剥削”的资格。而亚当·斯密认为，用劳动力去换取报酬不过是一种正常的市场交易行为；而资方并非不劳而获或平白无故就能挣钱，利润被视为经营的回报。    埃德蒙·柏克《法国革命论》：保守主义\n 认为应该珍视一个社会中的成见，他甚至直截了当地把变革视为一件坏事，而把保守视为一件好事 把“绝对的民主制”视为亚里士多德意义上的暴民政体    现代意识形态的兴起 主要的现代意识形态均诞生于欧洲。\n从概念上说，意识形态是现代社会科学体系中的一个概念和范畴，意指“一个行动导向的信念体系，一套以某种方式指导或激励政治行动的相互联系的思想观念”\n 意识形态需要解释世界 意识形态通常具有改造世界的企图心 意识形态通常还带有行动导向的色彩。特定的意识形态通常会鼓励某些特定的行动或行为，有时这种特定行动和行为可能发展为某种运动、政党甚至是革命 群众取向。意识形态如果要成为成功的意识形态，最终一定要简化到普通民众能够理解的语言，甚至最后简化为几个口号 值得提醒的是，意识形态的口号与号称在某种意识形态指导下的政治实践是两回事  什么是自由主义 自由主义被认为是资本主义和工业革命时期的意识形态，大概在18世纪晚期和19世纪早期趋于成熟。\n 政治上，主张立宪政府与个人自由。自由主义的基本政治主张是要有一个有限政府或立宪政府，政府的权力、行为和边界要受到强有力的约束。政府不能想干什么就干什么，其行为应该有明确限定。同时，社会中的普通公民和法人的权利应该享有明确的保护，特别是要防止他们受到政治权力恣意妄为的侵害。 经济上，反对重商主义（重商主义曾经是非常流行的政策主张，重商主义今天已经演变为经济民族主义或贸易保护主义）。主张自由放任，它赞同亚当·斯密所阐述的“看不见的手”原理。自由主义认为，政府要尽可能少干预市场，应该由“看不见的手”来协调市场主体的行为，而这是最有效率的一种方式。国家的合理角色被界定为“守夜人”。换句话说，一个理想国家或政府的主要角色应该是制止犯罪、防止非法的暴力及提供基本的秩序。关于就业、教育、社会福利等都不要管。  古典自由主义的倡导：   个人主义原则：人类个体本身的价值和权利就是至高无上的，这些权利无须依赖基本公民身份以外的其他任何身份，这些权利不能被国家或任何集体剥夺。把个人因素视为整个社会创造动力的来源。\n  个人自由原则：古典自由主义会认为国家或社会可以干预个人行为的惟一正当理由是为了保护其他人同等的自由与权利。\n  理性原则：相信随着人理性力量的发展，对自然和社会的科学知识的进一步发掘，这个社会能够不断地获得进步和加以改善。由于这种进步史观，自由主义倾向于支持变革。\n  平等原则：指形式的平等和机会的平等，而非实质的平等和结果的平等。\n  宽容原则：社会要允许、容纳、甚至是鼓励多样性，宽容各种不同的选择和各种可能的见解。\n  被治理者同意的原则：所有统治都应该基于被治理者的同意。\n 自由主义未必主张民主政治。但如果说自由主义可能支持民主的话，很大程度上是因为统治要居于被治理者同意的这一原则。 但同时自由主义非常警惕普通民众是否会以多数投票方式侵犯自由权利，是否会导致托克维尔和密尔所警惕的“多数暴政”问题。所以，自由主义通常认为，民主政治同时需要宪政原则的约束。    宪政原则：政府权力应该受到明确的限制\n  自由放任原则：主张自由放任，无论是经济政策上还是社会政策上。认为守夜人国家就是理想的国家类型\n  古典自由主义的大师们  约翰·洛克：基于自然法和契约论，政府的权力应该来自于被统治者的共同认可或者一致同意，设立政府的唯一目的就是保护国民的生命权、自由权和财产权。  《独立宣言》开篇即充满了洛克思想的影子。所以，从《独立宣言》可以看出，美国建国之初的政治意识形态最接近于自由主义，或者说美国就是一个以自由主义立国的国家。   亚当·斯密：总体上认为，人是自利的，其追求自利的过程客观上会在“看不见的手”的引导下促进社会的利益，所以他主张自由放任政策与守夜人国家。 约翰·斯图亚特·密尔《论自由》：“人类可以个别地或集体地对任何成员的行动自由进行干涉，其唯一正当理由旨在自我保护。”。其思考的起点是假定每个人的自由都是绝对的。但如果每个人都拥有不受限制的“绝对自由”，当大家行使这种“绝对自由”时，彼此可能会发生互相侵害和冲突。所以，一个社会必须要给这种自由以一定的限制  自由主义的演进与嬗变 古典自由主义者未曾预见或难以有效回应间歇性的经济危机、贫富悬殊以及托拉斯和大企业垄断等问题。客观上，大规模城市化对政府产生了极大的公共服务需求。在这种背景下，陆续兴起的其他不同意识形态开始构成对古典自由主义的挑战，特别是保守主义和社会主义。\n自由主义意识形态内部兴起了现代自由主义。现代自由主义既是对古典自由主义的继承，又是对古典自由主义的改造。\n现代自由主义认为，原先高度自由放任的制度安排是不恰当的，应该让政府发挥更积极的作用。因此，现代自由主义有两个基本特点：一方面，是尊重过去基本的制度安排，包括尊重私人财产权和市场经济，尊重宪政、法治与公民的自由权利；另一方面，在此基础上，主张强化政府干预——包括对市场、行业和企业的管制，加强对劳工阶层的保护以及建设福利社会。\n从社会实践来看，强化政府干预的大趋势基本上是难以阻挡的。大概从1870年左右开始，到整个20世纪的多数时间里，政府规模和政府干预都经历了大幅扩张。\n 约翰·梅纳德·凯恩斯：如果整个市场自由运转，采用自由放任政策，就会出现有效需求不足的问题，所以政府干预就成为必要。与古典自由主义不同，凯恩斯倾向于认为政府对经济增长和稳定负有责任。凯恩斯的宏观调控主要是指财政政策与货币政策 约翰·罗尔斯《正义论》：正义是社会制度的首要德性，正像真理是思想体系的首要德性一样  第一个正义原则：每个人都拥有平等的权利来享有最广泛的、与他人类似的自由相容的基本自由。（自由原则） 第二个正义原则：社会和经济的不平等应该：（1）有利于受惠最少者的最大利益；（2）职位和机会应该向所有人开放（平等原则）    新古典自由主义的复兴 从20世纪30年代到60年代，是欧美发达国家现代自由主义的鼎盛时期。但是，到了20世纪70年代左右，凯恩斯主义政策开始引发很多问题，经济上主要表现是滞胀现象，即经济停滞与通货膨胀的并存；社会方面表现为福利政策导致的很多社会病。20世纪70年代以后，**新自由主义（neoliberalism）或者叫新古典自由主义（neo-classicalliberalism）**开始崛起。新古典自由主义从概念上看，是对古典自由主义的一种复兴。\n  弗里德里希·冯·哈耶克\n 从方法论上说，哈耶克秉承的是个人主义方法论。他基于个人主义方法论来观察社会和世界。个人不仅被置于集体之前的优先位置，而且个人还被视为社会繁荣的真正根源与动力。 基于其知识论，他的基本观点是：  人在很大程度上是无知的，因为人所具有的知识和信息与其决策所需的信息相比总是少得可怜。因此，人类无法借助完全的理性来认知所有复杂事物背后的关键信息。人是相对无知的，这个社会又需要创新，而创新具有高度的不确定性。因此，一个好的社会要给每一个人及组织以探索和尝试的自由。 从知识的结构来说，这些不同的有用知识总是分散在社会的各处。假定有一个中央机构基于理性和科学、依靠其所知的庞大信息来统一做经济决策，是完全靠不住的。理由是该机构所具有的知识和信息，与决策所需的知识和信息相比，还是少得太多。 反对理性建构主义的观点和社会工程的概念。他认为，人类认为可以凭借自己的完全理性与完全信息，把社会推倒并按照自己的意图重新设计一次，这种想法是完全靠不住的。      路德维希·冯·米瑟斯\n 自由主义所主张的资本主义社会秩序是：资本家如果要发财致富，唯一的途径是像满足他们自身需求一样来改善同胞的物质供应条件。 自由主义断言，在实行劳动分工的社会里，人们互相合作的唯一可行的制度是生产资料的私有制。完全的公有制是行不通的，这种社会很快就会垮掉；如果是公有制和私有制结合的状态，就会导致生产力的下降，无法创造更多的财富 米瑟斯主张的是权利的平等而非结果的平等，形式的平等而非实质的平等。    米尔顿·弗里德曼：货币主义的倡导者\n 经济自由是政治自由的前提 私有产权和契约自由是整个市场制度的核心 政府职能必须严格限定在较小范围内 政府权力必须有限度和足够分散。 其关于教育问题的一个建议：“教育券”    罗伯特·诺齐克《无政府、国家与乌托邦》\n 主张“最小国家论”：能被证明为正当的就是一种最小国家（minimal state），即仅限于防止暴力、偷窃、欺骗和强制履行契约等有限功能的国家；更多功能的国家（extensive state）都将被证明为是非正当的，因为这样的国家会侵犯到个人不被强迫从事某些特定事情的权利。    什么是保守主义 保守主义亦是一种影响很大的思潮。18世纪晚期至19世纪早期，保守主义的兴起是对当时日益加速的社会变革和政治革命的一种“反动”，也是对启蒙运动和进步主义思潮中激烈变革要求的一种“反动”。\n早期的保守主义有两个版本，一个版本是所谓“十足的保守派”，即反对变化，彻头彻尾地谋求维持现状，不愿意做丝毫的实质性改变。另一个版本的保守主义则比较灵活。这种保守主义是为了保存而变革。这种保守主义主张对现状应该持维护和继承的态度，但同时认为有的方面必须要变革——因为不变革的话，既有的东西都很难保存下来。\n保守主义意识形态的重大变化发生在20世纪70年代以后，它吸收古典自由主义的内核，发展成了新保守主义。\n保守主义的重要原则  捍卫传统的原则。保守主义认为，传统当中包含了很多有益的价值与思想，反对激进变革 经验主义原则。人的理性是有边界的，不能想对社会做什么改造就能做什么改造，在尊重现有惯例、传统与习俗基础上做逐步改进更为合理。 人类的不完善原则。批评“至善论”的危险 社会作为有机体的原则。有机体的观点意味着社会是一个复杂的有机系统，社会内部不同部分之间是互相关联的。所以，不能凭自己的理论、臆想或理性来随意创造一种新社会。 重视等级、秩序和权威的原则。在保守主义者眼中，这个社会存在等级本身是很正常的。所以，对于那种试图彻底打破既有秩序的社会革命思潮，保守主义是强烈反对的。如同尊重既有秩序和社会等级，保守主义也信奉尊重权威的原则。当然，这个原则不能解释过度。尊重权威并不意味着主张国家为所欲为或政府干预；相反，保守主义通常是反对上述做法的。 重视家庭的原则。保守主义认为，家庭是很多重要社会功能的承担者，比如教育；同时，家庭也维系着一个社会的稳定与秩序。从更深层上说，家庭代表的是传统秩序的一部分。 重视和认同宗教的原则 重视道德的原则 尊重财产权的原则。在这一点上，保守主义与古典自由主义的立场别无二致。保守主义不仅反对国家剥夺或征收财产，而且反对国家对私人市场的过度干预、高税收和高福利等做法。  保守主义意识形态内部的一大争论是，保守主义究竟是一整套系统的价值观念和意识形态体系，还是仅仅是一种对于现状的维系与变革之间的思想倾向。这方面并无定论。\n杰里·马勒：“保守主义的内容不仅随着时间和国家语境改变，而且常常在同一时间地点自称保守主义者的人中也内涵不一。”\n撒切尔夫人改革与里根革命 20世纪70年代以后，随着欧美社会经济滞胀和福利病的出现，保守主义开始迎来新的春天。以英国和美国为首，新保守主义运动开始兴起。\n撒切尔夫人改革 切尔夫人的理想国家是资本和市场力量充分发挥作用、政府大幅缩减规模的民主国家。这种理念就更像是向古典自由主义的回归。\n大力推进私有化改革，出售了很多国有企业，同时缩减政府干预的范围。\n还试图消除社会福利，但是整个社会对于这种改革的抵抗非常厉害，现代工业社会的背景加上民主政体与普选制的制度——所有这一切都束缚了撒切尔夫人的手脚，最终使得她这种新保守主义改革无法达到她期待的结果。\n里根革命 里根始终怀疑政府干预和管制的有效性，他的做法是撤回政府干预并降低税率和市场管制，以此让自由市场机制自动修正所面临的问题。\n遗憾的是，里根革命并未达到里根总统的预期效果。他把税率砍了下来，结果短期内政府收入减少了，但是福利没有办法砍下来，这样财政赤字就上去了。所以，新保守主义改革在20世纪80年代给美国留下了一堆沉重的政府公债。尽管里根总统并未达到其改革目标，但有人认为里根的新保守主义改革为20世纪90年代美国新经济和经济增长奠定了基础。\n什么是社会主义 空想社会主义：（欧文、圣西门和傅里叶）强调集体主义和互助，批评资本主义的诸种负面现象\n科学社会主义或共产主义：（马克思和恩格斯的学说）主张通过无产阶级革命来建立公有制，实行计划经济，建设共产主义。\n改良的社会主义或社会民主主义：（爱德华·伯恩斯坦）应该放弃暴力革命，主张通过议会方式进行民主斗争，并进而改变资本主义国家的经济政策，强化再分配，实现社会平等以及建设福利国家。\n社会主义意识形态视为对若干原则的倡导：\n 共同体原则。认为脱离了群体的个人是不存在的，倘若脱离了群体，个体的价值就无从体现，甚至难以成为一个完整意义上的人。 平等主义原则。社会主义的平等观，不只是形式平等和机会平等，同样重要的是实质平等和结果平等。一个符合社会主义理想的社会，其社会成员之间的贫富差距程度应该要远远小于按照其他原则构建的社会。平等的重要性与优先性，是衡量一种观点是否属于社会主义意识形态的关键标准。（自由主义更重视自由） 博爱原则，认为应该以同等的方式去对待社会中的每一份子 阶级原则。社会主义秉承阶级分析方法，把社会分成资产阶级和无产阶级，或上层阶级和下层阶级。主张打破既有的阶级结构，以构建更平等的、甚至无阶级的社会作为理想。 财产的社会控制原则。认为只要财产控制在私人手里，必定会带来前面提到的不平等和阶级压迫。所以，社会主义寻求的是让财产的私人占有过渡到某种形式的财产的社会控制。 满足需求的原则，每个人应该拥有满足这些基本需求的权利。  从社会分层看，下层阶级的苦难往往更多一些。所以，思考如何让下层阶级的生活变得更好时，很多知识分子容易走上信奉社会主义的思想道路。\n从民主社会主义到新工党 从马克思这样一个理论家和革命预言家，到列宁这样一个理论家和革命实践家，不仅是社会主义意识形态从理论到实践的转换，同时包含了理论上的创新。\n但是马克思学说受到了很多挑战，如\n 德国社会民主党的重要领袖爱德华·伯恩斯：走上了改良社会主义的道路，并在德国阐明了民主社会主义或社会民主党的政治纲领。  总体上并不赞成从马克思和恩格斯到后来列宁的无产阶级革命观点。相反，他认为应该在资产阶级宪政民主框架内，通过议会斗争的方式来实现社会主义的基本目标。 认为马克思生活的年代还没有出现普选（除了1848年普鲁士短暂的民主实验以外），所以，马克思本人并没有看到通过选举改革让普通民众获得选举权的可能性。 对马克思和恩格斯在《共产党宣言》中的政治纲领与社会设计充满了担忧。  他认为完全的公有制将会造成劳工阶层的积极性不足。后来很多关于计划经济的研究已经为这种观点提供了理论和经验支持。 这种模式会导致生产过程的官僚主义化。行政官僚本身缺少市场激励，整个生产过程极易变成一种官僚化运作。 无产阶级一党专政有可能会成为新的专制统治——伯恩斯坦认为至少有这种可能性。 伯恩斯坦认为马克思的工人阶级中心论有可能是反人道主义的。如果说工人阶级需要特殊优待，那么其他阶级呢？ 实际上，伯恩斯坦的部分担忧已经为苏联斯大林统治时期的某些实践所证实   主张的一个主要政策是通过税收和再分配使不同社会阶层的收入更加平等化。 社会福利政策也是一个重要方面，社会民主主义的早期理想是建设从摇篮到坟墓的、无所不包的福利国家 社会民主主义通常还会促成充分就业以及支持与强大的工会力量合作    社会民主主义的早期政治纲领在如今的很多欧洲国家已成为现实。今天，很多西方国家的制度与政策都是借鉴了这些原则。\n20世纪80年代以来，社会民主主义阵营内部出现了分化，其主流开始与新自由主义的部分主张合流，兴起了“新的社会民主主义”“第三条道路”“中间道路”“新社会民主党”和“新工党”等概念。总的趋势是，他们部分地接受新自由主义的经济理论，承认市场经济的作用，强调企业家精神和激励因素的重要性，不赞同建设无所不包的福利国家。英国工党在向新自由主义的政策靠近。\n意识形态论战的场域 个人优先还是集体优先 支持个人优先的观点有几个基本倾向。首先，社会或群体是由个体构成的，所以个人应该有优先性。其次，整个社会的基础与动力都在于个人，所以相应的制度与政策都需要落实到个人激励上。当然，个人优先的结果一定是不同个体之间会有差距。所以，主张个人优先的观点必须接受贫富差距的事实。\n支持集体优先的观点有几个基本倾向。首先，有人强调共同体生存是第一位的。这种意识可能会导致比较强烈的民族主义立场。其次，这种观点强调个人的最优选择未必会导致集体的最优选择，个人利益的最大化或可跟集体利益的最大化相冲突（如囚徒困境）。\n但是，凡是倡导集体优先的社会，必然都会强调一种更强组织化的手段和更强的集体控制。由此带来了两个问题：一是个人可能会被压制，个性受到压抑；二是那掌握集体控制手段的个人或集团，往往会拥有更大的权力，甚至可能侵犯其他普通个人的自由与权利。\n国家的角色与作用 美国整个政治文化中对国家、政府和权力抱有一种高度警惕的态度。\n从更中立的视角看，国家的好处与坏处都是明显的。没有国家，就没有公共秩序，就没有基本安全，就没有国防力量，就没有最基本的公共基础设施。另一方面，国家的坏处也是明显的。国家天然地倾向于扩展其职能范围，想接管个人权利，想干预社会生活。国家或政府权力还经常容易被滥用，统治者和官员会因为拥有政治权力而变得腐败。这些都是可能的弊端。\n自由及其限度 这里的自由是指政治自由，政治自由的谱系上存在两极：一极是自由至上主义（libertarianism），一极是极权主义（totali-tarianism）。\n自由至上主义不是无政府主义，而是把国家限制在极小范围内。他们认为，凡超过这个必要的极小范围，都不是国家应该介入的领域。极权主义意味着国家试图利用政治权力控制一切，政治权力渗透到经济、社会乃至家庭等各个领域。\n在自由问题上，多数人的意识形态处在这一政治谱系两极中间的某个位置。\n 在所有政府内部始终存在权威与自由之间的斗争，有时候是公开的，有时是隐蔽的，两者之中从无一方在争斗中占据绝对上风。在每一个政府中自由都必须做出重大牺牲，而限制自由的权威，绝不能而且也不应该在任何的政治中，成为全面专制，不受控制。必须承认自由乃文明社会的尽善化，但仍然必须承认权威乃其生存之必需。——大卫·休谟\n 平等 保守主义强调的是既有秩序和社会等级，所以保守主义并不热爱平等。自由主义强调的是自由优先，在自由主义框架中平等的价值显然要低于自由的价值。但与此同时，自由主义主张机会的平等和形式的平等，或者说是法律面前人人平等。当然，社会主义更多地主张结果的平等和实质的平等\n政府与市场的关系 更支持自由市场，还是更支持政府干预，代表了意识形态维度上的很大分歧。\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap3/","tags":null,"title":"意识形态大论战"},{"categories":null,"contents":"数据质量   不完整性：\n  数据噪声：\n 仪器本身的误差 使用了不恰当的仪器 数据传输或存储过程中的差错    不一致性：\n 来源于不同数据源头 采用不同的度量衡    No data quality, no mining results quality\n数据预处理的主要任务 数据清洗（data cleaning） 通过填写缺失的值，光滑噪声数据，纠正不一致实现\n填补缺失值  忽略元组 人工填写 使用一个全局变量填充缺失值（如“Unknown”） 使用属性的中心度量(如均值或中位数)来填充 使用给定元组属同一类所有样本的属性均值或者中位数 使用最可能的值填补缺失值  噪声数据处理  噪声是测量的变量的随机误差或者方差  噪声数据远少于正常数据 噪声数据和正常数据有明显的不同   分箱（binning）: 考察数据的近邻来光滑有序数据值  如何划分  等深的划分：每个箱的大小相同 等宽的划分：每个箱值的区间范围是常量   如何光滑  用箱均值光滑 用箱中位数光滑 用箱边界光滑     Cluster： 落在簇之外的就是离群点 回归(regression): 线性回归、多元线性回归 数据审计(Data editing):  纠正不连续数据  人工纠正 Knowledge engineering tools：如关联分析等  数据约简(data reduction) 合理约简数据，既要约的够小，又要不能损失太多信息\n数据集成（Data integration） 把多个数据库、数据立方体或者文件合并\n数据转换（Data transformation） Normalization（数据规范化）   最小-最大规范化：把$[min_A,max_A]$ 规范到$[newmin_A,newmax_A]$\n$$v' = \\frac{v-min_A}{max_A-min_A}(newmax_A-newmin_A)+newmin_A$$\n  z-score(z-分数)规范化： 基于均值和标准差来规范化\n   小数定标规范化：  smoothing aggregation Generalization 数据归约(Data reduction) histograms 直方图 等深(equi-depth) 每个桶的宽度区间是一致的\n等宽 （equi-width） 每个桶的频率粗略的为常数\nv-optimal 进行加权的求和，weighted variance\n$$variance = \\frac{1}{n-1}\\sum_i(x_i-\\hat{x})^2$$\nmaxdiff 一般而言，v-optimal和maxdiff的效果更加准确\nmaxdiff考虑的是端点之间的距离，而v-optimal考虑的是划开后类之间的聚类情况如何。v-optimal需要穷尽各种可能的划分方式，所以他的计算开销大很多。\nClustering 聚类 对于多维的数据。\n如何衡量一个cluster的好坏：\n diameter：类之间两个物体的距离，尽可能小 centroid distance：簇中各个对象到簇中心距离的平均值  Sampling 抽样 允许使用数据小的多的随机样本来表示大型数据集\n  无放回的简单随机抽样（SRSWOR）\n  有放回简单随机抽样（SRSWR，bootstrap sampling）\n  簇抽样：适用于数据样本非常大的情况下，选择部分的cluster内的所有数据，不破坏数据间的性质，如在大型数据库中，可能一页被看作一簇\n  分层采样（stratified sampling）\n  数据离散化 ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/3dataprocessing/","tags":null,"title":"Data Processing"},{"categories":null,"contents":" 三极管的结构，工作原理，三种组态起码要认识（如何工作与分析不做太高要求），放大作用如何实现，伏安特性曲线（尤其输出，各种区与每种线的含义），各种基本参数\n 半导体三极管 三极管：双极结型三极管(BJT，又叫双极晶体管)\n发射结上的箭头的方向指向发射结导通的方向(P指向N)，由此可以区分NPN型和PNP型\n发射区：发射载流子，既然要发射，那载流子浓度必然很高 集电区：收集载流子，面积大但是载流子浓度不高 基区：控制区域\n结构特点：\n 发射区的掺杂浓度最高 集电区的掺杂浓度低于发射区，且面积大 基区很薄，一般在几个微米，且掺杂浓度最低  电流放大 放大实际上是通过核心元件三极管控制能量的新的变化来实现放大\n实现放大的外部条件：发射结正偏，集电结反偏\n载流子内部传播过程-以NPN型为例  发射结正偏，发射区的自由电子扩散到基区  $I_{EN}$：自由电子的扩散 $I_{EP}$:空穴的扩散,由于浓度原因，显然远不如$I_{EN}$ $I_{E} = I_{EP}+I_{EN} \\approx I_{EN}$   基区：自由电子此时进入基区后，基区中现在扩散过来的非平衡少子比他的多子还多，所以会继续往前扩散，所以自由电子会经过基区继续向集电极扩散，在扩散过程中，必然会发生复合。（如果基区足够宽，就可以让绝大多数电子在基区中复合，这也就是为什么基区要做的足够薄）。但是复合之后，又可以在基极$I_B$的影响下重新产生。所以可以认为其中的浓度不变。扩散速度和浓度梯度有关，所以必须让集电结这里的电子必须被快速抽走保证扩散速度基本不变（刚好此处就集电结反偏了）  在$I_B$做一个KCL，可以看到$I_B=I_{EP}+I_{BN}-I_{CBO}=I_E-I_C$   集电区收集自由电子，反偏会加速漂移运动，产生了$I_{CBO}$  $I_C=I_{CN}+I_{CBO}$    BJT电流分配关系 共基极直流放大系数 $\\hat{\\alpha}$ $$\\hat{\\alpha}=\\frac{传输到集电极电流}{发射极注入电流}=\\frac{I_C-I_{CBO}}{I_E}\\approx \\frac{I_C}{I_E}$$\n他通常只与管子的结构尺寸和掺杂浓度有关，与外加电压无关，一般为0.9-0.99\n共射极直流放大系数 $\\hat{\\beta}$ $$\\hat{\\beta} = \\frac{I_{CN}}{I_{BN}} = \\frac{I_C-I_{CBO}}{I_B+I_{CBO}}\\approx \\frac{I_C}{I_B}$$\n反向饱和电流（穿透电流）：当$I_B$为0时，仍然有一个从C到E的电流,$I_{CEO}=(1+\\hat{\\beta})I_{CBO}$\n三极管的放大作用主要是依靠它的发射极电流能够通过基区传输，然后到达集电极而实现的。\n 内部条件：发射区杂质浓度远大于基区浓度，并且基区很薄 外部条件：发射结正向偏置，集电结反向偏置  三种组态 看除去用于输入和输出之外共用的是哪个极\n可以发现输入要么在基极就是在发射极\nBJT的I-V特性曲线 现在考虑共射极连接的BJT曲线\n输入特性 $$i_B=f(v_{BE})|_{V_{CE}=const}$$\n当$V_{CE}=0$时，就相当于发射结的正向伏安特性曲线，当其大于1V时，$V_{CB}=V_{CE}-V_{BE}\u0026gt;0$,集电结反偏，收集载流子能力增强，基区复合减少，这使得同样的$V_{BE}$下的$I_B$减少，也就是曲线右移\n有三个区：\n 死区 非线性区 近似线性区  非线性区和近似线性区的分界：（工作压降）  硅：0.6-0.7V 锗：0.2-0.3V      输出特性 $$i_c=f(V_{CE})|_{i_B=const}$$\n 放大区  放大区域内输出曲线基本与横坐标平行，随着$v_{CE}$的增加略微向上倾斜(受基带宽度调制效应产生)。但是主要受到$i_B$的影响，此时发射结正偏，集电结反偏 基带宽度调制效应：在$V_{BE}$不变的情况下，$V_{CE}$的上升会导致$V_{CB}$反压上升，导致集电结内的空间电荷区的宽度上升，从而使得基带区的有效宽度下降，基区内的载流子复合机会下降，从而使得 $\\beta$ 增大   饱和区  发射结和集电结均处于正偏。此时$V_{CE}\u0026lt;V_{BE}$,集电结内电场被削弱，收集载流子能力下降，此时$i_c$不再服从$\\hat{\\beta}i_{B}$的关系，而是随着$V_{CE}$的增长而增长。虚线可以认为是饱和区和放大区的分界线。对于小功率管，可以认为$V_{CE}=V_{BE}$时处于临界饱和状态   截止区  发射结和集电结全部反向偏置，此时$i_B=-I_{CBO}$,$i_C=I_{CEO}$(但是对于小功率管很小，可以忽略)    BJT的主要参数 基本参数  电流放大系数  共发射极直流放大系数 $\\hat{\\beta}\\approx \\frac{I_C}{I_B}$（$V_{CE}$为常数） 共发射极交流电流放大系数 $\\beta = \\frac{\\Delta I_C}{\\Delta I_B}$ 共基极直流电流放大系数 $\\hat{\\alpha} = \\frac{I_C-I_{CBO}}{I_E} \\approx \\frac{I_C}{I_E}$ 共基极交流放大系数 $\\alpha = \\frac{I_C}{I_E}$   极间反向电流  集电极基极反向饱和电流$I_{CBO}$：即发射极开路时，集电极的反向饱和电流 集电极发射极间的反向饱和电流$I_{CEO} = (1+\\hat{\\beta})I_{CBO}$,即输出特性曲线$I_B=0$ 那里对应的Y坐标的值，也称作集电极发射极间穿透电流   极限参数  集电极允许最大电流$I_{CM}$ 集电极允许最大功率损耗$P_{CM}=I_CV_{CE}$ 反向击穿电压  $V_{(BR)CBO}$——发射极开路时的集电结反向击穿电压。 $V_{(BR)EBO}$——集电极开路时发射结的反向击穿电压。 $V_{(BR)CEO}$——基极开路时集电极和发射极间的击穿电压。      温度对BJT参数及其特性的影响 温度每升高10度，$I_{CBO}$约增加一倍\n温度每升高1度，$\\beta$值增大$0.5%-1%$\n温度对反向击穿电压中的$V_{(BR)CBO}$和$V_{(BR)CEO}$都有影响，温度升高，两者增大\n故而：\n 温度升高，输入特性曲线左移 温度升高，输出特性曲线上移，曲线族间距增大  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%B8%89%E6%9E%81%E7%AE%A1/","tags":null,"title":"半导体三极管"},{"categories":null,"contents":"Sieve methods Principle of Inclusion-Exclusion PIE用于计算n个有限集合的并的大小 : $$ {\\begin{aligned}\\left|\\bigcup {i=1}^{n}A{i}\\right|\u0026amp;=\\sum _{I\\subseteq {1,\\ldots ,n}}(-1)^{|I|-1}\\left|\\bigcap {i\\in I}A{i}\\right|.\\end{aligned}}$$\n我们在组合中，通常将我们不希望看到的坏事件定义为$A_i$,这样的话我们所希望得到的就是$$ {\\begin{aligned}\\left|{\\bar {A_{1}}}\\cap {\\bar {A_{2}}}\\cap \\cdots \\cap {\\bar {A_{n}}}\\right|=\\left|U-\\bigcup _{i=1}^{n}A_{i}\\right|\u0026amp;=|U|+\\sum _{I\\subseteq {1,\\ldots ,n}}(-1)^{|I|}\\left|\\bigcap _{i\\in I}A_{i}\\right|.\\end{aligned}}$$\n同时，我们可以用一个$ A_{I}=\\bigcap _{i\\in I}A_{i}$来表示，这样的话我们可以令 $ S_{k}=\\sum _{|I|=k}|A_{I}|,$. Conventionally, $ S_{0}=|A_{\\emptyset }|=|U|$,那么 $$\\left|{\\bar {A_{1}}}\\cap {\\bar {A_{2}}}\\cap \\cdots \\cap {\\bar {A_{n}}}\\right|=S_{0}-S_{1}+S_{2}+\\cdots +(-1)^{n}S_{n}.$$\nsurjections 考虑求解$[n]\\rightarrow [m]$ 的满射的数量。\n那么我们可以定义坏事件为$A[i]=[n]\\overset{on-to}{\\to}([m]-{i})$\n则$A_I$可以看成是$[n]$到$([m]/I)$的一个映射，这种映射有$(m-|I|)^n$种方式\n故而结果为 $$\\sum {I\\subseteq [m]}(-1)^{|I|}\\left|A{I}\\right|=\\sum _{I\\subseteq [m]}(-1)^{|I|}(m-|I|)^{n}=\\sum _{j=0}^{m}(-1)^{j}{m \\choose j}(m-j)^{n}$$\nderangements 错排：任意的一个$i\\in [n]$,有 $\\pi(i)\\neq i$\n那我们就定义坏事件就是$A_i={\\pi|\\pi(i)=i}$\n那么就有$|A_I|=(n-|I|)!$\ntips: 最后的求解过程中还应用了泰勒公式$e^x=1+\\frac{1}{1!}x+\\frac{1}{2!}x^2+\\frac{1}{3}x^3+\\cdots$\npermutations with restricted positions 在一个$n\\times n$ 的棋盘中，保证选择的n点中的每两个点不会再同一行或者同一列。\n即$G_\\pi = {(i,\\pi(i))|i\\in{1,2,..n}}$\n将排列转换为一组二维坐标,假设B是一个不符合条件的位置的集合, $r_k$ 表示在B中选k个不同的位置的方法. 则满足条件的n排列的个数为$N_0 = \\sum\\limits_{k=0}^n (-1)^k r_k (n-k)!$\nInversion posets the mobius function computing mobius functions principle of mobius inversion sieve method in Number theory ","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/sieve-methods/","tags":null,"title":"Sieve Methods"},{"categories":null,"contents":"运输层 该层位运行在不同主机上的应用经称提供直接的通信服务\n3.1 概述与运输层服务 运输层协议位不同主机上的应用进程提供了逻辑通信的功能\n网络路由器不实现运输层协议，网络路由器只检查网络层字段，不检查运输层报文段的字段，在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。\n3.1.1 运输层和网络层的关系  运输层：提供运行在不同主机上的进程之间的逻辑通信 网络层：提供主机之间的逻辑通信  运输层协议只运行在端系统中\n运输协议能够提供的服务常常会受制于底层网络层协议的服务模型\n3.1.2 因特网运输层概述 UDP(用户数据报协议)：为调用它的应用程序提供一种不可靠(不能保证一个进程发送的数据能完整到达)、无连接(无握手)的服务。提供数据交付与差错检测\nTCP(传输控制协议)：提供一种可靠的、面向连接的服务，通过流量控制、序号、确认和定时器确保按序交付\n虽然RFC中将UDP分组称为datagram数据报，但是本书中运输层分组统称报文段\nTCP有拥塞控制，防止一条TCP连接用过多的流量淹没通信主机之间的链路和交换设备，但是UDP传输的应用程序可以按照其需要以任意的速率发送数据\n3.2 多路复用与多路分解 多路复用与多路分解：将由网络层提供的主机到主机交付服务延申到为运行在主机上的应用程序提供进程到进程的交付服务。\n 多路分解：将运输层报文段的数据交付正确的套接字 多路复用：从源主机的不同套接字收集数据块，并为每个数据块封装上首部信息生成报文段，并将报文段传送给网络层  一个进程由一个或者多个套接字，运输层不是直接将数据交付给进程而是交给了一个中间的套接字。每个套接字都有一个唯一的标识符。\n每个报文段的首部信息的前32个比特都是源端口号字段和目的端口号字段，每个字段16比特，端口号从1-65535之间，其中0-1023范围内的端口号是周知端口号，是受限制保留给一些周知应用层协议来使用的\n 一个UDP套接字由一个二元组(目的IP地址,目的端口号)定义 TCP套接字由一个四元组(源IP地址,源端口号,目的IP地址,目的端口号)标识。 所以不同主机发送相同目的IP地址和目的端口号的报文，在UDP中会给同一个套接字，而TCP中不会  如果使用非持续HTTP服务，那么每一对请求/响应都创建一个新的TCP连接并关闭\n3.3 无连接运输：UDP UDP：做运输协议能做的最少的工作，只在IP上增加了复用/分解功能和差错检测功能\n使用UDP时，发送报文段之前，发送方和接收方的运输层没有握手，故而被称为是无连接的\nDNS是一个使用UDP的典型例子\n部分应用更适合使用UDP的原因：\n 关于发送什么数据以及何时发送的应用层控制更加精细：因为TCP有拥塞控制并且需要可靠有序交付，而一些实时应用通常要求最小发送速率且不希望过分延迟报文段的发送，并且能够容忍一些数据丢失 无需建立连接：UDP没有建立连接的时延(这是DNS采用UDP的主要原因) 无连接状态：TCP需要在端系统中维护连接状态(接收和发送缓存，拥塞控制参数及序号和确认好的参数)，采用UDP可以支持更多的活跃用户 分组首部开销小。TCP报文首部20字节，UDP8字节  还有一些如网络管理数据的(SNMP)这些在网络重压状态下运行，这时候可靠的拥塞受控的数据传输难以实现\n多媒体开发人员通常将应用运行在UDP上而不是TCP上\n3.3.1 UDP报文结构 首部只有四个字段(8字节)，每个字段16比特(2字节)。\n 源端口号 目的端口号 长度：UDP报文段的字节数(首部+数据) 检验和  3.3.2 UDP校验和 对报文段中所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷(最高位进位的数加到最低位去)。接收方收到后，把所有比特字和校验和相加，将会得到全1.\n提供差错检测的原因在于无法保证所有的链路都提供差错检测，同时存储在某台路由器的内存中的时候也可能引入比特差错，故而要在端到端基础上在运输层提供差错检测\n但是，UDP的差错检测没有恢复能力，只能对报文段进行丢弃或者交给应用程序并给出警告\n3.4 可靠数据传输原理 3.5 面向连接的传输：TCP 3.5.1 TCP连接 TCP是面向连接的，因为在一个应用进程可以开始向另一个应用进程发送数据前，两个进程必须先握手，即呼想发送某些预备报文段，以建立确保数据传输的参数。\n连接状态只在两个通信端系统的TCP程序中保留\nTCP连接提供全双工服务：应用数据可以从B流向A，也可以从A流向B\nTCP连接是点对点的，即多播是不可能的\n客户进程通过套接字传输数据流，数据通过套接字后，被TCP导入发送缓存中，发送缓存时发起三次握手期间设置的缓存之一。接下来TCP不时的从发送缓存中取出一块数据并将数据传入网络层。\n取出数据的长度受限于最大报文段长度(MSS),而MSS根据本地发送主机的最大链路层帧长度(即最大传输单元MTU)来设置。MSS要保证一个TCP报文段加上TCP/IP首部长度(通常40字节)适合单个链路层帧。注意MSS指的是报文段中应用层数据的长度\nTCP接收端收到报文段后放入接收缓存中，应用程序从缓存中读取数据流。\n3.5.2 TCP报文段结构 | 源端口号 | 目的端口号 | | 序号 | | 确认号 | |首部长度|保留未用|SWR|ECE|URG|ACK|PSH|RST|SYN|FIN| 接收窗口 | | 因特网校验和 | 紧急数据指针 | | 选项 | | 数据 |  序号(seq):32 bits 确认号(ACK)：32 bits 接收窗口字段：16 bits，用于流量控制 首部长度字段: 4 bits 选项字段：可选、变长 标志字段：6 bits  ACK：指示确认字段的值有效 RST,SYN,FIN: 连接建立与拆除 SWR,ECE: 明确拥塞通告 PSH：置位时标识接收方应当立即将数据交给上层 URG：指示报文段里存在着发送端上层实体置为紧急的数据，紧急数据的最后一个字节由紧急数据指针字段指出    序号与确认号 TCP把数据看成一个无结构、有序的字节流，序号是建立在传送的字节流之上，而不是报文段序列上，主机A填充到报文段的确认号是希望从主机B收到的下一字节的序号\nTCP：累计确认\n收到失序的报文段的处理方式取决于编程人员：\n 立刻丢弃失序报文段 保留失序字节，并等待确少的字节以填补间隔  一条TCP连接的双方均可随机的选择初始序号\n3.5.3 往返事件的估计与超时 采用超时/重传机制来处理报文段的丢失问题\nRTT：往返时间\n报文段的样本RTT就是从某报文段被发出到对该报文段的确认被收到之间的时间量。大多数的实现是某个时刻做一次测量而不是每个发送的报文段测量一个。TCP绝不为已经重传的报文段计算SampleRTT。\nSampleRTT的平均值(加权移动平均)EstimatedRTT：$$EstimatedRTT=(1-\\alpha)EstimatedRTT + \\alpha SampleRTT$$\n在RFC6298中给出的推荐值是$\\alpha = 0.125$\nRTT偏差：$$DevRTT=(1-\\beta)DevRTT+\\beta |SampleRTT-EstimateRTT|$$$\\beta$的推荐值是0.25\n设置重传时间间隔不能太小，否则会造成不必要重传，也不能太大，否则不能很快的重传报文段造成数据传输时延较大。一般设置为$$TimeoutInterval = EstimatedRTT+4*DevRTT$$只要超时了就将其加倍，但是再次收到报文段后就仍然按照上面的公式对其进行更新\n3.5.4 可靠数据传输 可靠数据传输保证一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。\n推荐的定时器管理过程是使用单一的重传定时器，即使有多个已发送但是仍未被确认的报文。\n/*假设发送方不受TCP流量控制和拥塞控制，每一个数据小于MSS.*/ NextSeqNum = InitialSeqNum SendBase = InitialSeqNum loop(永远){ switch(event): case 从上层应用接收数据： 生成序号为NextSeqNum的报文; if(定时器没有启动){ 启动定时器; } 向IP传递报文; NextSeqNum += 数据字节数; break; case 超时： 重传SendBase对应的TCP报文; /*和GBN不同之处*/ TimeoutInterval *= 2; 重启定时器; /*每次重传一个报文后都会重新启动定时器*/ break; case 接收ACK, AN = y: if(y \u0026gt; SendBase){ SendBase = y; /*采取累计确认*/ 重新计算TimeoutInterval; if(仍有发送且未确认报文){ 重启定时器; } } else{/*实际上此时y == SendBase*/ y的冗余数量 += 1; if(y的冗余数量 == 3){ /*快速重传*/ 立即重传序号为y对应的报文; } } break; } 对于接收端而言：\n   事件 动作     具有所期望序号的按序报文段到达且在此之前的报文段都已经被确认，即本报文段是当前状态下第一个接收但未被确认的报文 Delayed ACK，延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK。   具有所期望序号的按需报文段到达且当前有一个报文段等待ACK传输，即此时处于事件一的状态 立马发送单个累计ACK，确认这两个报文   比所期望序号大的失序报文段到达，即接收产生了间隔 立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号）   能部分或完全填充接收数据间隔的报文段到达 如果该报文段序号起始于间隔的低端，则立即发送ACK    一些有趣的情况   主机A发送的报文在主机B上收到，但从主机B发往主机A的确认报文丢失了。超时事件发生，主机A会重传相\n同的报文段。\n  主机A发送了两个报文段，都被主机B接收，但是在超时之前B发送的两个确认报文没有一个到达A。A重传第\n一个报文，在超时间隔内B发送的第二个确认到达了A。第二个报文段不会被重传。\n  同2，但是在超时之前，A收到了第二个确认报文，第一个确认报文丢失，A不会重传任何报文。\n  超时间隔加倍 每次重传将下一次的超时间隔设为之前的两倍(指数级增长)，收到后再恢复公式计算\n快速重传 为了避免一个超时周期过长，当一个报文段丢失的时候，长超时周期使得发送方延迟重传丢失的分组增加了端到端时延。\n认为如果收到了三个冗余的ACK，那么就执行快速重传，即在该报文段的定时器过期前重传丢失的报文段\n一个修改建议是选择重传：即允许TCP接收方有选择的确认而不是累计确认\n3.5.5 流量控制 流量控制是一个速度匹配服务，使发送方的发送速率和接收方的应用程序读取速率匹配，消除接收方缓存溢出的可能性\nTCP让发送方维护一个**接收窗口(rwnd)**的变量来提供流量控制，接收方给发送方一个指示：接收方还有多少可用的缓存空间\n RcvBuffer: 接收缓存大小 LastByteRead：主机B上的应用进程从缓存中读出的数据流的最后一个字节的编号。 LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。 由于TCP不允许已分配的缓存溢出，下式必须成立：LastByteRcvd-LastByteRead\u0026lt;= RcvBuffer  设置$rwnd=RcvBuffer-(LastByteRcvd-LastByteRead)$\n 以下假设A向B发送报文段 初始时B将rwnd设置为RcvBuffer大小 主机B会见rwnd的大小放在报文段首部中的接收窗口字段中 如果通报了rwnd为0之后B不向A发送报文(不发送确认报文且无向A传输的数据)，可能导致后续B缓存清空后A仍然无法发送报文，故而规定B的接收窗口为0后，A将向B发送只有一个字节数据的报文段。但缓存开始清空后，确认报文中将含有一个非0的rwnd值  3.5.6 TCP连接管理 三次握手：\n 第一步：(SYN报文段)客户端发送报文段,报文段中应用数据为空，报文段首部的标志位SYN置为1,客户随机生成序号，并将其放在序号字段中。 第二步:（SYNACK报文段）服务器为TCP连接分配TCP缓存与变量，并向客户发送允许连接报文段，此报文段应用数据为空，SYN位置1，确认号为客户随机生成的序号+1，并随机选择自己的序号 第三步：收到SYNACK报文段后，客户给连接分配TCP缓存与变量，这个报文段SYN置0.且可以含有应用数据  客户关闭连接：\n 向服务器发送特殊报文段，FIN置1 服务器收到后发送一个确认报文段 服务器在发送一个FIN置1的他的终止报文段 客户进行确认，连接资源释放(客户发送ACK后定时等待后关闭)  3.6 拥塞控制原理 分组重传可以作为网络拥塞的征兆，我们需要一定的机制在网络拥塞时抑制发送方\n3.6.1 拥塞原因与代价 分组的到达速率接近链路容量时，分组经历巨大的排队时延\n发送方必须执行重传以补偿因为缓存溢出而丢弃的分组\n发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本\n当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输流量最终被浪费了\n3.6.2 拥塞控制办法  端到端拥塞控制：网络层没有对运输层控制提供显式支持，即使网络中存在拥塞端系统也必须通过对网络行为的观察来推断。TCP报文段的丢失被认为是网络拥塞的一个征兆 网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显式反馈信息。例如在ATM可用比特率拥塞控制中，路由器显式的通知发送方路由器能够在输出链路上支持的最大主机发送速率  一种是采用阻塞分组(choke packet)的形式 \\ 一种是路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生    3.7 TCP拥塞控制 TCP：让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率\n运行在发送方的TCP用户拥塞控制机制额外跟踪一个变量，也就是拥塞窗口(cwnd).在一个发送方中未确定的数据量不能够超过cwnd和rwnd的最小值\n如何控制速率：每个RTT的起始点，允许发送cwnd个字节的数据，该RTT结束的时候收到确认报文，因此该发送方的发送速率是cwnd/RTT字节/秒\n将丢包事件定义为：要么出现超时，要么收到了来自接收方的三个冗余ACK\n因为TCP使用确认来出发增大他的拥塞窗口长度，故而可以说TCP是自计时的\nTCP的指导性原则：\n 一个丢失的报文段意味着拥塞，因此丢失报文段时应当降低TCP发送方的速率 一个确认报文段表示该网络正在向接收方交付发送方的报文段，因此对向前未确认报文段的确认到达时，能够增加发送方的速率 带宽探测，增加速率以响应到达的ACK，除非出现丢包事件才减小速率  TCP拥塞控制算法：慢启动，拥塞避免，快速恢复\n慢启动 cwnd的初始值通常设置一个MSS的比较小的值，使得初始速率大概只有MSS/RTT，在慢启动状态，cwnd以一个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。之后每过一个RTT，发送速率就翻番。\n如果存在一个丢包事件就把cwnd设置为1并重新启动慢启动过程，并且把慢启动阈值ssthresh置为拥塞窗口值的一半·\n当cwnd上升到ssthresh时，将结束慢启动并且将TCP转移到拥塞避免模式。另一种结束方式是如果是三个冗余ACK，TCP将执行一种快速重传并进入快速恢复状态\n拥塞避免 cwnd在每个RTT线性增加\n超时后，cwnd设置为一个MSS，丢包后ssthresh被设置为原来cwnd的一半。\n如果是三个冗余ACK导致的超时，则将cwnd减半后加三，并且当收到三个冗余ACK，将ssthresh设置为cwnd的一半，然后进入快速恢复状态\n快速恢复 对每个冗余的ACK增加一个MSS，当对丢失报文段的一个ACK到达后，TCP降低cwnd后进入拥塞避免状态。如果在快速恢复种遇到了超时事件，将迁移到慢启动状态并将cwnd设置为1，ssthresh设置为一半\n早期的TCP Tahoe版本是没有快速恢复的，3个冗余ACK也进入慢启动，TCP Reno版本有\n回顾 加性增，乘性减\nTCP Vegas算法：\n 分组丢失之前在源和目的地之间检测路由器种的拥塞 检测出快要发生的分组丢失时，线性的降低发送速率，快要发生的分组丢失通过观察RTT来预测  吞吐量的宏观描述 TCP的传输速率在$W/(2*RTT)$和$W/RTT$之间变化（W：当前窗口长度）\n平均吞吐量：$$\\frac{0.75*W}{RTT}$$\n经高带宽路径的TCP $$平均吞吐量 = \\frac{1.22MSS}{RTT\\sqrt{L}}$$ 其中，L为丢包率，MSS为最大报文段长度\n3.7.1 公平性 如果K条连接都经过一个传输速率为R bps的瓶颈链路，如果每个传输的平均传输速率都接近R/K，那么认为这个拥塞机制是公平的\n实际上那些具有更小的RTT的传输能够更快的抢到可用带宽，因而比那些具有较大RTT的连接先用更高的吞吐量\n由于UDP没有拥塞控制，将挤压TCP资源\n如今许多Web应用使用多个并行TCP连接来抢占链路传输中的带宽\n3.7.2 明确拥塞警告:网络辅助拥塞控制 允许网络明确向TCP发送方和接收方发出拥塞信号，这种形式的网络辅助拥塞控制称为明确拥塞通告(ECN)\n在IP数据报的首部服务类型字段中2个比特用于ECN(4种状态)\n路由器判断拥塞后使用ECN比特设置指示该路由器正在历经拥塞，接受主机收到报文后在TCP ACK中设置ECE发送到主机，通知发送方TCP收到拥塞指示，接下来TCPP发送方通过减半cwnd来对一个具有ECE拥塞指示的ACK作出反应。并在下一个发送给接收方的报文首部中设置CWR比特\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/yun-shu-ceng/","tags":null,"title":"运输层"},{"categories":null,"contents":"关系数据库系统  关系数据库系统\n3.1 关系数据库系统概述\n3.2 关系数据库系统的衡量准则\n 完全关系型的十二条衡量准则 空值（NULL）的定义  3.3 关系模型数学理论—关系代数\n3.3.0 关系模型（概念）\n 关系数据结构 表结构（表头）：表框架，表的元数与基数 关系：关系的性质 关键字：候选关键字，主关键字，外关键字 关系数据库：关系子模式-视图（view） 关系操纵 数据查询：两个关系的合并，单个关系内的元组选择，单个关系内的属性指定 元组的删除、插入、修改 空值的处理 关系中的数据约束 实体完整性约束，参照完整性约束，用户定义的完整性  3.3.1 关系的表示\n 关系的表示，迪卡尔乘积  3.3.2 关系操纵的表示\n 关系代数中的五种基本运算：选择，投影，笛卡儿积，并，差（请注意每个运算符的执行条件和结果关系的关系模式） 基本运算的应用  3.3.3 关系模型与关系代数\n3.3.4 关系代数中的扩充运算\n 交，除法，联接与自然联接，θ-联接 扩充运算与基本运算之间的关系 扩充运算的应用实例  3.3.5 关系代数的应用\n 综合的关系代数应用表示，复杂查询的关系代数表达式 关系代数的应用 单个关系上的选择与投影 两个关系的并、交、差 两个关系的迪卡尔乘积、自然联接、θ-联接 两个关系的除法  难点\n 查询条件带有‘否定’语义：‘不等’比较 \u0026amp; 减法运算 使用表联接查询，还是使用除法? 正确使用自然连接运算 和 除法运算 表的自联接  3.3.6 关系演算\n 原子公式，公式的定义 基于关系演算的数据查询表示：单表查询，多表连接查询，复杂查询的表示（逻辑非、蕴涵操作符）   关系数据库系统衡量准则 十二条标准：\n 信息准则（关系数据库中的所有信息都能在逻辑一级唯一的用表中的值显示表示，结构描述信息在逻辑上组织成关系形式） 确保访问准则（能够用逻辑方式依靠表名、关键字值与列名的组合来访问数据库中每一个原子数据） 空值的关系处理准则（系统应当具有处理空值的能力，空值：无意义或当前未知的值） 基于资源管理的动态联机目录（数据库的描述信息数据字典与用户数据有着相应的形式与操作方式） 统一易用的数据子语言（数据定义、视图定义、数据操纵、完整性约束能力、授权机制、事务处理能力） 视图更新准则 高级的插入、删除及修改操作 物理数据独立性 逻辑数据独立性 数据完整性准则 分布独立性 无损害准则  关系代数 关系模型 二维表的组成：\n 表框架（n个命名的属性，n被称为表的元数） 元组(一个表框架存放了m个元组，m称为表的基数)  满足以下7个性质的二维表称为关系：\n 元组个数有限 元组唯一 元组次序无关 元组分量的原子性 属性名唯一性 属性名次序无关性 分量值域同一性  Relational Rules：\n Rule 1. First Normal Form Rule：Can't have multi-valued fields. Rule 2. Access Rows by Content Only Rule  No order to the rows No order to the columns   Rule 3. The Unique Row Rule  Two rows can't be same in all attributes at once. So that a relation is an unordered SET of tuples. But many products allow this for efficiency of load.    每个关系都有一个名称关系名，关系中的每一个属性有一个名称属性名，关系名和所有的属性名构成了关系框架\n超键：set of colunms that has the uniqueness property\n键：minimal superkey\n候选关键字，主关键字，外关键字\n待补充：关系数据库：关系子模式-视图（view）\n关系操纵 查询：单表查询可以有纵向定位（行选择）和横向定位（选择列），多表查询先将多张表合并再用单表查询操作。可以被分解为三个基本操作：两个关系的合并，单个关系内元组指定，单个关系内属性指定\n插入：一条数据插入操作只能向一个关系中增加元组\n删除：删除的基本单位是元组，一次操作只能删除一个关系内的元组\n修改：不是一个基本操作，可以通过先删再插的操作实现\n操纵对象是关系\n空值处理 关系的主键中不允许出现空值（完整性约束）\n算数表达式中出现空值，结果为空值\n逻辑表达式中出现空值，为逻辑假\n如果是出现了集合中的空值元素，那么仍可使用SUM,AVG,MAX,MIN,COUNT等统计运算，空值不被计算\n如果是对空集进行统计运算，则SUM,AVG,MAX,MIN为空值,COUNT为0\n注意：COUNT(*)是统计元组个数，不存在空值元素问题\n三类数据完整性约束 实体完整性约束：主键中的属性不为空\n参照完整性约束：外键要么取空值，要么是被引用表中当前存在的某元组上的主键值\n用户定义的完整性：用户自己定义的属性取值约束\n关系操纵的表示 n元关系R是一个n元有序组的集合，关系R是n个属性的属性域的笛卡尔乘积的子集\n关系上的基本操作与关系代数中的五种基本运算：\n 元组选择-选择运算 属性指定-投影运算 关系的合并-笛卡尔乘积 元组的插入-并运算 元组的删除-差运算  相容表(compatible tables):Head(R)=Head(S),属性值域相同(不代表一个表中这个属性的所有值要在另一个表中出现)且有相同的意思\n并运算：\n 条件：参与运算的两个关系为同类关系(具有相同属性个数且值域相同) 结果：关系模式不变  差运算（R-S）：\n 条件：参与运算的为同类关系 结果：关系模式不变，由所有属于关系R但是不属于关系S的元组所构成的集合  差运算不满足结合律\n投影运算：略去关系中某些列而重新安排剩余列的排列次序的运算 $\\pi_{B_1,B_2,..B_m}$\n 运算结果：一个由 $B_1,B_2,..B_m$ 组成的m元关系，注意消除结果中可能出现的重复元组  选择运算：根据给定条件F从关系R中选出符合条件的元组, $\\sigma_F(R)$\n 结果：关系模式不变，由属于R且满足F的元组组成  可以解和投影与选择来实现单张表中的数据查询，在没有括号的情况下，运算顺序从右到左\n笛卡尔乘积：两个关系的合并运算，$R\\times S$,若R，S分别有n,m个属性，p,q个元组，则笛卡尔乘积有$n+m$ 个属性，$pq$ 个元组\n如果笛卡尔乘积中存在相同的属性名，必须在结果中选择一个进行换名\n关系模型与关系代数 关系：n元有序组的集合\n关系操纵：关系上的集合运算\n关系代数：$(A,\\pi,\\sigma,\\times,\\cup,-)$\n注意最大最小的比较的时候用$\u0026lt; \\text{or},\\leq$.\n关系代数中的扩充运算 交运算：\n 条件：同类关系 结果：关系模式不变，既属于R也属于S的元组 可以用差运算实现 $ R-(R-S) $  除运算（$R\\div S$）：\n 运算条件：$Head(S)\\subset Head(R)$ 运算结果：$ Head(T)=Head(R)-Head(S) $ ,结果元组T中的元组在S和R中对应同一个值 $$R\\div S = \\pi_{A_1,..A_n}(R)-\\pi_{A_1,..,A_n}((\\pi_{A_1,..,A_n}(R)\\times S)-R)$$  注意的是用商和除数进行笛卡尔乘积，得到的是原被除数的一个子集\n连接运算（$\\theta-连接$，$R {\\bowtie}_{F}S$）:对满足条件F的R中和S中的元组合并为一个关系\n 结果：$Head(T)=Head(R)\\cup Head(S)$，不必消除同名属性但是要换名 推导：$\\sigma_F(R\\times S)$  自然连接：( $R\\bowtie S$ ):自动根据两个关系中的同名属性进行等值连接(即把R和S中同名属性相同的连接在一起)\n关系代数的应用 在订单类的题目中，如果需要使用减法，注意从订单中减还是顾客/供应商减\n关系演算  原子公式，公式的定义\n 在关系演算中，关系用谓词来表示，关系上的操作可以用**关系演算公式(简称公式)**来表示\n元组关系演算：公式中的每个变元都是一个元组\n域关系演算：每个变元的取值都是单个的属性值\n关系演算就是对于所有在关系中的元组对这个谓词是成真指派，其余全是成假指派\n原子公式：\n 谓词R(t)是原子公式 $ u(i)\\theta v(j)$是原子公式，其中u,v为元组变量，u(i)表示元组u上的第i个属性 $u(i)\\theta a$是原子公式，其中a为常量  所有的目标属性以自由变元的形式出现，其他属性以约束变元的形式出现，如检索学生的学号姓名，可以$\\exist sd,sa(S(sno,sn,sd,sa))$.\n当变元与常量进行相等比较的时候，可以直接用常量值代替变元出现在谓词中，如$\\exist cn,pno(C(cno,cn,pno)\\wedge pno='C2')$和$\\exist cn(C(cno,cn,'C2'))$是等价的\n关系的联结：\n 可以通过相关谓词的逻辑与运算实现两个关系的笛卡儿乘积：R(p) ∧ S(q) 在1)的基础上再通过选择条件 F 实现两个关系的θ-联结：$R(p) ∧ S(q) ∧ F$ 可以通过两个谓词中的公共变元（同名变元）实现两个关系的自然联结：$R(x,y,z) ∧ S(y,u,v)$  自联结：谓词名不变，对部分变元进行重命名，从而实现关系的自联结（同名变元取值相等）\n关系演算与关系代数：假设公式$\\phi1$代表关系R1,$\\phi2$对应R2\n $\\phi1 \\wedge \\phi2$:  有公共变元表示R1,R2的自然连接 无公共变元表示笛卡尔积   $\\phi1 \\rightarrow \\phi2$: $R2 \\div R1$  ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/relational-database-system/","tags":null,"title":"关系数据库系统"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 3\n 感觉这一章就给了一些基础概念，看西瓜书也成啊\n3.1 The Agent–Environment Interface The learner and decision maker is called the agent. The thing it interacts with, comprising everything outside the agent, is called the environment.\nOne time step later, in part as a consequence of its action, the agent receives a numerical reward, $R_{t+1}\\in \\textbf{R}$, and finds itself in a new state, $S_{t+1}$.\n定义：$p(s', r|s, a)= Pr{S_t=s',R_t=r | S_{t−1}=s,A_{t−1}=a}$ The function p defines the **dynamics** of the **MDP**\n可以看出在马尔可夫决策过程中，每一个的概率只依靠于前一次的状态于动作\n类似的，可以定义以下函数：\nThe general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment.\n然后举了几个简单的例子，有兴趣可以去看\n3.2 Goals and Rewards 在强化学习中，agent的目标是获取最大化的奖励和。这意味着不能单单只看立即得到的眼前的奖励，而要看长远过程下的奖励之和\n奖励信号更应该告诉agent最终目标，而不是其实现过程，如同下棋时，应当是当你赢时给与奖励而不是局部最优时给予，如果那样设定的话可能导致agent追求局部最优而忽略全局\n3.3 Returns and Episodes In general, we seek to maximize the expected return, where the return, denoted $G_t$, is defined as some specific function of the reward sequence. In the simplest case the return is the sum of the rewards:$G_t=R_{t+1} + R_{t+2} + R_{t+3} + · · · + R_T$ , where T is a final time step.\nThis approach makes sense in applications in which there is a natural notion of final time step, that is, when the agent–environment interaction breaks naturally into subsequences, which we call episodes(有时也用trials)\n每一个episode都有一个终止状态，终止状态后将被重置为初始状态\nTasks with episodes of this kind are called episodic tasks（举例：下棋，走迷宫）. In episodic tasks we sometimes need to distinguish the set of all nonterminal states, denoted $S$, from the set of all states plus the terminal state, denoted $S^+$. The time of termination, $T$, is a random variable that normally varies from episode to episode\n但也有些任务是一直不会终止的，我们称为continuing tasks, 这样的话我们的$G_t$将会是无限大，故而我们采取一种概念上复杂但是数学上简单的discount定义\n$$G_t=R_{t+1} +\\gamma R_{t+2} +\\gamma^2 R_{t+3} + · · · =R_{t+1} + \\gamma G_{t+1}$$\n即discounting rate $0 \\leq \\gamma\\leq 1$，决定了未来奖励的当前价值。\n3.4 Unified Notation for Episodic and Continuing Tasks 在之后的介绍中，我们两种任务都会探讨，所以我们希望寻求一种能够通用的表示两种任务的记法\n我们可以考虑让episode tasks 在进入终止状态后进入一个特殊的 absorbing state，在这个状态下永远只转移到自身状态并且reward永为0，如下图深色方框： 故而可定义$$Gt=\\sum_{k=t+1}^T\\gamma^{k−t−1}R_k$$，这个公式包含了$T = \\infin$ or $\\gamma = 1$ (but not both)的可能性.\n3.5 Policies and Value Functions value functions—functions of states (or of state–action pairs) that estimate how good it is for the agent to be in a given state (or how good it is to perform a given action in a given state).\npolicy is a mapping from states to probabilities of selecting each possible action.\n定义：\nstate-value function for policy : $v_\\pi(s) = E_\\pi(G_t | S_t = s) = E_\\pi( \\sum_{k=0}^{\\infty} \\gamma^k R_{t+k+1} | S_t =s)$\naction-value function for policy: $q_\\pi(s, a) = E_\\pi(G_t | S_t = s, A_t = a) = E_\\pi( \\sum_{k=0}^{\\infty} \\gamma^k R_{t+k+1} | S_t =s, A_t = a)$\n我们一般可以通过经验（大量随机实验样本的均值）来获取其估计值，（如Monte Carlo methods），但是当状态空间很大的时候，这是不现实的，那时可以将其当作参数方程，通过调参的方式来得到返回值，其精确度取决于近似方式\n满足递归关系, 称为是Bellman equation for $v_\\pi$, It expresses a relationship between the value of a state and the values of its successor states. 如果已知参数（p(s′,r|s,a),π等), 则可以视为线性方程组，对于小规模的状态集，可以直接求解，其解就是值函数\n对应的backup diagram：\n3.6 Optimal Policies and Optimal Value Functions optimal policy：$\\pi_*$\noptimal state-value function, denoted $v_*$ and defined as $v_*(s) = \\max_\\pi v_\\pi(s)$\noptimal action-value function, denoted $q_*$, and defined as $q_*(s,a) = max_\\pi q_\\pi(s,a)$\n有关系： $q_*(s, a) = E[R_{t+1} + \\gamma v_*(S_{t+1}) | S_t=s,A_t=a]$ .\n因为$v_*$也是policy的value-function，故而其也满足贝尔曼方程的条件，称为**Bellman optimality equation**.\n可以写作： 最后两行（3.18，3.19）是两种常见的不同的表达形式\n对应的有： 对应的backup diagram为： For finite MDPs, the Bellman optimality equation for $v_{*}$ has a unique solution。如果有n个状态，那么就得到一个n个变量的n个等式，如果知道必要的参数，可以通过解非线性方程组的方式对其进行求解\n解出来后： If you have the optimal value function, $v_{*}$, then the actions that appear best after a one-step search will be optimal actions. Another way of saying this is that any policy that is greedy with respect to the optimal evaluation function $v_{*}$ is an optimal policy.\nWith $q_{*}$, the agent does not even have to do a one-step-ahead search: for any state s, it can simply find any action that maximizes $q_{*}(s, a)$.\n但是这种方式的缺点在于：我们需要精确的知道环境的动态性质且有足够的计算资源去完成所有运算，同时环境需满足马尔科夫性质\n Many different decision-making methods can be viewed as ways of approximately solving the Bellman optimality equation. For example, heuristic search methods can be viewed as expanding the right-hand side of (3.19) several times, up to some depth, forming a “tree” of possibilities, and then using a heuristic evaluation function to approximate $v_{*}$ at the “leaf” nodes. (Heuristic search methods such as $A^*$ are almost always based on the episodic case.) The methods of dynamic programming can be related even more closely to the Bellman optimality equation. Many reinforcement learning methods can be clearly understood as approximately solving the Bellman optimality equation, using actual experienced transitions in place of knowledge of the expected transitions. We consider a variety of such methods in the following chapters.\n ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl3/","tags":null,"title":"Finite Markov Decision Processes"},{"categories":null,"contents":" （国家能力是）对力量强大的社会组织实际的或潜在的反对时，国家执行其正式目标的能力。\n——西达·斯考切波\n 世界版图上的国家 如果身处那些被评级为危险或危急的国家，那里的人们首先关心的可能不是民主与自由，而是安全和秩序。\n国家起源的逻辑：安全与暴力 国家的起源与人性的基本渴望有关。（两种基本渴望：一种是对安全的渴望，一种是对自主的渴望）\n随着20世纪80年代国家理论的兴起，学术界越来越认识到国家本身就是一个重要的政治问题。\n 国家是社会在一定发展阶段上的产物；国家是承认：这个社会陷入了不可解决的自我矛盾，分裂为不可调和的对立面而又无力摆脱这些对立面。而为了使这些对立面，这些经济利益互相冲突的阶级，不致在无谓的斗争中把自己和社会消灭，就需要有一种表面上凌驾于社会之上的力量，这种力量应当缓和冲突，把冲突保持在“秩序”的范围以内；这种从社会中产生但又自居于社会之上并且日益同社会相异化的力量，就是国家。 ——恩格斯\n 恩格斯的国家理论是基于政治冲突的视角，即从对冲突的考察、对秩序的需要来理解国家的起源。\n相通的逻辑。众人能生活在一个相对安全的社会里，是因为一个拥有巨大暴力的机构的存在，这种巨大暴力的存在使得普通的个人与个人之间潜在的暴力被遏制了。\n从封建主义到现代国家 封建制度是一种融合了保护与效忠关系、人身依附与契约精神的复杂混合体。封建制度的基础是土地，领主享有某些特定的权利，同时需要承担某些特定的义务；附庸也是如此。\n在封建主义体系中，国王与不同贵族之间的关系既是一种经济关系，又是一种政治关系；既包含了人身依附的等级制色彩，又包含一种基于传统的契约精神。\n封建主义对现代政体的一个特殊贡献是，近现代立宪政体是从封建制度中直接演化出来的。\n查尔斯·蒂利把现代国家的兴起视为一个“战争塑造国家，国家制造战争”的过程。（凡是那些没有发展出军队、官僚制和税收系统的政治实体就慢慢被消灭了。那些拥有军事优势的政治实体通过发动战争会占领更大的地盘。）\n理解国家的不同维度 韦伯的国家定义被总结为一句简单的话：国家是合法垄断暴力的组织\n现代国家的基本特征：\n 有特定疆域 包含特定人口 垄断暴力 需要一整套官僚系统 依赖于税收系统 国家主权需要得到国际承认  关于国家的理想角色，目前大致有三种主要观点。第一种观点认为，国家的理想角色主要是提供保护；第二种观点认为，国家的理想角色主要应该是促进发展；第三种观点认为，国家的理想角色主要应该是提供福利。\n国家理论的不同流派  多元主义国家理论：沿袭自由主义传统，一般适用于现代的自由民主国家。  在多元主义视角下，代表不同社会利益的政党和集团在国家这个政治舞台上进行政治竞争，背后则是民众的广泛参与和不同利益的表达。在这一理论框架中，国家本身没有自己的自主性和利益。最后国家的公共决策则被视为不同利益集团政治竞争和博弈的一种均衡。   马克思主义国家理论：基础是阶级分析方法  国家是为一个社会的经济生产方式和阶级利益服务的；或者更直接地说，国家是阶级统治的工具。通过国家，统治阶级实现了对被统治阶级的政治统治，从而可以更好地实现其经济利益。 马克思主义国家理论具有很强的经济决定论色彩。经济上的支配阶级，也是政治上的支配阶级。国家的本质是经济上的支配阶级实现对被支配阶级进行政治统治的工具。 国家本身并没有自主性，国家的意志不过是统治阶级意志的反应，其最终目标是服务于统治阶级的经济利益。   新古典国家理论：理性选择学派的国家理论  国家被模型化为一个追求统治收益最大化的统治者。这种国家理论采用的是经济人假设和新古典经济学的分析方法。   国家主义国家理论：关于国家的精英主义视角  国家具有自主性，而且根据国家自身利益行事。由此可见，这种理论框架具有强烈的国家中心论视角，而非过去很多理论沿袭的社会中心论。    国家构建与国家能力 但启蒙运动以来的思想传统倾向于把国家视为一种“必要的恶”，这是一种自由主义的视角。\n彼得·埃文斯等主编的《找回国家》认为，社会科学研究中以社会为中心的理论视角应该被摒弃，而国家与社会互动的视角或者以国家为中心的视角是值得倡导的。\n国家主义理论常用的三个概念：\n  国家自主性：现代国家总是处在一个国家构成的全球体系中，处在国际体系和国内社会临界点上。这样，国家只能根据国家竞争和地缘政治需要来采取政治行动。因此，国家不一定会受国内社会力量的直接约束，而是从适应国际体系中国家间竞争的需要出发自主地行动。这被视为国家自主性的重要来源\n 自主性面临的质疑：  理性选择学派提出的问题：国家自主性的概念背后有没有微观基础？国家自主性的微观基础是什么？是官僚集团的利益吗？如果不是，那又是什么呢？ “几乎没有一个国家是统一的运作者”。比如，对于“国家按照自己的利益行事”这种说法，基欧汉和奈等学者就追问过：“是什么样的自己，是什么利益？” 几乎没有哪个国家拥有执行其国家目标和意志所需的全部资源。为了实现国家目标和意志，国家统治精英几乎都需要以某种方式与社会中的强势集团进行结盟或协商。一旦国家与社会的互动贯穿其中，国家自主性就可能成为一个问题。      国家构建：指一个现代国家或一个有效的现代国家塑造的过程\n 政治共同体的形成 国家机构与制度建设的问题 国家能力塑造和增强的过程    国家能力，对此的定义有两种视角\n 从国家与社会的关系视角来定义  斯考切波认为，国家能力是指“面对力量强大的社会组织实际的或潜在的反对时，国家执行其正式目标的能力”。 米格代尔认为，国家能力是指国家领导层“通过国家的计划、政策和行动来实现其改造社会的目标的能力”   从国家本身来定义  国家能力是指国家机关对现有的非国家资源、活动和人际关系的干预，改变那些资源的现行分配状态，改变那些活动、人际关系以及在分配中的关系的程度。      国家能力的不同视角 迈克尔·曼把国家能力区分为两种类型：专制性权力和基础性权力（也被译为“独裁性权力”与“建制性权力”）\n专制性权力来源于强制力。专制性权力强，意味着国家可以不必与市民社会协商，不必经过与社会讨价还价，即可自行决策及将决定强加于社会的权力。\n基础性权力是国家以制度化方式向社会渗透、与社会互动而在其领土范围内有效贯彻其政治决策的能力。基础性权力依赖于稳定的制度化路径，而专制性权力依赖的是随意的强制力。\n对应这两种能力的强弱，可以分为四类国家\n弗朗西斯·福山在《国家构建》中区分了国家能力的两个维度：一是国家职能范围，二是国家力量强弱\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap4/","tags":null,"title":"政治生活中的国家"},{"categories":null,"contents":" 基本的共射级，工作原理，如何估算静态工作点， 重要：负载线怎么来的，怎么画 失真与静态工作点的关系 温度的影响（定性的把握） 基极分压式要认识，稳定工作的原理\n 三极管放大电路 在输入为交流信号时，常常在输入输出处都加入一个电容用来阻隔直流信号，防止影响外部电路。\n工作原理 静态 输入信号$v_i=0$,放大电路的工作状态称为静态或直流工作状态\n$I_{BQ}=\\frac{V_{BB}−V_{BEQ}}{R_b}$\n$I_{CQ}=\\beta I_{BQ}+I_{CBO} \\approx \\beta I_{BQ}$\n$V_{CEQ}=V_{CC}−R_c∗I_{CQ}$\n一般硅管的$V_{BE}=0.7V$,锗管的$V_{BE}=0.2V$\n求Q点时，一般先假设电路中BJT满足放大电路条件，求出相应的参数，然后观察是否满足放大条件。\n动态 输入正弦信号$V_s$后，电路处在动态工作状态，此时各极电流电压都会在静态值的基础上随输入信号变化\n 先确定静态工作点$Q(I_{BQ},I_{CQ},V_{CEQ})$ 再动态确定性能指标$(A_V,R_i,R_o)$  图解分析法 静态工作点的图解分析 采用此方法的前提时必须已知三极管的输入输出特性曲线\n利用输入回路方程$V_{BE}=V_{BB}-i_BR_b$做出直线与输入特性曲线的交点得到$I_{BQ}$\n再利用输出回路方程$V_{CE}=V_{CC}-i_CR_C$,在输出特性曲线上与$I_{BQ}$曲线对应的就是Q点。得到$V_{CEQ}$和$I_{CQ}$\n动态工作的分析图解 根据$V_s$的波形，在BJT的输入特性曲线上画出$V_{BE}$和$i_B$的波形\n图中参数: $V_s=V_{sm}sin(wt)$ $V_{BE}=V_{BB}+v_S-i_BR_b$\n然后根据上图得到的$i_B$的变化范围在输出特性曲线上画出$i_c$和$V_{CE}$的波形(利用$V_{CE}=V_{CC}-i_CR_c$)\n静态工作点对波形失真的影响 静态工作点过高 静态工作点过高会导致饱和失真\n静态工作点太低 静态工作点太低会出现截止失真\n所以工作点要设置在输出特性曲线放大区的中间部位，要有合适的交流负载线\ntbd:ppt上思考题\n温度对工作点的影响   温度每升高10度，$I_{CBO}$约增加一倍\n 温度上升，输出特性曲线上移    温度每升高1度，$\\beta$值增大$0.5%-1%$\n 温度上升，输入特性曲线族间距加大    $V_{BE}=V_{BE(T_0=25C)}-(T-T_0)*2.2*10^{-3}V$\n 温度上升,输入特性曲线左移    基极分压式射极偏置电路 目标是：温度变化时使得$I_{CQ}$保持恒定。即我们需要**b点的电位能基本不变**，即可实现静态工作点的稳定\n稳定工作点的原理:\n 保证b点电位基本不变：使$I_1\u0026gt;\u0026gt;I_{BQ}$，$V_B\u0026gt;\u0026gt;V_{BEQ}$,此时$V_{B}=\\frac{R_{b2}}{R_{b1}+R_{b2}}V_{CC}$, 与温度无关 通过反馈控制：温度上升 -\u0026gt; $I_{CQ}$上升 -\u0026gt; $I_{EQ}$上升 -\u0026gt; $V_E$上升，$V_B$不变 -\u0026gt; $V_{BEQ}$下降 -\u0026gt; $I_{BQ}$下降 -\u0026gt; $I_{CQ}$下降 Re取值越大，反馈控制作用越强 一般取 $I_1 =(5-10)I_{BQ}$， VB =3~5V  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E4%B8%89%E6%9E%81%E7%AE%A1%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/","tags":null,"title":"三极管放大电路"},{"categories":null,"contents":"网络层：数据平面  重点：4.2、4.3 网络传输中ipv4报文首部哪些不会改变\n 网络层：实现主机到主机之间的通信服务，与运输层和应用层不同的是，网络中的每一台主机和路由器之间都有一个网络层部分。\n网络层能够分解成两个相互作用的部分，即数据平面和控制平面。数据平面指网络层中每台路由器的功能，决定路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。控制平面即网络逻辑的范围，控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。**软件定义网络(Software-defined Networking ,SDN)**通过将控制平面功能作为一种单独服务，明确分离数据平面与控制平面。\n4.1 网络层概述 转发：分组从一个输入链路接口转移到适当的输出链路接口的路由器的本地动作\n路由选择：确定分组从源到目的地所采取的端到端路径的网络范围处理过程\n控制平面的路由选择算法决定了数据平面的本地转发表\nSDN：把原本实现在路由器中的路由选择算法转移到远程控制器上\n因特网的网络层是尽力而为服务，既不能保证最终交付，也不能保证按序被接收，不能保证端到端时延，也能保证有最小的带宽。\n分组交换机中链路层交换机是基于链路层中帧的字值段做决定，而路由器是网络层设备\n4.2 路由器工作原理 路由器的体系结构：\n 输入端口  终结入物理链路的物理层功能 与入链路远端的数据链路层交互来执行数据链路层功能 执行查询功能， 决定路由器的输出端口 控制分组(携带路由选择协议的分组)从输入端口转发到路由选择处理器   交换结构：将路由器中的输入端口连接到输出端口 输出端口：存储从交换结构接收的分组并通过执行必要的链路层和物理层功能在输出链路上传输这些分组 路由选择处理器：执行控制平面功能，传统的路由器中执行必要的路由选择协议，维护路由选择表和关联链路状态信息，并计算转发表，在SDN中，路由u谢娜则处理器负责与远程控制器通信  4.2.1 输入端口处理与基于目的地转发 输入端口处理：线路端接-\u0026gt; 数据链路处理 -\u0026gt; 查找、转发、排队\n路由器使用分组目的地址的前缀进行最长前缀匹配\n在某些设计中，如果来自其他输出端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时暂时被阻塞，被阻塞分组在输入端口处排队等待被及时调度\n输出端口的其他动作:\n 出现物理层和链路层处理 检查分组版本号、检验和寿命字段，并重写后两个字段 更新用于网络管理的计数器  4.2.2 交换  经内存交换：所有输入共享内存 经总线交换：输入端口为分组计划一个内部标签，与首部匹配的输出端口存分组并去除表情啊 经互联网络交换：可以并行，纵横式的，到不同输出端的分组不会相互阻塞  4.2.3 输出端口处理 排队-\u0026gt;数据链路处理(协议、封装)-\u0026gt;线路端接\n4.2.4 何处出现排队 路由器缓存空间耗尽并无内存可用时会出现丢包\n 输入排队  交换结构不足以使所有到达分组无时延传输 HOL阻塞：被线路前部的一个分组阻塞，如两个分组发送一个目的地   输出排队  4.2.5 分组调度 先进先出(FIFO)：维护队列\n优先权排队：每个优先权有自己的队列，队列内部FIFO。必须高优先级的列空了才处理低优先级，是非抢占的即已经开始的传输不会被打断\n循环和加权公平排队：\n 循环排队规则：将组分成多个队列，轮流提供服务，不允许链路空闲，如果有空则立即检查序列中下一个类 加权公平排队(WFQ):每个类被分配一个权值，保证该类发送的分组中确保接收到的服务部分比例与权重比例一致  4.3 网际协议:IPv4、寻址和IPv6 4.3.1 IPv4数据报格式 |版本4|首部长度4| 服务类型8 | 数据报长度16 | | 16比特标识 |标志3| 13比特片偏移 | | 寿命8 | 上层协议8 | 首部校验和8 | | 32比特源IP地址 | | 32比特目的IP地址 | | 选项(可选) | | 数据 |  版本（号）：规定了数据报的IP协议版本 首部长度：因为可包含一些可变数量的选项 服务类型：(TOS) 使不同类型的IP数据报能够区分开来 数据报长度: IP数据报的总长度(首部+数据) 标识、标志、位偏移：与IP分片有关 寿命(TTL): 确保数据报不会永远在网络中循环，每当一台路由器处理数据报时，这个字段的值就减去1 协议：通常仅当一个IP数据报到达期最终目的地时才有用，字段指示了IP数据报应该交给哪个特定的运输层协议，为6则TCP，为17则UDP 首部校验和：首部校验和用于帮助路由器检测收到的IP数据报中的比特错误。计算方式：每两个字节当成一个数，用反码算数进行求和 源和目的IP地址 选项：允许IP首部被扩展 数据(有效载荷)  一般而言，IPv4的首部长20字节\n4.3.2 IPv4数据分片 链路层帧能够承载的最大数据量：MTU(最大传送单元)\n为了限制最大传输单元MTU，将数据报分片，并设置标识：\n 发送主机对每个他发送的数据报的标识号+1，一个数据报的各个分片的标识相同 最后一个片的标志比特设为1，其余设为0. 偏移字段指定片在初始数据报的哪个位置(每个片也是一个IP数据报)  数据报的重新组装在端系统中而不是网络路由器中\n4.3.3 IPv4编址 IP要求每台主机和路由器接口拥有自己的IP地址，从技术上讲，一个IP地址与一个接口相关而不是接口对应的主机或者路由器相关\n每个IP地址为32比特四字节，采用点分十进制记法书写，每个字节用十进制书写，各个字节之间以句点断开。\n一个IP地址的一部分需要其连接的子网决定，a.b.c.d/x中的/x记法称为子网掩码，而这子网的前x个比特称为这个地址的前缀\n为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，用接口端接这些隔离的网络的端点，这些隔离的网络中的每一个都叫做一个子网\n因特网的地址分配策略被称为是无类别域间路由选择(CIDR)\nIP广播地址：255.255.255.255，交付给同一网络中的所有主机\n获得一块地址 获取一块IP地址用于一个组织的子网内，某网络管理员可能首先与他的ISP联系，该ISP可能从已分给他的更大地址中提供一些地址\n获取主机地址：动态主机配置协议 DHCP允许主机自动获取一个IP地址，可能是固定的，也可能是一个临时的IP地址\n同时，DHCP允许主机得知他的子网掩码，第一跳路由器地址(默认网关)、本地DNS服务器的地址\nDHCP：即插即用协议，也称零配置协议\n DHCP服务器发现：使用DHCP发现报文完成，在UDP分组中向端口67发送该报文，UDP分组封装在一个IP数据报中。使用广播目的地址255.255.255.255使用源地址0.0.0.0。传递给链路层，链路层广播该子网连接的节点 DHCP服务器提供：收到一个发现报文后，用DHCP提供报文做出响应，该报文向子网的所有节点广播，仍然使用IP广播地址255.255.255.255. DHCP请求：从一个或者多个服务器提供的IP选择一个，并提供DHCP请求报文进行响应，回显配置参数 DHCP ACK：服务器使用DHCP ACK报文对DHCP请求报文进行响应证实需要的参数  4.3.4 网络地址转换 网络地址转换：NAT\n他和他背后的网络对外界是一台单一的设备\nNAT路由器将重写IP地址和端口号字段\nNAT转换表：内部地址：端口 - 外部地址：端口\n4.3.5 IPv6 数据报格式 |版本4| 流量类型8 | 流量标签20 | | 有效载荷长度16 |下一个首部8| 寿命8 | | 源地址128 | | 目的地址128 | | 数据 |  一共40字节 版本：IP版本号 流量类型：(类似IPv4的服务类型TOS) 流标签：标识一条数据报的流，能够对一条流中的某些数据给出优先权 有效载荷长度 下一个首部：(类似IPv4中的协议字段)需要交付给哪一个协议，如TCP和UDP 跳限制：(类似IPv4中的寿命限制) 跳限制技术达到0，数据报被丢弃 源地址和目的地址：128比特，引入了任播地址：可以将数据报交付给一组主机中的任意一个 数据：有效载荷  在IPv6中不存在分片/重新组装，首部校验和，选项字段(但是可能出现在下一个首部指向的字段中)\n从IPv4向IPv6迁移 建隧道：将两台IPv6路由器中间IPv4路由器合称隧道，将IPv6的整个数据报放到一个IPv4的数据报的有效载荷中去，通过观察IPv4的协议号是41可以指示器有效载荷是IPv6数据报\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wang-luo-ceng-shu-ju-ping-mian/","tags":null,"title":"网络层-数据平面"},{"categories":null,"contents":"SQL语言  3.4 关系数据库语言SQL’92\n3.4.1 SQL概貌\n SQL的基本概念与使用方式：表（基表/虚表），行，列  3.4.2 SQL数据定义功能\n3.4.3 SQL数据操纵功能\n SQL语言与关系代数的关系 映像语句（select statement）的结构 select/from/where/group by/having/order by 两个必须的子句: select/from having子句的前面必须有group by子句 基本查询功能：distinct谓词；LIKE，IS NULL谓词；多表联接查询；表的自联接查询； 嵌套查询：IN，SOME/ANY/ALL，EXISTS等谓词；相关子查询与独立子查询； 子查询的合并：UNION/INTERSECT/EXCEPT/ALL运算 UNION / INTERSECT / EXCEPT UNION ALL / INTERSECT ALL / EXCEPT ALL 统计查询（GROUP BY和HAVING）：统计与分组统计查询；空值与空集在统计函数中的处理方法 复杂数据查询： 统计查询 分组统计查询（… GROUP BY） 分组选择统计查询（… GROUP BY … HAVING …） 关系代数中的除法运算功能在SQL中的表示方法 多层嵌套的NOT EXISTS查询 在FROM子句中嵌入子查询 查询结果输出 结果元组去重：distinct 结果元组排序：order by  3.4.4 SQL的更新功能\n 元组删除 元组插入：常量元组的插入，带子查询的元组插入 元组修改  3.4.5 视图\n 视图概念，视图与基表的区别 视图的创建（CREATE VIEW）与删除（DROP VIEW） 视图的嵌套定义 视图删除中的连锁反应 可更新视图的判断准则 视图的作用   SQL概貌 关系模型和SQL对应：\n 关系：基表 关系子模式：视图(虚表) 属性：列 元组：行  SQL不区分大小写\n一条命令以分号作为结束\nSQL 数据定义功能    符号 数据类型     INT 整数(2147483647)   SMALLINT 短整数(32767)   DEC(m,n) 十进制数(精度为m,小数位为n的小数)   FLOAT 浮点数   CHAR(n) 定长字符串   VARCHAR(n) 变长字符串   BIT(n) 定长位串   BIT VARYING(n) 变长位串   DATE 日期(年月日)   TIME 时间(小时、分、秒)   TIMESTAMP 时间戳(年月日小时分钟秒微秒)    时间戳的格式：yyyy-mm-dd-hh.mm.ss.nnnnnn\n创建表格：\nCREATE TABLE tablename ( colname datatype [ NOT NULL ] { , colname datatype [ NOT NULL ] } ) ; 对基表的属性进行增加/删除：\nALTER TABLE \u0026lt;基表名\u0026gt; ADD \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;; ALTER TABLE \u0026lt;基表名\u0026gt; DROP \u0026lt;列名\u0026gt; ; 删除表格\nDROP TABLE \u0026lt;基表名\u0026gt;; SQL数据操纵功能 映像语句（select statement）的结构：\n 目标子句 范围子句 条件子句 分组子句 分组查询语句 排序输出语句  SELECT * | colname { , colname ... } FROM tablename { , tablename ... } [ WHERE search_condition ] [ GROUP BY colname { , colname ... } [ HAVING group_condition ] ] [ ORDER BY colname [ ASC | DESC ] { , colname [ ASC | DESC ] ... } ]; having子句的前面必须有group by子句\n目标子句可以用'表名.属性名'来表明是哪一个表中的属性\n可以用AS对目标子句的结果重命名\n可以用distinct来消除结果中的重复元组\n可以在FROM子句中对一个关系重命名：\u0026lt;name\u0026gt; \u0026lt;newname\u0026gt;\nFROM子句中的部分是进行笛卡尔乘积进行合并\nBETWEEN..AND.. 谓词：包括了两端（对应的有NOT BETWEEN AND）\nLIKE谓词： column [NOT] LIKE val1 [ ESCAPE val2 ]\n模版（pattern）：val1\n 下划线（_）：可以匹配任意一个字符 百分号（%）：可以匹配任意一个字符串（包括长度为0的空字符串） 其它字符：只能匹配其自身  例如以A开头的学生姓名：WHERE sn LIKE 'A%'\n转义指示字符：val2\n 紧跟在转义指示字符val2之后的‘_’或‘%’（包括转义字符自身）不再是通配符，而是其自身  例如课程名中带有_ 的：WHERE cn LIKE '%A_%' ESCAPE 'A'\nIS NULL 与 IS NOT NULL；\n在查询语句中可以使用NOT、AND、OR构造复杂的逻辑式\n嵌套查询：\n [NOT] IN () $\\theta$ SOME/ANY/ALL () [NOT] EXISTS ()  相关子查询:子查询中调用了外层查询，每次外层元组变量变化后都重新执行一次子查询，执行顺序从外到内\n独立子查询: 子查询只执行一次，执行顺序从内到外\n子查询之间的运算：\n 并：UNION[ALL] 交：INTERSECT[ALL] 差：EXCEPT[ALL]  统计查询：\n COUNT  COUNT(*):集合中的元组个数 COUNT(colname)：在colname属性上取值非空的元组个数 COUNT(distinct colname)：在colname属性上非空且互不相同的元组个数   SUM AVG MAX MIN  统计查询一般运用在SELECT语句中，如果需要使用条件可以利用子查询，举例如下\n\\\\ 查询有两个或两个以上的客户订购过的商品的编号（pid） SELECT p.pid FROM products p WHERE 2 \u0026lt;= ALL (SELECT count(distinct cid) FROM orders o WHERE o.pid = p.pid ) 不等于的表示：\u0026lt;\u0026gt;;\n使用了GROUP BY 语句之后，SELECT语句对每个分组进行查询，每个分组返回一条结果语句\ntip：在成绩类的判断中，常见的对于一个学生可以利用sno进行分组\n分组统计查询中，目标属性必须包括所有的分组属性\n在一些DBMS中，允许在FROM子句中嵌入子查询，举例如下：\n\\\\每个供应商单笔销售最高金额的平均值 SELECT avg ( t.x ) FROM ( select aid, max(dollars) as x from orders group by aid ) t ; 关系代数中的除法运算功能在SQL中的表示方法\n多层嵌套的NOT EXISTS查询\n在FROM子句中嵌入子查询\n查询结果输出\n结果元组去重：distinct\n结果元组排序：order by\n映像语句的处理顺序:\n 合并FROM子句中的表（笛卡儿乘积） 利用WHERE子句中的条件进行元组选择，抛弃不满足WHERE条件的那些元组 根据GROUP BY子句对保留下来的元组进行分组 利用HAVING子句中的条件对分组后的元组集合（group）进行选择，抛弃不满足HAVING条件的那些元 组集合 根据SELECT子句进行统计计算，生成结果关系中的元组 根据ORDER BY子句对查询结果进行排序  SQL数据更新功能 元组删除 DELETE FROM table_name [ WHERE search_condition ] ; 元组插入 INSERT INTO tabname [ ( colname { , colname … } ) ] VALUES ( expr | NULL { , expr | NULL … } ) | subquery; 可以插入常量元组（VALUES(...)），也可以将子查询结果插入(subquery)\n元组修改 UPDATE table_name SET colname = expr | NULL | subquery, ...... [ WHERE search_condition ] ; 视图 视图的定义：\nCREATE VIEW \u0026lt;视图名\u0026gt; [ ( \u0026lt;列名\u0026gt; { , \u0026lt;列名\u0026gt; … } ) ] AS \u0026lt;映像语句\u0026gt; [ WITH CHECK OPTION ] 视图:由若干张表经过映像语句构筑成的表，又称导出表\n视图与基表的区别：被称为视图的二维表本身（结构与数据）并不实际存在于数据库内，而仅仅保留了其构造信息（有关视图的定义信息）。因此视图又被称为‘虚表’（virtual table）。当用户执行视图上的访问操作时，数据库管理系统将根据视图的定义命令将用户对于视图的访问操作转换成相应基表上的访问操作\n视图的创建 (CREATE VIEW) CREATE VIEW \u0026lt;视图名\u0026gt; [ ( \u0026lt;列名\u0026gt; { , \u0026lt;列名\u0026gt; … } ) ] AS \u0026lt;映像语句\u0026gt; [ WITH CHECK OPTION ] 如上创建一个以\u0026lt;视图名\u0026gt; 为表名的视图，对应的数据查询语句是\u0026lt;映像语句\u0026gt;。以\u0026lt;映像语句\u0026gt;作查询所得到的查询结果即是该视图中的元组。\n如果没有给视图中的属性命名，则用\u0026lt;映像语句\u0026gt;的SELECT子句中的属性名作为视图属性的属性名。否则视图中的属性必需与\u0026lt;映像语句\u0026gt;的SELECT子句中的结果属性一一对应\nWITH CHECK OPTION用于约束视图上的修改操作：如果允许在该视图上执行更新操作，则其更新后的结果元组仍然必需满足视图的定义条件。即通过该视图插入或修改后的新元组能够通过该视图上的查询操作查出来\n可以嵌套的创建视图（即映像语句中FROM一个已经存在的视图）\n视图的删除（DROP VIEW） DROP VIEW \u0026lt;视图名\u0026gt; 删除一个视图后，那些嵌套定义在该视图上的视图也会随之删除\n视图上可以进行查询操作(实际上是先改写成基表上的查询操作)\n允许进行视图上的更新需要满足：视图的每一行必须对应基表的惟一一行，视图的每一列必须对应基表的惟一一列\n 1、没有指定DISTINCT，即重复元组未从查询结果中消除； 2、定义查询的SELECT列表中的每个元素均为列名（而不是常量，表达式或聚合函数），且列名出现不能多于一次； 3、FROM子句只能指定一个表，即视图必须有一个源表且用户有请求该表的权限。如果源表本身就是一个视图，那么视图必须满足这些条件。因此，排除了基于连接、并（UNION）、交（INTERSECT）或差（EXCEPT）操作的所有视图 4、where子句不能包含任何引用了FROM子句的表的嵌套SELECT操作。 5、定义查询不能有GROUP BY或HAVING子句。  视图的作用：提高了数据独立性，简化了用户观点，提供了自动的安全保护功能\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/sql/","tags":null,"title":"SQL语言"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 4\n The key idea of DP, and of reinforcement learning generally, is the use of value functions to organize and structure the search for good policies.\n 如果看完了西瓜书，感觉这一章略读就好\n 4.1 Policy Evaluation (Prediction) 已知$\\pi$, 估计value-function：\n4.2 Policy Improvement 通过上面的算法，我们可以计算出一个policy的value函数，那么为了更好的提升policy，我们可以在当前状态s下选择另一个动作a，之后的行为仍然按照原policy执行，如果$q_\\pi(s,a) \u0026gt; v_\\pi(s)$的话，可以说明替换后的策略更好。\n证明如下： 那么我们可以得到一种greedy的策略：\n4.3 Policy Iteration 利用之前的evaluation与improvement来得到最优的策略：\nPolicy iteration often converges in surprisingly few iterations\n4.4 Value Iteration 由于每进行一次improvement都要进行一次评估，可能导致比较慢，所以可以考虑每进行一步就直接improvement\n这些西瓜书都讲了，再看一遍太浪费时间了\n4.5 Asynchronous Dynamic Programming 以上的DP算法 的一个缺点是需要遍历整个状态集多次，但是当状态集比较大的时候就耗时比较大了(比如举了无数次的例子的backgammon有$10^{20}$个状态)\nAsynchronous DP algorithms are in-place iterative DP algorithms that are not organized in terms of systematic sweeps of the state set. These algorithms update the values of states in any order whatsoever, using whatever values of other states happen to be available. The values of some states may be updated several times before the values of others are updated once. To converge correctly, however, an asynchronous algorithm must continue to update the values of all the states: it can’t ignore any state after some point in the computation. Asynchronous DP algorithms allow great flexibility in selecting states to update.\n第八章有更详细的讨论，不多写了\n4.6 Generalized Policy Iteration  Policy iteration consists of two simultaneous, interacting processes, one making the value function consistent with the current policy (policy evaluation), and the other making the policy greedy with respect to the current value function (policy improvement). In policy iteration, these two processes alternate, each completing before the other begins, but this is not really necessary. In value iteration, for example, only a single iteration of policy evaluation is performed in between each policy improvement. In asynchronous DP methods, the evaluation and improvement processes are interleaved at an even finer grain. In some cases a single state is updated in one process before returning to the other. As long as both processes continue to update all states, the ultimate result is typically the same—convergence to the optimal value function and an optimal policy.\n 我们用generalized policy iteration (GPI）来表示上述两个子过程不断接触修改\n 竞争中有合作，合作中有竞争\nThe evaluation and improvement processes in GPI can be viewed as both competing and cooperating. They compete in the sense that they pull in opposing directions. Making the policy greedy with respect to the value function typically makes the value function incorrect for the changed policy, and making the value function consistent with the policy typically causes that policy no longer to be greedy. In the long run, however, these two processes interact to find a single joint solution: the optimal value function and an optimal policy.\n如下图：\n 4.7 Efficiency of Dynamic Programming 如果用n和k表示状态数与动作数的话，忽略一些实现细节的情况下，复杂度为$k^n$\nIn practice, DP methods can be used with today’s computers to solve MDPs with millions of states\n4.8 Summary 总结了一下前面的内容，然后引出了新概念：\nAll of them update estimates of the values of states based on estimates of the values of successor states. That is, they update estimates on the basis of other estimates. We call this general idea bootstrapping\n","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl4/","tags":null,"title":"Dynamic Programming"},{"categories":null,"contents":" 民主政治不仅是最广泛受到称颂的政治制度，而且也可能是最难以坚守的政治制度。在所有的政府形式中，惟独民主政体依赖于最少的强制和最多的同意。民主政府最终发现它们自己陷于内在的悖论和矛盾的冲突中。……建立一个民主政治和坚守一个民主政治是两件不同的事。……假如民主不能起作用，人们则可能宁愿选择不经他们同意的统治，他们可能选择不再忍受去作出政治抉择的痛苦。\n​ ——拉里·戴蒙德\n 全球视野下的政体类型 比较正式的政体类型学起源于亚里士多德（可看第二章的笔记）\n到20世纪，现代政体类型一般被分类为：民主政体、威权主义政体和极权主义政体。\n胡安·林茨认为现代政体类型不止这三种，他在《民主转型与巩固的问题》中划分了五种现代政体类型，分别是民主政体、威权主义政体、全能主义（极权主义）政体、后全能主义（极权主义）政体和苏丹制政体。后全能主义政体是全能主义政体发生改革或演进的产物。后全能主义政体既可能转变为较为标准的威权主义政体，又可能仍然保留着比较多的全能主义特征。苏丹制，沿用的是马克斯·韦伯的概念，粗略地说是指完全基于个人统治的专制主义政体。\n详细说明\n什么是民主政体 约瑟夫·熊彼特《资本主义、社会主义与民主》（程序性定义）：民主方法就是那种为做出政治决定而实行的制度安排，在这种安排中，某些人通过争取人民选票取得作决定的权力。民主政治并不意味着人民真正在统治——就“人民”和“统治”两词的任何明显意义而言——民主政治的意思只能是：人民有接受或拒绝将要来统治他们的人的机会。\n达尔对于多头政体的界定，从实质性条件来看，主要是政治参与和政治竞争这两个标准。\n民主政体的几个基本特征：\n 政治参与 政治竞争 问责制或责任制 回应或响应机制 起码的政治平等。这里的政治平等是指具有平等的参与政治、政治表达和投票的基本权利，所有公民在这方面应该是平等的。 多数决定的规则  20世纪50年代，美国学者肯尼思·阿罗提出了著名的“阿罗不可能定理”，意思是说很多情况下多数决定规则实际上是不可能的   对少数权利的保护 言论自由与新闻自由  民主政体的治理细节 如果是民主政体，可以看到公民的基本诉求能通过一种正式的机制反馈到政府，并对其产生直接影响。\n民主政体意味着有效的问责制，意味着从公民到政府的积极响应机制，这种政体具有很强的自我调适能力。\n民主模式的多样性 直接民主和间接民主，后者又称为代议制民主。所谓直接民主，就是公民直接参与政治活动和政治决策的一种制度安排；所谓代议制民主就是公民选举代表参与政治活动和政治决策的一种制度安排。\n通常直接民主只适用比较小的地理和人口规模，如果这个范围过大的话就只能采用代议制民主的方法。\n现在的主流是代议制民主。当然，全民公决有时会作为代议制民主的一项补充性制度。\n代议制民主的好处：\n 代议制民主可以解决国家规模和统治可行性的问题，这使得大国的民主治理成为可能 在政治生活中恰到好处地平衡大众民意和精英治理之间的关系，用精英治理来平衡大众民意。  跟代议制民主有关的一个问题是平民主义民主与精英主义民主的分野：是否支持实质性政治平等\n精英主义的民主政体和威权主义的区别：\n 在民主主义的精英统治中，政治领导权是开放的（可以通过后天努力获取领导权）。对威权的精英统治来说，其政治权力封闭在一个规模相对较小的特定集团或特定圈子中。 民主的精英统治更需要兼顾公共利益，或者说是兼顾多数人的利益。至于威权的精英统治，更有可能只是为了少数人利益进行统治的。 在民主的精英统治下，普通公民可以通过投票来选择或否决政治精英。而威权的精英统治下，普通公民并不拥有这种政治权利。  民主的悖论与被误解的民主 三个悖论：  民主在发展中世界所经历的许多问题都是源自内在于民主的本性中的三种紧张和悖论。\n第一种紧张是冲突与认同之间的紧张。……没有竞争和冲突，就没有民主政治。但是，任何认可政治冲突的国家都冒着这样的风险，社会变得如此紧张，充满冲突，以至于社会的和平和政治的稳定都将陷于危境。\n第二种紧张或矛盾是代表性与治国能力的冲突。民主政治意味着不愿将权力集中到少数人手中，要使领导人和政策服从于人民的代表和责任机制。但是，为了稳定，民主政治（或任何政府制度）必须有亚历山大·汉密尔顿称作‘能量’的东西：它必须能够行动，必须能够随时地、迅速地、决然地采取心动。政府不仅应回应利益团体的需要，它还必须能够抵制它们的过分要求，并在它们之间进行协调。\n第三种矛盾，即同意和效能之间的矛盾。……假如民主不能起作用，人们则可能宁愿选择不经他们同意的统治，他们可能选择不再忍受去做出政治抉择的痛苦。因此，存在一个悖论：民主需要同意。同意需要合法性。合法性需要有效率的运作。但是，效率可能因为同意而被牺牲。\n 常见的七种误解 民主主要是一个政治哲学命题？ 民主的哲学思辨当然非常重要。但是，最近半个世纪以来，民主主要是一个转型问题。离开转型谈民主，意义不是太大。与哲学思辨相比，转型研究更多关注经验世界已经发生什么和正在发生什么，而非“应该”发生什么。\n如今，大众视野里的民主要么是政治哲学意义上的民主，要么是作为发达国家民主典范的英美民主。前者往往把民主理解为一个“应然”的问题，后者容易把民主过分理想化。\n转型是一个单向线性的进程？ 不少人容易把转型理解为一个单向线性的进程，众所周知的转型三部曲是：旧政体的瓦解、新政体的创建和新政体的巩固。顺利完成转型三部曲的最著名案例要算美国。但是，需要提醒的是，美国通常被视为政治发展的特例。\n其他大国——诸如法国、德国、意大利、日本等，从传统政治向现代政治的转型都经历过较为曲折的过程，这些国家至少都经历过一次民主政体的崩溃。\n政体要么民主要么不民主？ 这是政体类型的经典两分法。但在第三波民主化（1974以来）以来的重要现象是出现了大量的“两不像政体”。这种政体既非标准的威权政体，亦非标准的民主政体，而是介于两者之间，但国际学界通常把“两不像政体”视为威权色彩浓厚的政体类型。\n不民主就是因为不民主？ 不少人把民主的文本或宪法简单地视为一套可拆卸的政治装置。一旦一个国家安上这套政治装置，该国就变成民主国家或立宪国家了。但实际上，民主的文本或宪法本身不过是几张纸而已。民主的文本或宪法能否生效，能否运转起来，以及能否运转得好，全赖实际的政治过程，全赖主要政治力量的所作所为，全赖政治家的领导力与选择。所以，民主这套政治装置究竟怎样，不仅取决于这套政治装置本身，更取决于安装和操作这套装置的人。\n民主搞不好是因为民主本身不好？ 民主搞不好的直接问题是不会搞民主。民主要搞好，既涉及一套基于民主文本和宪法条款的制度安排，又涉及政治精英与主要政治力量的信念与行为，还涉及最初的民主实践能否常规化、惯例化与稳定化。\n转型困难国家的一个重大挑战，是此前的旧政体没有给新政体留下多少有利的遗产，反而是留下了很多沉重的包袱。\n民主重在选举竞争与权力制衡而政府效能无关紧要？ 把民主仅仅理解为分权制衡就有失偏颇。实际上，只有政治参与、政治竞争、宪政约束与分权制衡，没有相当的政治权威与政府效能，任何政府是难以为继的，民主政体将无法维系。英国宪法学家白芝浩认为，先要有权威，然后才谈得上限制权威。\n不同国家的民主模式都是相似的？ 经典的政体类型学区分了不同政体类型的差异，但民主政体内部的模式差异却没有受到应有的重视。实际上，不同民主国家制度模式的差异是很大的，这些国家在政府形式、选举制度、政党体制和央地关系上均有不同的制度\n威权主义政体的逻辑 威权主义政体是指一个人或一个小集团的统治，居于统治地位的可能是君主、独裁者、军队或政党等。一般来说，威权政体下缺少正式的政治参与和政治竞争，政府亦非责任制或问责制政府。\n常见的类型是：君主制、军人统治、非军人统治的个人独裁、神权统治\n威权主义政体的特征：\n 政治上的非多元化。在这种政体形式下，政治参与和政治竞争受到严格的限制。 是在经济和社会领域倡导多元化，这是威权政体不同于极权主义政体的地方。威权政体之下通常都存在私人企业部门，允许发展市场经济，部分威权国家还允许开办私人报纸和私人电台。 实行一定的政治控制和政治压制 意识形态控制和政治动员程度总体偏低，这也是威权政体不同于极权政体的一个重要方面。 政治领导权的更迭规则完全不同于民主政体。  威权政体由于缺乏程序合法性，所以更多地依赖于政绩合法性。\n面临的问题：\n 面临着“发展悖论”。一方面，优质威权政体一旦推动发展，更加现代化的经济、教育与观念往往会引发更多的民众抗争，从而构成对原有体制的挑战；另一方面，如果没有发展，劣质威权政体会由于经济停滞、社会不公和治理不善而激起严重的怨愤心理，从而在另一个方向上引发抗争。 国家治理问题：委托代理链条的终端上往往难以实现有效治理。 威权政体的治理挑战还来自于信息问题：最大的风险是所有这些不同层级的政府与部门都可能会封闭和阻塞信息。 威权国家的稳定性很多时候取决于政治领导人这一偶然因素 很多威权政体都不可避免地面临着最终的政治困境和转型问题  极权主义政体的逻辑 极权主义政体是指国家试图“完全”控制国民和社会的一种政治体系。\n卡尔·弗里德里希和兹比格纽·布热津斯基认为，极权主义包括了六个基本特征：一个包罗万象的意识形态；单一政党；有组织的恐怖；传媒垄断；武器垄断；经济管制。\n与传统的威权统治不同，极权主义统治试图让每一个人都卷入政治，并最终能控制公民和社会的一切。这种统治方式既不同于传统的君主专制，又不同于20世纪后来的很多新式独裁。\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap5/","tags":null,"title":"不同的政体：民主、威权与极权"},{"categories":null,"contents":"场效应管  场效应管的结构，基本的名词，三极管的区别，为什么能实现电压控制电流，特性曲线（输出与转移），曲线上的分区，不同类型的管子有什么区别，参数，包括符号有什么不一样（上面/下面，左边/右边），主要参数什么意思（交流参数不做要求） JFET的结构，工作原理，特性曲线 特别清晰：场效应管与三极管的同/异\n 场效应晶体管(FET)是一种电压控制的单极性半导体器件，利用电场效应改变内部导电沟道，实现控制输出电流的目的\n场效应管的分类：\n MOSFET绝缘栅型  增强型  N沟道 P沟道   耗尽型  N沟道 P沟道     JEFT结型  N沟道（耗尽型） P沟道（耗尽型）    耗尽型：场效应管没有加偏置电压时，就有导电沟道存在 增强型：场效应管没有加偏置电压时，没有导电沟道\nMOSFET: 金属-氧化物-半导体场效应管 是利用半导体表面电场效应进行工作，故而又称为表面场效应器件\nN沟道增强型MOSFET 结构 工作原理 $V_{GS}$对沟道的控制作用  $V_{GS}\\leq 0$时，没有导电沟道的产生，d、s间加电压也无电流产生 $0\u0026lt;V_{GS}\u0026lt;V_{TN}$时，产生了电场但是未形成导电沟道(反型层)，此时ds间仍无电流 $V_{GS}\u0026gt;V_{TN}$时，电场作用下产生了导电沟道，ds间加电压后有电流的产生。($V_{GS}$越大，那么导电沟道就越厚) 其中$V_{TN}$代表的是N沟道增强型MOSFET的开启电压 产生沟道过程：使栅极接正，源极接负，形成了从栅极到P型硅片的以二氧化硅为截止的平板电容器，产生了一个垂直于半导体表面的电场，使得P极衬底中的空穴被排斥留下不能移动的受主离子(负离子)，形成耗尽层，同时P型衬底中的少子(电子)被吸引到栅极下的衬底表面，栅源电压达到一定值后，在栅极附近的P型硅表面形成了一个N形薄层,称为反型层，实际上也就形成了感生沟道  $V_{DS}$对沟道的控制作用 当$V_{GS}$一定时(即大于开启电压)，$V_{DS}$电压上升将会导致$I_{D}$增大，从而使得沟道电位梯度上升，靠近漏极d处的电位升高，使电场强度减小，从而使沟道变薄。\n当$V_{DS}$增长到使得$V_{GD}=V_{TN}$的时候，在紧靠漏极处会出现预夹断。\n预夹断之后，若$V_{DS}$继续上升，那么夹断区延长，导致沟道电阻上升，使得$I_D$基本不变\n同时作用 给定一个$V_{GS}$,就有一个不同的$i_D-V_{DS}$曲线\n 沟道中只有一种类型的载流子参与导电，所以场效应管也被称为单极型三极管 MOSFET的栅极绝缘，故而$i_G\\approx 0$,输入电阻很高 MOSFET是电压控制器件，$i_D$受$v_{GS}$控制 只有当$v_{GS}\u0026gt;V_{TN}$时，增强型MOSFET的ds端才能导通 预夹断前$i_D$和$V_{DS}$接近线性关系，预夹断后，趋近饱和  I-V特性曲线  输出特性曲线 $i_D=f(v_{DS})|_{v_{GS}=const}$  截止区 $v_{GS}\u0026lt;V_{T}$  导电沟道未形成,$i_D=0$，为截止工作状态   可变电阻区 $v_{DS}\u0026lt;(v_{GS}-V_{TN})$  $i_D=K_n[2(v_{GS}-V_{TN})v_{DS}-v_{DS}^2]\\approx 2K_n(v_{GS}-V_{TN})v_{DS}$   饱和区(也称放大区) $V_{GS}\u0026gt;V_{TN}$且$v_{DS}\\geq (v_{GS}-V_{TN})$  $i_{D}=K_n(v_{GS}-V_{TN})^2$   必须要让FET工作在饱和区才有放大作用    转移特性 $i_D=f(v_{GS})|_{v_{DS}=const}$\nN沟道耗尽型MOSFET 结构与工作原理 在二氧化硅绝缘层中掺有大量的正离子，已存在导电沟道可以在正或负的栅极电压下工作，而且基本无栅流\n 当$V_{GS}\u0026gt;0$时，沟道中感生出更多的负电荷，使得沟道变宽，在$v_{DS}$作用下，$i_D$有着更大的数值 当其小于0时，沟道中负电荷减少，沟道变窄，从而使得漏极电流减小。当负电压到达某值时，耗尽区扩展到这个沟道，沟道被完全夹断，此时$i_D$不存在，这是的栅源电压称为夹断电压(截止电压)$V_P$  I-V特性曲线 P沟道MOSFET 电路符号和N型的区别在于代表衬底的B的箭头方向\n为能正常工作，PMOS管的$v_{DS}$必须为负值，开启电压$V_T$也是负值，**实际电流方向为流出漏极，但是我们假定流入漏极的电流方向为正**\n沟道调制效应等几种效应  沟道长度调制效应  考虑到$V_{DS}$对于沟道长度L的调制效应，实际上饱和区的曲线并不是平坦的   衬底调制效应(体效应)  衬底没有和源极并联时，衬底与源极之间的偏压$v_{BS}$会影响实际的开启(夹断)电压和转移特性(如对于N沟道增强型而言，$V_{BS}$负的越多，转移曲线右移) 为保证导电沟道和衬底之间的PN结反偏，通常会要求N沟道$V_{BS}\\leq 0$,P沟道$v_{BS}\\geq 0$.通常会让N沟道器件衬底接电路最低电位，P沟道器件衬底接电路最高电位   击穿效应  漏衬击穿  外加的漏源电压过高，将漏极到衬底的PN结击穿   栅极击穿  栅极电压过大 通常在栅源间加入双向稳压管，限制栅极电压保护器件      主要参数  直流参数  增强型参数：开启电压$V_T$ 耗尽型参数：夹断电压$V_p$ 耗尽型参数：饱和漏电流$I_{DSS}$ 直流输入电阻$R_{GS}$   交流参数  输出电压$r_{ds}$,不考虑沟道调制效应时为无限大，实际中一般为几十千欧到几百千欧 低频互导$g_m$   极限参数  最大漏极电流$I_{DM}$ 最大耗散功率$P_{DM}$ 最大漏源电压$V_{(BR)DS}$ 最大栅源电压$V_{(BR)GS}$    JEFT 结构 箭头的方向表示栅极正向偏置时，栅极电流方向从P到N，由此可以区分N沟道和P沟道\n工作原理分析-以N沟道为例 $v_{GS}$对沟道的控制作用 其小于0时，PN结反偏，耗尽层加厚，使得沟道变窄\n但他减小到一定值时，沟道夹断，对应的栅源电压$v_{GS}$称为夹断电压$V_{P}$\nN沟道的JEFT夹断电压小于0\n上述分析表明，改变$v_{GS}$大小，可以有效控制沟道电阻的大小。$|v_{GS}|$增大，沟道电阻增大，$i_D$减小\n$v_{DS}$对沟道的控制作用 考虑$v_{GS}$为0的情况，随着$v_{DS}$的增加，一方面沟道电场强度增加，漏极电流增加，另一方面gd间的PN结方向电压增加，在经过源极到沟道的N型半导体区域中形成了沿沟道的电位梯度，靠近漏层的耗尽层加宽，沟道变窄，从上到下呈楔形分布\n$v_{GD}=V_p$时出现预夹断，此时虽然$v_{GD}$上升，但是夹断区延长导致电阻上升，使得$i_D$基本不变\n共同作用 当$V_p\u0026lt;V_{GS}\u0026lt;0$，导电沟道更容易被夹断，对于同样的$v_{DS}$，$i_D$更小\n预夹断处$v_{GD}=v_{GS}-v_{DS}=V_P$\n综上可知\n JFET栅极与沟道间的PN结是反向偏置的，因此$i_G\\approx 0$，输入电阻很高。 JFET是电压控制电流器件，$i_D$受$v_{GS}$控制。 预夹断前$i_D$与$v_{DS}$呈近似线性关系；预夹断后，$i_D$趋于饱和  为什么JFET的输入电阻比BJT高得多？\n特性曲线与参数 FET和BJT的比较  FET和BJT内部都含有两个PN结，外部都有3个电极。它们有如下的对应关系：  FET BJT 栅极g -- 基极b 源极s -- 发射极e 漏极d -- 集电极c 虽然这两类器件的工作原理不相同，但它们都可以利用两个电极之间的电压控制流过第三个电极的电流来实现输入对输出的控制。  MOS管：栅-源电压$v_{GS}$控制漏极$i_D$ BJT：基-射极间电压$v_{BE}$控制集电极电流$i_C$ 在放大区域内，MOS管的$i_D$与$v_{GS}$之间是平方律关系，而BJT的$i_C$与$v_{BE}$之间是指数关系。显然，指数关系更加敏感，所以通常BJT管的跨导要大于MOS管的跨导。 因MOS管的栅极电流$i_G=0$，而BJT管的基极电流$i_B\\neq 0$，且电压$v_{BE}$首先影响$i_B$（或$i_E$），然后通过$i_B$（或$i_E$）实现对$i_E$的控制，故常将BJT称为电流控制器件，MOS管称为电压控制器件， 以示两者之差别。   MOS管的跨导$g_m$不仅与$V_{GSQ}$和开启（夹断）电压的差值（或$I_{DQ}$）有关，而且还与其沟道的宽长比W/L 有关。而BJT的$g_m$ 仅与$I_{CQ}$有关。 这两类器件的输出电阻$r_o$都等于Early电压$V_A$与静态电流（$I_{DQ}$或$I_{CQ}$）的比值。通常BJT的$V_A$比MOS管的$V_A$大。意味着 BJT的输出电阻$r_o$ 比MOS管的大。 MOS管的$K_n$与BJT的$\\beta$ 或$\\alpha$具有类似的性质，即它们主要取决于管子的固有参数（如，尺寸、参杂浓度、载流子迁移率等），而与它们所在的电路无关。  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1/","tags":null,"title":"场效应管"},{"categories":null,"contents":"Existence problems Existence by counting shannon's circuit lower bound double counting 对同样的东西以不同的方式计数两次，得到的结果相同\nhandshaking lemma Handshaking Lemma: At a party, the number of guests who shake hands an odd number of times is even.\n等价于以下的计数方式：构建一个图，如果两人握手则存在一条连接这两个顶点的边，只需要说明所有的所有的奇数度数的点的度数和是偶数\n只需要说明$\\sum_{v \\in V}d(v)=2|E|$即可(偶-偶=偶)\nsperner's lemma 定义一个proper coloring为顶点a,b,c三点颜色不同，ab,ac,bc边上每边只有两种颜色\nSperner's Lemma (1928)： For any properly colored triangulation, there exists a cell receiving all three colors.\n我们再构建一张图，让每个小三角形对应一个顶点，让大三角形外部对应一个顶点，如果存在相邻顶点之间在原图中存在红-蓝边，那么就连接这两点。这样的话，如果是一个三种颜色都有的三角形对应的顶点度数为1，其余的情况就是2或0，而大三角形的红蓝边与外界的点相连的度数也为奇数，根据握手引理，则必然存在一个三角形三种颜色都有\nThe pigeonhole principle 将超过mn个物品分到n个类中，则必然有一个类中物品大于m\ninevitable divisors 对于一个${1,2,..2n}$的子集S，如果$|S|\u0026gt;n$, 那么S中必然存在两个数可以相互整除\n定义$C_m={2^km|k\\geq 0,, 2^km\\leq 2n}$，这样的话S中的每个数都可以分到一个$C_m$中，而同一个$C_m$中的数可以互相整除，必然有一个$C_m$中存在S中的两个及以上的数\nmonotonic sebsequences (Erdos-Szekeres 1935)A sequence of more than mn different real numbers must contain either an increasing subsequence of length m+1, or a decreasing subsequence of length n+1.\n注意的是：子序列是可以被间隔开的，不同于子串\n假设长度为$N\u0026gt;mn$, 那么可以对原序列中的每个点都可以对应一个二维平面上的点$(x_i,y_i)$,其中前者表示以$a_i$为结束点的最长递增子序列的长度，后者对应递减子序列长度，我们可以证明序列中的两个数必然对应的点不同(把后面的那个点加到前面的点对应的子序列中都会让x或y变化)。故而必然有一个点在${1,2,..m}\\times{1,2,..n}$之外，也就得证\ndirichlet's approximation Let $x$ be an irrational number. For any natural number $n$, there is a rational number ${\\frac {p}{q}}$ such that $1\\leq q\\leq n$ and $\\left|x-{\\frac {p}{q}}\\right|\u0026lt;{\\frac {1}{nq}}$\n将$[0, 1]$划分为n个区间，填入$n+1$个数(${kx},k=1,2,..n+1$)，其中${x}=x-\\lfloor x \\rfloor$对应一个数的小数部分\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/existence-problemms/","tags":null,"title":"Existence Problemms"},{"categories":null,"contents":"网络层：控制平面 5.2 路由选择算法 BGP协议报文使用TCP报文封装，RIP使用UDP，OSPF使用IP报文封装\n路由选择算法的目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径\n路由选择算法的分类：\n 集中式路由选择算法：用完整的全局的网络知识来计算，具有全局状态信息的算法叫做链路状态算法(LS) 分散式路由选择算法：路由器使用迭代、分布式的算法计算出最低开销。如距离向量(DV)算法 静态路由选择算法：路由随时间变化缓慢，通常人工配置 动态路由选择算法 负载敏感算法 负载迟钝算法：目前使用的(RIP,OSPF,BGP)都是负载迟钝的  5.2.1 链路状态路由选择算法 如OSPF算法，这通常由**链路状态广播(link state broadcast)**算法完成，节点广播的结果就是所有节点都有该网络的统一、完整的视图\n一种链路状态路由选择算法是Dijkstra算法\n/* * D(v) 到本次迭代，从源节点到目的节点v的最小距离 * p(v) 源节点到点v的最短路径的前一节点 * N‘ 节点子集，包含了源到其点最短路径已知的所有点 */ Initialization: N’ = {u} for all nodes v if v is a neighbor of u then D(v) = c(u, v) else D(v) = ∞ Loop: find w not in N’ such that D(w) is a minimum add w to N’ update D(v) for each neighbor v of w and not in N’: D(v) = min(D(v), D(w)+ c(w, v) ) /* new cost to v is either old cost to v or known least path cost to w plus cost from w to v */ until N’= N 5.2.2 距离向量路由选择算法 迭代的（一直要持续到邻居之间无更多信息交换为止）、异步的、分布式(每个节点要从一个或者多个直接邻居接收某些信息，执行计算，然后把结果分发给邻居)的算法\n使用的协议有BGP,RIP\nBellman-Ford算法：$d_x(y)=min_v{c(x,v)+d_v(y)}$\n算法思路：每个节点从邻居节点处得到一个距离向量，他保存v的距离向量，然后使用Bellman-Ford方程更新自己的距离向量\n 可能遇到的问题：当DV算法稳定后某条链路开销突然改变，可能出现路由选择环路问题，节点间的最短路径相互依赖，导致结果在节点间不断的来回变换直到最后稳定，称为无穷计数问题 一种尝试解决的方式：增加毒性逆转：如果z通过y路由到达目的地x，那么z告诉y，z到x的距离无穷大。但是涉及三个或以上节点的环路毒性逆转无效  5.3 自治系统内部的路由选择：OSPF 为了解决1)互联网规模大，所有路由器之间更新链路开销的负担是巨大的2)ISP希望按照自己的意愿运行路由器或者对外部隐藏其网络的内部组织面貌，这两个问题可以通过将路由器组织进**自治系统(AS)**解决\n自治系统AS由一组通常处在相同管理控制下的路由器组成，通常在一个ISP中的路由器以及互联他们的链路构成一个AS。一个自治系统由其全局唯一的AS号(ASN)所标识,AS号由ICANN区域注册机构分配\n运行在一个自治系统内的路由选择算法叫做自治系统内部路由选择协议\nOSPF:开放最短路优先，是一种链路状态协议，使用洪泛链路状态信息和Dijkstra最低开销路径算法。\n使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，每当一条链路的状态发生变化后，路由器就广播链路状态信息，即使不改变也要周期性(至少30min一次)的广播一次。\nOSPF的优点：\n 安全：所有的OSPF消息经过身份验证，能够配置简单的和MD5(基于配置在所有路由器上共享秘密密钥，路由器对附加了秘密密钥的OSPF分组计算MD5散列值并包括在OSPF分组中，接收路由器根据预配置的秘密密钥计算MD5散列值与OSPF中携带的比较)的鉴别 存在多条相同开销的路径时，允许使用多条路径 对单播和多播综合支持 支持在单个AS内的层次结构：允许AS内划分区域，有一个主干区域，每个区域运行自己的OSPF，如果要跨区域：区域1-\u0026gt;主干区域-\u0026gt;区域2  5.4 ISP之间的路由选择:BGP 因特网中，所有的AS运行相同的AS间路由选择协议，称为边界网关协议(BGP)\n5.4.1 BGP的作用 在BGP中，分组时路由到CIDR化的前缀，每个前缀表示一个子网或者一个子网的集合，因此一台路由器的转发表将具有(x,I)的表项，其中x为前缀，I时路由器的接口之一的接口号\n BGP提供的手段  从邻居AS获得前缀可达信息。BGP允许每个子网向因特网的其余全部部分通告他的存在 确定到该前缀的最好的路由    5.4.2 通告BGP路由信息 对于每个AS，每台路由器要么是网关路由器，要么就是内部路由器，网关路由器直接连接到其他AS中一台或者多台路由器，内部路由器只连接AS内部路由器或者主机\n每队路由器使用179端口的半永久TCP连接来交换路由选择信息\n 跨越两个AS的BGP连接：外部BGP连接(eBGP) AS内部的BGP连接：内部BGP连接(iBGP)  传递可达信息：不断重复AS内部广播，网关传递到其他AS的过程\n5.4.3 确定最好的路由 路由器通过BGP连接通告前缀时，会在前缀中引入一些BGP属性。前缀及其属性称为路由。两个比较重要的属性是AS-PATH和NEXT-HOP。其中AS-PATH包含了通告已经通过的AS列表，NEXT-HOP是AS-PATH起始的路由器接口的IP地址。\n热土豆路由选择 转发表中增加AS外部目的地的步骤：\n 从AS间协议学到经多个网关可到达子网x 使用AS内部的路由选择信息，决定到达每个网关的最低开销路径的开销 热土豆路由选择：选择具有最低最小开销的网关 从转发表确定通往最低开销的网关接口I，在转发表中加入表项(x,I)  热土豆选择：尽可能快的将分组送出其AS，使得他在AS内部的开销最小\n路由选择算法 如果有多条路径，顺序的按照以下规则消除直到只剩下一条：\n 路由被指派一个本地偏好作为属性值之一，具有最高本地偏好的路由被选择 如果多个具有相同的最高本地偏好，则从这些里面选择具有最短AS-PATH的路由(其中距离测量是AS的跳数) 剩下路由中使用热土豆路由选择方式，即最靠近NEXT-HOP路由器的路由 如果仍然剩下多条路由，则使用BGP标识符来选择路由  5.4.4 IP任播 多台服务器使用相同IP地址进行通告，路由器对于这多个通告，将会认为是到达同一个服务器的不同路径，在用户请求时选择较近的那个服务器\n利用BGP实现，可用于DNS和CDN服务\n5.4.5 路由选择策略 所有进入一个接入ISP网络的流量必然时以该网络为目的地，所有离开一个接入ISP的流量必然源于该网络\n5.6 ICMP:因特网控制报文协议 ICMP：被主机和路由器用来彼此沟通网络层的信息，最典型用途时差错检测\nICMP会被作为IP有效载荷承载的，主机收到指明了上层协议为ICMP的数据报后会分解出内容给ICMP\nICMP报文有一个类型字段和一个编码字段，并且包含了引起该ICMP报文首次生成的IP数据报的首部和前8个字节(方便确定引发差错的数据报)\nping的实现 ping程序发送一个ICMP类型8编码0(对此的表述是回显请求)的报文到指定主机，看到回显(echo)请求，目的主机发回一个类型0编码0的ICMP回显回答\nTraceroute的实现 traceroute：允许跟踪一台主机到另外一台主机之间的路由\n源主机的traceroute向目的地主机发送一系列普通的IP数据报，这些数据报每个携带了一个具有不可达UDP端口号的UDP报文段，第一个数据报的TTL(寿命)为1，第二个为2，以此类推。该源主机为每个数据报启动定时器，第n个数据报到达第n个路由器的时候，第n台路由器观察到这个数据报的TTL刚好过期，按照IP协议规则，路由器丢弃这个数据报并发送一个ICMP警告给源主机(类型11编码0).该警告包含了路由器的名字与他的IP，当该ICMP报文返回源主机的时候，源主机从定时器得到往返时延，从ICMP报文得到第n台路由器的名字和IP地址\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wang-luo-ceng-kong-zhi-ping-mian/","tags":null,"title":"网络层-控制平面"},{"categories":null,"contents":"数据库安全性与完整性  4.1 数据库的安全性保护\n 数据库安全的基本概念与内容：主体，客体，身份标识与鉴别，自主访问控制，审计 SQL对数据库安全的支持  SQL中的存取权限 SQL中的授权命令GRANT和权限的回收命令REVOKE    4.2 数据库的完整性保护\n 数据库完整性保护的功能：目的与常用实现措施 实体完整性，参照完整性，用户定义完整性 完整的CREATE TABLE命令 基表的创建 完整性约束的定义：主关键字，外关键字，CHECK约束，UNIQUE，NOT NULL, DEFAULT 触发器及其创建命令   数据库的保护：在数据库的管理系统内部设置一些必要的软件以达到数据保护的目的\n数据库的安全性保护 数据库的安全要求用户：通过规定的访问途径，按照规定的访问规则\n可信计算基TCB：为实现数据库安全所采用的所有实施策略与机制的集合\n主体：数据库中数据的访问者\n客体：数据库中的数据及其载体\n身份标识与鉴别：每个主题有一个标识符与一个用于验证身份的访问口令，主体访问客体时，TCB将对主体所提交的身份标识符与口令进行鉴别，以防止非法访问\n自主访问控制(DAC)：一种基于存取矩阵的安全控制模型，基于用户的鉴别与存取访问规则的确定。每个用户要给以对系统中每个存取对象的存取权限，一个主体访问客体时，系统检查该主体在该客体上是否拥有所需要的权限。\n对于存取权限，只有两种获取方式，一种是客体所有者自动拥有全部权限，另一种是拥有权限的用户自主的将他的权限传授给其他用户\nDAC将在登录和访问数据库时检查权限\n强制访问控制：主体无权将任何权限授予他人\n审计：跟踪用户对数据的访问操作，如访问时间/访问内容/用户名/终端名/操作类型/操作结果，并可以根据审计结果给出报警信息\n这个安全策略需要一个网络中的实体完成，即访问监控器，在TCB中实现\n安全标准 用户自主保护级：自主访问控制、身份鉴别、数据完整性\n系统审计保护级：自主访问控制、身份鉴别、客体重用、审计、数据完整性\n安全标记保护级：自主访问控制、强制访问控制、标记、身份鉴别、客体重用、审计、数据完整性\n结构化保护级：自主访问控制、强制访问控制、标记、身份鉴别、客体重用、审计、数据完整性、隐蔽信道分析、可信路径\n访问验证保护级：自主访问控制、强制访问控制、标记、身份鉴别、客体重用、审计、数据完整性、隐蔽信道分析、可信路径、可信恢复\nSQL对安全的支持 自主访问控制通过(用户，操作对象，操作权限)这样的三元组来定义用户对数据的访问权限\n授权范围：SELECT权、INSERT权、DELETE权、UPDATE权、REFERENCE权、EXECUTE权、USAGE权\n授权：\nGrant \u0026lt;权限\u0026gt; on 表名[(列名)] to 用户 With grant option GRANT \u0026lt;权限\u0026gt; ON \u0026lt;数据对象\u0026gt; FROM \u0026lt;数据库用户\u0026gt; 回收语句：\nREVOKE \u0026lt;操作权限列表\u0026gt; ON \u0026lt;操作对象\u0026gt; FROM \u0026lt;用户名列表\u0026gt; [RESTRICT | CASCADE] CASCADE：连锁回收\nRESTRICT：在不存在连锁回收问题时才能回收权限，否则拒绝回收\n数据库的完整性保护 完整性包括了正确性(数据有效有意义)与一致性（多用户访问时保证对数据的更新与访问保持一致）\n数据库完整性保护：\n 执行更新操作时，检查是否违反完整性约束条件，防止又存取权的合法用户的误操作 目的：  及时发现错误 采取措施防之错误进一步蔓延 最终将数据库恢复正确状态   常用实现措施  完整性约束条件的定义与检查 触发器 并发控制技术    保护基本功能：设置功能、检查功能、处理功能\n完整性规则的三个内容：\n 实体完整性：基表主关键字不为空 参照完整性：关系R中的每个元组在外键F上的值要么为被引用的关系中存在的值，要么为空值 用户定义完整性：用户定义的数据完整性要求  一条完整性约束规则由三个部分组成：\n 完整性约束条件的设置：  属性级的约束（域约束）：数据类型、非空值约束、取值范围约束 元组级别的约束（表约束）：主键、候选键定义(UNIQUE)、外键定义、基于元组的CHECK子句 全局约束（断言assertion）：单个关系中设计统计操作的约束条件、多个关系之间复杂的约束条件   条件的检查（DBMS内部设置） 条件的处理：如破坏完整性，可能拒绝执行并报警，也可能调用相应的函数处理如外键定义子句中的方法或者触发器中给出的方法  约束的命名：CONSTRAINT \u0026lt;约束名\u0026gt; \u0026lt;完整性约束定义子句\u0026gt;\n完整的CREATE TABLE命令需要定义：\n 模式名\u0026amp;表名 属性的定义  属性名\u0026amp;数据类型 缺省值定义 DEFAULT{default_constant | NULL} 属性的数据约束定义(见下)   表级（元组级）的数据约束定义(见下)  属性的约束定义：\n{ NOT NULL | [ CONSTRAINT constraint_name ] UNIQUE | PRIMARY KEY | CHECK ( search_condition ) | REFERENCES table_name [ ( column_name ) ] [ ON DELETE CASCADE | RESTRICT | SET NULL ] [ ON UPDATE CASCADE | RESTRICT | SET NULL ] } 多个属性取值约束定义（表级约束定义），需要另起一行\n[ CONSTRAINT constraint_name ] { UNIQUE ( colname { , colname ... } ) | PRIMARY KEY ( colname { , colname ... } ) | CHECK ( search_condition ) | FOREIGN KEY ( colname { , colname ... } ) REFERENCES table_name [ ( colname { ,colname... } ) ] [ ON DELETE CASCADE | RESTRICT | SET NULL ] [ ON UPDATE CASCADE|RESTRICT|SET NULL ] } UNIQUE可以取空值\n候选键：UNIQUE + NOT NULL\n对于外键REFERENCES KEY后面会加上取值约束与保证一致性的保证措施\nForengen Key约束：\nFOREIGN KEY ( colname { , colname ... } ) REFERENCES table_name [ ( colname { ,colname... } ) ] [ ON DELETE CASCADE | RESTRICT | SET NULL ] [ ON UPDATE CASCADE | RESTRICT | SET NULL ] } Foreign key ...... References ......:定义主外键的引用关系。当对引用表中的外键进行赋值时，需要检查外键值的正确性。\non delete ...... / on update ......: 当在被引用表中删除元组或修改主键值时，需要维护引用表中外键值的正确性，具体方式如下：\n Cascade：同步做连带删除/更新 Restrict：如果在引用表中存在与被删除或修改的主键相关的元组，则拒绝本次对被引用表的delete/update操作 (缺省的维护模式) Set Null：如果在引用表中存在与被删除或修改的主键相关的元组，则自动地将相关元组上的外键值置为空(NULL)  CHECK:其他任意的属性取值约束\n定义断言 CREATE ASSERTION \u0026lt;name\u0026gt; CHECK( \u0026lt;condition\u0026gt; )\n撤消断言 DROP ASSERTION \u0026lt;assertion-name-list\u0026gt;\n触发器:某个事件的发生导致另外一些事情的发生，以消除前一个事件对数据完整性的影响\n触发器的组成：\n 触发事件(用户定义)：为某个完整性约束条件的否定或者某种数据操纵事件 结果事件(用户定义)：触发发生后，消除影响的程序，通常是一组SQL命令 触发过程：DBMS自动调用并执行  创建命令：\nCREATE TRIGGER trigger_name { BEFORE | AFTER } { INSERT | DELETE | UPDATE [ OF colname { , colname ... } ] } ON table_name [ REFERENCING corr_name_def { , ...... } ] /*给新/之前的命名*/ /*执行事件*/ [ FOR EACH ROW | FOR EACH STATEMENT ] [ WHEN ( search_condition ) ] { statement | BEGIN ATOMIC statement; { statement; ... } END 命名方式：\n{ OLD [ ROW ] [ AS ] old_row_corr_name | NEW [ ROW ] [ AS ] new_row_corr_name | OLD TABLE [ AS ] old_table_corr_name | NEW TABLE [ AS ] new_table_corr_name } 删除触发器： DROP TRIGGER trigger_name\n举例：\n/*删除一个客户元组时，需要将该客户所有订单上的cid置为空值(set null)*/ create trigger foreign_cid after delete on customers referencing old as old_custom for each row begin update orders set cid = null where cid = :old_custom.cid ; end; ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/security-and-integrity/","tags":null,"title":"数据库安全性与完整性"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 5\n 蒙特卡洛方法不需要环境的信息，只需要经验（experience—sample sequences of states, actions, and rewards from actual or simulated interaction with an environment.）\nMonte Carlo methods are ways of solving the reinforcement learning problem based on averaging sample returns. To ensure that well-defined returns are available, here we define Monte Carlo methods only for episodic tasks.\n5.1 Monte Carlo Prediction 有两种方法，一种是“first-visit“,把整个片段集所有第一次访问到状态时的returns做平均化处理，来估计$v_\\pi(s)$的值另一种是”**every visit**”，把整个片段集中所有访问到s状态时的returns取平均，来估计$v_\\pi(s)$的值。两种方法都有应用，下给出first-visit，在9和12章介绍every-visit\n每一次返回平均值都是其本身的无偏估计，标准偏差在$\\sqrt{\\frac{1}{n}}$内\n蒙特卡洛算法每一次运行都是独立的，也就是说他不是\u0026quot;bootstrap\u0026quot;的\n5.2 Monte Carlo Estimation of Action Values 如何估计$q_\\pi(s,a)$, 同上一小节一样也是first-visit与every-visit两种方式\n不过有一个问题在于如何保证所有的action都被考虑到，这就是之前第二章提到的如何保持exploit和explore的关系的问题，称为“maintaining exloration“问题，一种解决方式是对于每一个state–action pair，都给予其一定的概率作为一个episode的起点，这样当取样次数趋于无限的时候，每一个pair的取样次数也趋于无限了，这种方式的假设称为exploring starts. 但是这样有一个问题就是\u0026quot;it cannot be relied upon in general, particularly when learning directly from actual interaction with an environment.\u0026quot;, 此时一种常见的策略是调整policy，使得对于一个状态，所有的action都有一定的概率发生\n5.3 Monte Carlo Control 蒙特卡洛方法估计最优policies的方法和DP差不多：先迭代value function使之逼近当前policy的真实value function，然后基于更新后的value function进行policy improvement，直到最终policy基本不再变化\n由于我们在此处估计的是$q_\\pi(s,a)$，就不需要额外的model来确定最优的action了，可以直接根据$\\pi(s)=\\arg \\max_a q(s, a)$来确定\n为了更具备实际意义，我们要考虑如何去掉infinte number of episodes 的假设 ，一种方式是设立一个极小值，当两次policy evaluation的差别小于这个值的时候，认为此次policy evaluation结束，这种方式在小规模情况下很好，但是数据规模较大时仍然会需要比较多次。另一种方式就是放弃完整的policy evaluation，类似于4.6中的value iteration\n以下算法仍然基于了exploring starts 假设\n5.4 Monte Carlo Control without Exploring Starts on-policy: 直接优化或评价目标策略\n对于on-policy策略而言，对于所有的pair有$\\pi(a|s) \\ge \\frac{\\varepsilon}{|\\mathcal A(s)|}$\n采取第二章中提到的类似的方法，以$p= 1- \\varepsilon + \\frac{\\varepsilon}{|\\mathcal A(s)|}$的概率选取原先确定的action\n此处省略一大段，如果有兴趣看相关证明的可以自己看书\n5.5 Off-policy Prediction via Importance Sampling 在on-policy中，由于我们需要explore所有的action，这也就导致我们在一些时候会选择非最优的情况，故而我们有了off-policy的想法\noff-policy: 有两个策略，一个叫行为策略 $b$（behavior policy），另一个叫做目标策略$\\pi$（target policy），从behavior policy生成的episodes中学习target policy的过程，叫做off-policy learning。\n 关于off-policy与on-policy的应用比较\nThroughout the rest of this book we consider both on-policy and off-policy methods. On-policy methods are generally simpler and are considered first. Off-policy methods require additional concepts and notation, and because the data is due to a di↵erent policy, off-policy methods are often of greater variance and are slower to converge. On the other hand, off-policy methods are more powerful and general.They include on-policy methods as the special case in which the target and behavior policies are the same. Off-policy methods also have a variety of additional uses in applications. For example, they can often be applied to learn from data generated by a conventional non-learning controller, or from a human expert. Off-policy learning is also seen by some as key to learning multi-step predictive models of the world’s dynamics\n 下面又是一大波我不想看的数学知识\nTODO()以后一定补\n因此有两种方式，可以取：\n一种是取平均（ordinary importance sampling）\n$$V(s) = \\frac{\\sum_{t \\in \\mathcal T(s)} \\rho_t G_t}{|\\mathcal T(s)|}$$\n另一种是加权平均（weighted average）\n$$V(s) = \\frac{\\sum_{t \\in \\mathcal T(s)} \\rho_t G_t}{\\sum_{t \\in \\mathcal T(s)} \\rho_t}$$\n5.6 Incremental Implementation 5.7 Off-policy Monte Carlo Control ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl5/","tags":null,"title":"Monte Carlo Methods"},{"categories":null,"contents":" 简而言之，如果国家的基础条件同时存在有利与不利的情况，一个好的宪法设计就会有利于民主制度的生存；反之，一个坏的宪法设计可能导致民主制度的崩溃。——罗伯特·达尔\n 如何理解政府机构 一个国家政治生活的重要方面就是政府机构的设置，政府机构设置还对应着一整套政治制度的安排。一国政府机构设置的不同意味着该国政治制度安排的不同。\n从概念上说，政府是制定和实施公共决策与政策的机构，政府履行着国家的基本职能。\n政府正是由很多不同类型和层级的政府机构组成的。从政府机构类型来说，可以从两个维度进行分类：一个是职能维度，一个是层级维度。\n从职能维度来说，政府机构主要有三类：行政机构、立法机构和司法机构\n行政机构是政府的核心。对行政机构来说，除了个别国家的最高行政长官职位实行委员会制度以外，绝大多数国家都拥有单一最高行政长官。\n另一个方面是政府机构不同层级的划分。\n政治系统和官僚系统的比较 ","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap6/","tags":null,"title":"政府结构和政治制度"},{"categories":null,"contents":" 认识基本的共源极，知道工作原理就行了，公式不会要求记忆 图解法求静态工作点，工作的时候是怎么移动的，失真对于图像的影响\n 场效应管放大电路 基本共源极电路的组成 如何让MOS管工作在饱和区：\n $V_{GG}$提供栅源电压使得$V_{GS}\u0026gt;V_{TN}$ $V_{DD}$和$R_{D}$提供合适的漏源电压使得$V_{DS}\u0026gt;v_{GS}-V_{TN}$ 同时$R_d$还有将电流转化为电压的作用 通常称$V_{GG}、V_{DD}$为工作电源，$v_I$为信号  信号的传递：\n $v_i\\to \\Delta v_{GS} \\to \\Delta i_{D} \\to \\Delta v_{DS}(=v_O)$ 因为在饱和区的$i_D=K_n(v_{GS}-V_{TN})^2$,所以可以根据MOS的控制关系得到上面的式子 信号由栅源回路输入，漏源回路输出，所以源极时公共端，，所以称为共源回路  基本共源极放大电路工作原理 放大电路的静态和动态 静态：输入信号为0时的工作状态，也叫直流工作状态\n静态工作点$Q(I_{DQ},V_{GSQ},V_{DSQ})$\n输入信号不为0时，放大电路的工作状态称为交流工作状态\n放大电路的直流通路和交流通路 仅有直流电流流经的叫做直流通路\n直流电流电压源的内阻为0，交流电流流经直流电压源时不产生任何交流压降，所以直流电压源对于交流相当于短路\n放大电路的静态工作点估算 先假设工作在饱和区，利用FET特性方程求解后，需要检验是否满足$V_{DSQ}\u0026gt;V_{GSQ}-V_{TN}\u0026gt;0$，不满足则说明工作在可变电阻区或者截止区\n这是增强型NMOS管的计算方法，其他管型的静态工作点方法需要归纳\n放大电路的动态工作情况 放大电路的习惯画法 省略工作电源的直流电压符号，仅保留电压源非接地端子，并标注电压源名称\n图解法确定静态工作点 利用直线方程$V_{DS}=V_{DD}-i_DR_d$,$v_{GS}=V_{GG}$\n动态工作情况的图解分析 正常工作情况 由于$v_{GS}=V_{GSQ}+v_i$\n我们可以得到以下结论：\n $v_i$上升，则$v_{GS}$增加，则$i_D$增加，故而导致$V_{DS}$下降，故而当$v_i$正半周时$|v_{ds}(v_o)|$上升 $v_{ds}$和$v_i$的相位相反 可以测量出放大电路的电压放大倍数 可以确定最大不失真输出幅度  静态工作点对于波形失真的影响 截止失真(NMOS)\n饱和失真(NMOS)\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/","tags":null,"title":"场效应管放大电路"},{"categories":null,"contents":"The probabilistic method The probabilistic method  性质1：需要证明某种东西存在，我们可以证明如果一个东西随机的选择出来的概率是正数，那么这个东西必然存在 性质2：任何一个随机变量都必然存在一个值不小于他的期望，必然存在一个值不大于他的期望  求解方式：\n 设计事件  边的方向以 $1/2$ 的概率随机点/边 以$p$为概率被选入集合中（此后求解使期望最小/大的p值）   求解概率  直接计算概率，可能会用到$(1-p)^x = e^{-px}$ 利用$E \\left[ \\sum\\limits_{i=1}^n a_i X_i \\right] = \\sum\\limits_{i=1}^n a_i \\cdot E[X_i]$求随机变量的期望(利用性质2求解至少有的问题)    Ramsey number $K_n$: n个顶点的完全图\nmonochromatic graph: 所有边的颜色相同\nRamsey number $R(k,\\ell )$ is the smallest integer $n$ such that in any two-coloring of the edges of a complete graph on $n$ vertices $K_n$ by red and blue, either there is a red $K_k$ or there is a blue $ K_{\\ell }$.\n对$R(k,k)$给出下界：如果${n \\choose k}\\cdot 2^{1-{k \\choose 2}}\u0026lt;1$，那么则不存在一个单色的$K_k$: 采用抛硬币的方式对边随机染色，那么可以求出存在一个选择使得$K_k$单色的概率小于1，那么可以证明存在一个概率大于0的选择使得任意的$K_k$都不单色\n证明过程中使用了union-bound（至少一个事件发生的概率小于等于所有事件概率和）： $$\\mathbb{P}\\left(\\bigcup_i A_i\\right)\\leq \\sum_i\\mathbb P(A_i)$$\nTournament Linearity of expectation Independent sets Coloring large-grith graphs Lovasz Local Lemma Lovász Local Lemma (symmetric case)： Let $ A_{1},A_{2},\\ldots ,A_{n}$ be a set of events, and assume that the following hold:\n for all $ 1\\leq i\\leq n$, $ \\Pr[A_{i}]\\leq p $; the maximum degree of the dependency graph for the events $ A_{1},A_{2},\\ldots ,A_{n} $ is $ d $, and $ ep(d+1)\\leq 1 $.  Then $ \\Pr \\left[\\bigwedge {i=1}^{n}{\\overline {A{i}}}\\right]\u0026gt;0 $\nrevisit:Ramsey number 可以利用 Lovasz Local Lemma 证明$R(k,k)\\geq Ck2^{k/2}$对于一些常数$C\u0026gt;0$\n定义$A_S$ 为坏事件：一个点集S构成了一个单色的$K_k$,这个坏事件和其他的坏事件的不独立当且仅当他们相交的点超过了两个。所以最大度为$\\binom{k}{2}\\binom{n}{k-2}$\n然后说明所有坏事件都不成立的情况，即在n取到某值的时候，概率大于0，所以存在不存在单色$K_k$的情况，所以$R(k,k)$必然大于这个n\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/probablistic-methods/","tags":null,"title":"Probablistic Methods"},{"categories":null,"contents":"链路层与局域网 两种链路层信道：\n 广播信道：连接有线局域网、卫星网和混合光纤同轴电缆(HFC)接入网中的多台主机，因为许多主机与相同广播信道连接，所以需要媒体访问协议来协调帧传输 点对点通信链路：长距离链路连接的两台路由器、办公室计算机与他们连接到邻近的以太网交换机之间。点到点协议(Point-to-Point Protocol,PPP)  6.1概述 为方便讨论，本章将所有运行链路层协议的任何设备均称为节点(node)(包括主机、路由器、交换机和WIFI接入点)\n将沿着通信路径连接相邻节点的通信信道称为链路(link)\n6.1.1链路层提供的服务 可能包括：\n 成帧：帧由一个数据字段和若干首部字段组成 链路接入：**媒体访问控制(Medium Access Control, MAC)**协议规定了帧在链路上的接入规则，对于点对点；链路，MAC协议比较简单(或者不存在)，当多个节点共享单个广播链路时，即多路访问问题，在这里MAC协议用于协调多个节点的帧传输。 可靠交付：保证无差错的经链路层移动每个网络层数据报，目的在于纠正一个差错而不是通过运输层或应用层协议来迫使重传。但是对于一些低比特差错的链路，如光纤、同轴电缆和很多双绞铜线链路，链路层的可靠交付有时被视为不必要的，所以很多有限的链路层协议不提供可靠交付服务 差错检测和纠正：由于信号衰减和电磁噪声导致差错。许多链路层协议会让发送节点在帧中包括差错检测比特，让接收节点进行差错检查。  6.1.2链路层实现位置 链路层主体部分是在网络适配器(network adapter)中实现的，也被称为网络接口卡(Network Interface Card,NIC), 网络适配器的核心是链路层控制器，控制器通常是一个实现了许多链路层服务的专用芯片。\n之前很多网络适配器是物理上分离的卡，但现在越来越多的网络适配器被综合进入主机的主板，即所谓的局域网在主板配置\n尽管大部分链路层是在硬件中实现的，但部分链路层是在运行于主机CPU上的软件中实现的。链路层中的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。接收端的链路层软件响应控制器中断、处理差错条件和将数据报向上传递给网络层。\n链路层是协议栈上硬件与软件交接的地方\n6.2 差错检测和纠正技术 我们使用**差错检测和纠正比特(Error-Detection and-Correction, EDC)**来增强数据D.(D包括了链路层首部信息和数据报)。我们发送D和EDC，根据接收到的D'和EDC'来判断D'是否与D一致\n我们现在研究在传输数据中检测差错的三种方法：\n 奇偶校验（描述差错检测和纠正背后隐藏的基本思想） 检验和方法（通常更多的运用于运输层） 循环冗余检测（更多的应用在适配器中的链路层）  6.2.1奇偶校验 单个奇偶校验位(假设数据有d个比特)：\n 偶校验：附加一个比特使得d+1个比特中1的数量总是偶数 奇校验：附加一个比特使得d+1个比特中1的数量总是奇数  但是测量已经表明了差错经常以突发形势聚集在一起，而不是独立发生。\n考虑更一般的二维奇偶校验(two-dimensional parity):将d个比特划分为$i$ 行$j$ 列，然后对每行每列都计算奇偶值，产生的$i+j+1$ 个奇偶比特构成了链路层帧的差错检测比特。这种方式可以检测和纠正单个比特的差错，可以检测(但不能纠正)两个比特差错的组合。\n接收方检测和纠正差错的能力叫做前向纠错(Forward Error Correction, FEC)\n6.2.2 检验和方法 将d比特数据看成一个k比特整数处理，一个简单的检验和方法就是将这k比特数加起来，将和作为差错检测比特\n因特网检验和方法基于这种方法，将数据的字节作为16比特的整数等待并求和，这个和的反码形成了携带在报文段首部的因特网检验和。接收方对接收到的数据（包括检验和）的和取反码，并检测结果是否为全1，如果有一个比特为0，就可以检验出差错(在书的3.3节讨论)\n为什么运输层使用检验和而链路层采用CRC呢：因为运输层通常在主机中作为用户操作系统的一部分用软件实现，采用简单而快速的方法是必要的，而链路层的差错检测在适配器中用专用的硬件实现，能快速执行更复杂的CRC操作\n6.2.3 循环冗余检测 循环冗余检测(Cyclic Redundancy Check, CRC)编码 也被称为多项式编码(polynomial code),\n在这种方法中，考虑d比特的数据$D$，发送节点要把它发送给接收节点，两者首先要协商好一个$r+1$ 比特模式，称为生成多项式(generator), 我们将其表示为$G$, 我们要求G的最高有效位必须为1。对于一个给定的数据段$D$, 发送方要选择$r$ 个附加比特$R$，并将它附加到D上，使得得到的$d+r$比特模式使用模2算术恰好能被G整除\n对于模2运算，加法不进位，减法不借位，即加法与减法是相同的，都可以用XOR异或操作代替，即\n​ $D\\cdot 2^r$ XOR $R = nG $\n而同时两边用R异或，可以得到 $D\\cdot 2^r = nG$ XOR $R$，即$R = reminder\\frac{D\\cdot 2^r}{G}$\n6.3 多路访问链路和协议 **广播链路(broadcast link)**能够使得多个发送和接收节点到连接到相同的、单一的、共享的广播信道上，使用“广播” 是因为任何一个节点在传输一个帧的时候，信道广播该帧，每个其他一个节点都会收到一个副本。\n节点通过多路访问协议来规范他们在共享的广播信道上的传输行为\n如果多个节点同时传输帧，那么也就是说传输的帧在所有的接收方处碰撞(collide),所有涉及到此次碰撞的帧全部都损失了\n目前的任何多路访问协议都可以划分为三种类型：信道划分协议、随机接入协议和轮流协议\n对于一个速率位R bps的广播信道，理想的多路访问协议应该具备以下特性\n 当只有一个节点时，该节点有R bps的吞吐量 有M个节点发送数据时，每个节点在一些适当定义的时间内有R/M的平均传输速率 协议是分散的，不会因为某主节点故障而使得整个系统崩溃 协议是简单的，实现不昂贵  6.3.1信道划分协议 TDM: 将时间划分为时间帧，并进一步将每个帧划分为N个时隙，通常选择的时隙长度要能使一个时隙内能传输单个分组，能避免碰撞且非常公平，缺陷是节点被限制为R/N bps的平均传输速率，节点必须总是等待他在传输序列中的轮次，即使只有他一个节点\nFDM：将R bps信道划分为不同的频段，每个频段具有R/N的带宽，并将每个频率分配给N个节点中的一个，缺点和TDM一样，限制一个节点只能使用R/N的带宽。\n码分多址(Code Division Multiple Access, CDMA): 对每个节点分配一种编码，然后每个节点用他唯一的编码对他发送的数据进行编码。如果进行选择这些编码，CDMA将可以使得不同节点能够同时传输，并且他们各自的相应的接收方仍能正确接收。(假设接收方能够直到发送方的编码)\n6.3.2 随机接入协议 在随机接入协议中，涉及碰撞的每一个节点重发他的帧（也就是分组），直到帧无障碍的通过为止，但是他在重发该帧之前会等待一个随机时延。每个节点独立选择随机时延。我们在本块描述一些最常用的随机接入协议\n时隙ALOHA 做如下假设：\n 所有帧都是L比特 将时间划分为长度为L/R的时隙(也就是说一个时隙等于传输一帧的时间)， 节点值在时隙起点开始传输帧 时间是同步的，每个节点都知道时隙何时开始。 如果在一个时隙中发生碰撞，则所有节点在该时隙结束前检测到该事件  令$p$是一个概率，操作如下：\n 在每个节点中，当节点有一个新帧要发送时，他等到下一个时隙开始并在该时隙传输整个帧 如果没有碰撞则成功传输（此时如果又新帧，他能够为传输准备一个新帧） 如果有碰撞，节点能够在时隙结束前检测到碰撞，该节点在后续的每一个时隙中都以概率p的可能性去重传这个帧直到其传输成功。  除了发生碰撞的帧之外，还有可能会有某个时隙是空闲的，只有刚好有一个节点传输的时隙叫做成功时隙，时隙多路访问协议的效率 定义为：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额。\n可以分析得到这个协议的最大效率是0.37。\nALOHA 时隙ALOHA要求所有节点同步他们的传输，而单纯的ALOHA是非时隙的\n当第一帧到达时立刻开始传输，如果碰撞，立刻以p的概率重传，否则等待一个帧的传输时间，再次以p的概率重传直到传输成功。\n纯aloha协议只有时隙的效率的一半\n载波侦听多路访问：CSMA 载波侦听(carrier sensing)：一个节点在传输前先听信道，如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间(96比特时间)没有传输，然后开始传输\n之所以侦听了还有可能碰撞的原因是端到端的信道传播时延,如B开始传输后但是还没到达D之前，D认为信道空闲开始传输\n具有碰撞检测的载波侦听多路访问：CSMA/CD 碰撞检测(collision detection)：当一个传输节点在传输时一直监听此信道，如果他检测到另一个节点正在传输干扰帧，就停止运输，在重复“侦听-当空闲时传输”循环前等待一段随机时间。\n检测到碰撞后会发送Jam信号来强化碰撞让其余点也知道\nCSMA/CD工作流程：\n 适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中 如果适配器检测到信道空闲，他开始传输帧。(传输前等待96比特时间，即最小帧间隔)另一方面，如果侦听到信道正在忙，就等待直到侦听到没有信号能量 传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量存在 如果传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了传输，否则就停止传输 中止传输后，等待一个随机时间量  关于等待的随机时间确定，用于以太网和DOCSIS电缆网络多路访问协议中的二进制指数后退算法解决了这个问题，当传输一个帧发生了n次碰撞后，下一次的时间间隔K从${0,1,2,3,\\cdots, 2^n-1}$中等概率选取。此处选取的K代表的延迟时间为发送K*512比特所需要的时间。n最大为10，达到10后6次保持10不变，16次均失败后放弃重传\nCSMA/CD效率：当有大量的活跃节点，且每个节点有大量的帧要发送时，帧在信道中无碰撞地运输那部分时间在长期运行时间中所占的份额。近似式$$\\frac{1}{1+5d_{prop}/d_{trans}}$$\n最小帧长：检测冲突的时长不超过端到端时延的两倍，取这一值为最小帧长\n6.3.3 轮流协议 前面的ALOHA协议和CSMA协议具备了理想协议的第一个特性，但是不具备第二个特性(有M个节点发送数据时，每个节点在一些适当定义的时间内有R/M的平均传输速率). 轮流协议就是为满足这个协议而创造的。\n轮流协议有很多种，此处讨论两种。\n轮询协议(polling protocol)：节点之一被指定为主节点，主节点以循环的方式轮询每个节点，先向节点1发送报文告诉他节点1最多能传输的帧的数量，节点1传输了某些帧后，再告诉节点2。(主节点通过观察信道上是都缺乏信号来决定一个节点何时完成了传送)。 缺点是引入了轮询时延，因为即使只有一个活跃节点也要轮询每一个非活跃的节点，第二个缺点是主节点如果有故障，整个信道都将不可操作\n轮询协议的典型例子是802.15协议和蓝牙协议\n令牌传递协议：用一个称为**令牌(token)**的小的特殊帧再节点之间以某种固定的次序进行交换，一个节点收到令牌时，只有其需要发送一些帧的时候才持有该令牌，否则其立即向下一个节点转发该令牌，如果其有帧要传输，则发送最大数目的帧数，然后向下一个节点转发。其缺点是一个节点的故障可能导致整个信道崩溃或者一个节点偶然忘记了释放令牌，这些必须调用某些恢复步骤使令牌返回到循环中来。\n6.3.4 DOCSIS：用于电缆因特网接入的链路层协议 一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个**电缆调制解调器端接系统(CMTS)**连接，**数据经电缆服务接口（Data-Over-Cable Service Interface, DOCSIS）**规范定义了电缆数据网络体系结构及其协议。\nDOCSIS使用FDM将下行(CMTS到调制解调器)和上行网络段划分为多个频率信道。\n此处略去n字\n6.4 交换局域网 6.4.1 链路层寻址和ARP ARP：从IP地址到链路层地址的地址解析协议\nMAC地址 事实上，并不是主机或者路由器具有链路层地址，而是他们的适配器（网络接口）具有链路层地址。\n但是链路层交换机并不具有与他们接口相关联的链路层地址。因为链路层交换机的任务是在主机和路由器之间承载数据报，交换机透明的执行该任务 。\n链路层地址有各种不同的称呼：LAN地址，物理地址，MAC地址，这三者表示同一个东西\n对于大多数局域网而言，MAC地址长度为6字节，每一块适配器的MAC地址都是不同的，且一个适配器的MAC地址都不会变化。MAC地址使用十六进制表示，每个字节表示为一对十六进制数，如5C-66-AB-90-75-B1这种表示方式\n发送适配器会将目的适配器的MAC地址插入到帧中，并将该帧发送到局域网中，一台交换机偶尔将这个帧广播到所有接口，适配器接收到一个帧的时候，检验该帧中的MAC地址是否与自己的匹配，若匹配则提取出封装的数据并沿着协议栈向上传递，否则就丢弃。\n如果需要使得局域网内所有适配器都接收到一个帧的信息，则插入一个特殊的MAC广播地址，对于使用6字节的局域网(如以太网和802.11)来说，广播地址是48个1组成的字符串(FF-FF-FF-FF)\n地址解析协议 地址解析协议：将网络层地址转化为链路层地址\n每台主机或者路由器的内存中都有一个ARP表中，取在相同局域网内的任意IP地址作为输入，可以返回相应的MAC地址。同时这个表中包含了一个寿命值，指示了表中删除每个映射的时间，一个表项通常的过期时间是20分钟。\nARP只为在同一个子网内的主机和路由器接口解析IP地址\n如果发送主机的ARP表中没有目的主机的表项，则发送方用ARP协议来解析这个地址，构造一个称为**ARP分组(ARP packet)**的特殊分组，包括了发送和接收IP地址以及MAC地址，ARP的查询分组和响应分组有着相同的格式，构造完成后，适配器用广播地址来发送这个分组，并传入子网中，而包含该ARP查询的帧能被子网上所有适配器接收到，每个适配器将该ARP分组向上传递给ARP模块，这些ARP模块检查其IP地址是否与ARP分组中的目的IP地址一致，与之匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组。然后查询主机更新其ARP表并发送其IP数据报。\n发送数据到子网之外 路由器的每个接口都有一个IP和适配器(MAC地址)。\n考虑一个连接了两个子网的路由器，发送主机通过ARP找到路由器的MAC地址并向其转发（转发的帧中包括了其他子网的目标IP）,路由器看到这个是向其寻址后传递给路由器的网络层，网络层通过查询路由器中的转发表得到器通过哪个接口转发，路由器通过ARP获取了另一个子网的目标主机的MAC地址，通过接口向这个适配器传递\n6.4.2 以太网 以太网：有线局域网\n在20世纪90年代后期，大多数公司和大学使用一种基于**集线器(hub)**的星形拓扑以太网安装，集线器是一种物理层设备，他作用于比特而不是帧，当一个比特到达一个接口时，集线器重新生成一个能量更大的相同的比特，并向所有其他接口传输出去。这是可能发生碰撞的。\n在21实际，以太网继续使用星形拓扑，但是将集线器换成了交换机(switch), 交换机是无碰撞的，并且是名副其实的存储转发分组交换机。\n以太网的帧结构  前同步码 目的地址 源地址 类型 数据 CRC\n 数据字段（46-1500字节）：承载了IP数据，以太网的最大传输单位（MTU）是1500字节，这意味着如果IP数据报超过了1500字节则需要分片，数据字段最小为46字节，如果少于46字节则需要填充至46字节，网络层接收到数据报后可以根据IP数据报首部的长度字段来去除填充部分。(最小帧长的确定：端到端时延的两倍)\n目的地址 (6字节)： 包含了目的适配器的MAC地址\n源地址(6字节)： 传输该帧到局域网上的适配器MAC地址\n类型字段(2字节)：类型字段允许以太网复用多种网络层协议，当以太网帧到达适配器B后，B需要知道其将数据字段内容传递给哪个网络层协议。\nCRC（4字节）：循环冗余检测\n前同步码(8字节)： 前7字节为10101010，最后一个字节为10101011，其前七个字节的作用在于唤醒接收适配器，并它们的时钟和发送方的始终同步，前同步码的第八个字节最后两个比特用来警告适配器“重要的内容来了”。\n以太网向网络层提供不可靠技术，即适配器B收到A的帧后，不会告诉A是否通过了CRC校验，如果没有通过校验则直接丢弃该帧，如果应用使用了UDP协议，则可以看到数据中的间隙，如果使用TCP协议，那么TCP将不会确认包含在这个数据帧中的数据，从而引起A中的TCP协议进行重传。\n以太网技术  命名：[速率]BASE[速率或者介质] BASE: 基带以太网 T：双绞铜线  现代的交换机可以协调运输，在任何时刻都不会向相同接口转发超过一个帧，此外现代交换机都是双全工的，即一台交换机可以和一个节点同时向对方发送帧而不会产生干扰，因此基于交换机的以太局域网中，不会有碰撞，已经没有必要使用MAC协议了\n6.4.3 链路层交换机 交换机的任务是接收入链路层帧并把他们转发到出链路。\n交换机转发和过滤 过滤(filtering)：决定一个帧应该转发到某个接口还是应当将其丢弃\n转发(forwarding): 决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。\n交换机的过滤和转发借助于**交换机表(switch table)**完成，交换机表中的一个表项包括：一个MAC地址、通往该MAC地址的交换机接口、表项放置在表中的时间。\n假设目的地址为DD-DD-DD-DD-DD-DD的帧从接口x到达，\n 如果表中没有DD-DD-..的表项，交换机向除了接口x之外的所有接口前面的输出缓存转发该帧的副本，换而言之，如果没有对于目的地址的表项，交换机广播该帧。 如果有DD-DD-..的表项，且接口为x，则直接采用丢弃该帧执行过滤功能即可 如果有DD-DD-..的表项，且接口不是x，则交换机将该帧翻到对应接口前面的输出缓存完成转发功能  自学习 交换机是自学习的，交换机表初始为空，对于在每个接口接收到的每个入帧，该交换机在其表中存储该帧源地址对应的MAC地址以及到达的接口，并记录当前时间。如果在一段时间(老化期 )中，交换机没有接收到以该地址为源地址的帧，就在表中删除该地址。\n交换机是即插即用设备，因为他们不需要网络管理员和用户的干预\n链路层交换机的性质 消除碰撞：交换机缓存帧且绝不会再网段上同时传输超过一个帧，其最大聚合带宽是该交换机所有接口速率之和\n异质的链路：交换机将链路彼此隔离，使其能以不同速率在不同媒体上运行\n管理： 易于进行网络管理\n交换机与路由器的区别 交换机是第二层的，路由器是第三层的\n补充：网桥 功能: 读取A网(总线)的所有帧, 在B(总线)上重发每个帧; B-\u0026gt;A同理\n特点: 不更改帧, 原样转发; 带缓存; 路由寻址能力(基于MAC, 只转发需要转发的帧)\n协议体系层次: 数据链路层 - MAC层\n链接模式：\n 局域网 - 网桥 - 局域网, 原样转发 局域网 - 网桥 - [网络或链路] - 网桥 - 局域网, 需要适当封装, 但原始MAC帧不修改  固定路由选择：每对点均有一条选定的路由, 跳数最少, 仅在拓扑变化时改变(生成树算法)\n帧转发：x收到帧，检查目的地址: 若在某一端口的列表中, 且非阻塞, 发送; 不在任何列表, 则x除以外的端口全部转发\n地址探索: 同交换机，收到帧, 则帧源地址MAC与此端口关联, 加入此端口数据库，数据库项带计时器, 超时删除\n最小生成树算法(Prim): 选取起始点(根网桥), 加入集合S,对于S中所有点(网桥), 在他们所有邻居里面找离S中点最短的距离, 把这个邻居加入S, 这条边(网桥间的最短距离)加入生成树,直到所有点都加入S, 边集合构成生成树\n网桥阻塞规则:\n 选择根网桥: ID最小的网桥 为每个网桥选择root port: 到根网桥最低开销的端口 为每个LAN指定网桥: 拥有到根网桥最低开销路径的, 与这个LAN相连的网桥 Designated port: 这个指定网桥与这个LAN相连的端口 Designated port 和 root port 不阻塞, 别的都阻塞   to be add\n ","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/lian-lu-ceng-yu-ju-yu-wang/","tags":null,"title":"链路层与局域网"},{"categories":null,"contents":"事务管理、并发与故障处理  5.1 事务处理（概念）\n  事务的定义与ACID性质\n  事务活动及其状态转换图\n  事务控制及相关的参数设置语句：事务的提交与回滚，事务的读/写类型与隔离级别\n  事务的语句组成成分\n5.2 并发控制技术（概念）\n  事务\n 事务的并发性，并发控制 调度，串行调度，可串行化调度，冲突与冲突可串行化，视图可串行化 冲突可串行化的判定方法 不正确的事务并发所导致的数据不一致现象：丢失修改lost-update，脏读dirty-read，不可重复读unrepeatable-read    封锁\n 共享锁（S锁），排它锁（X锁），锁相容矩阵，锁申请/锁释放算法 基于封锁技术的并发控制实现方法  三级封锁协议，三级封锁协议与数据不一致现象之间的关系 两阶段封锁协议 两阶段封锁协议与冲突可串行化的关系      多粒度封锁\n 封锁粒度/并发度/并发控制实现开销 之间的关系 多粒度树，多粒度封锁 基于意向锁的多粒度封锁协议  意向锁：IS, IX, SIX 意向锁锁相容矩阵：S，X，IS, IX, SIX 意向锁锁申请算法，意向锁锁释放算法      死锁的检测与预防\n 死锁 \u0026amp; 活锁 死锁的检测及其处理办法   等待图法\n  超时死锁检测法：锁申请等待超时 \u0026amp; 事务执行超时\n  时间戳死锁检测法\n5.3 数据库恢复技术\n      数据库恢复的含义、方法和常用措施\n  数据库故障的分类\n  数据库故障恢复三大技术：数据转储，日志，数据库镜像\n  数据转储：静态转储/动态转储，海量转储/增量转储，\n  日志：\n 日志的内容、组成、作用与记载原则 在日志中设置检查点的作用 事务的撤销（UNDO）与重做（REDO） UNDO日志  UNDO日志的内容，记载规则，作用 基于UNDO日志的故障恢复流程   REDO日志  REDO日志的内容，记载规则，作用 基于REDO日志的故障恢复流程   UNDO/REDO日志  UNDO/REDO日志的内容，记载规则，作用 基于UNDO/REDO日志的故障恢复流程   UNDO日志、REDO日志、UNDO/REDO日志的优点与缺点    恢复策略：小型/中型/大型故障的恢复策略\n   事务处理 事务：访问并可能更新数据库上数据的一个程序执行单元(unit)\n在关系数据库系统中，一个事物是由一条SQL语句或者一组SQL语句所构成的一个执行过程，并具有ACID四个特性\n事务是恢复和并发控制的基本单位\n事务：某个用户执行的一个不能被打断的对数据库的操作序列\n四条ACID性质：\n 原子性Atomicity：一个事务中的操作要么全部执行结束，要么一个都不执行。数据库管理系统会通过事务管理子系统、事务日志自动维护原子性 一致性Consistency：一个事务的成功执行总是将数据库从一个一致的状态转移到另一个一致的状态，包括了数据库中显式定义的各种完整性约束与用户心目中的隐式数据约束，可以通过DBMS的数据完整性保护子系统和编写事务的应用程序员两方面进行保护 隔离性 Isolation：一个事务的执行与并发执行的其他事务独立，互不干扰，由并发控制子系统实现 持久性 Durability：一个事务完成操作后，对数据库的更新永久反映在数据库中，即使以后故障也能通过故障恢复保留结果，由DBMS的恢复管理子系统实现  事务活动的流程 活动状态：事务开始执行后，进入活动状态，事务将执行数据库的访问操作，对于读操作，将数据读入用户的私有工作区间，如果该数据当前不存在DBMS系统缓冲区，那么DBMS首先将该数据从磁盘读入系统缓冲区，再将其拷贝到用户事务的私有工作区。对于写操作，可能并不是立即将数据永久写入磁盘，可能会暂时存放在DBMS系统缓冲区。\n预提交状态：事务最后一个访问语句执行结束后，事务进入预提交状态，此时写操作的结果可能还在缓冲区内，要确保当前事务的所有修改操作都真正被写入数据库的磁盘中，当所有写磁盘操作执行结束后，进入提交状态，否则如果执行过程中发生故障导致执行失败猫就进入失败状态\n失败(abort)状态：事务执行完最后一条语句前中断或者预提交失败都会进入失败状态，原因可能是用户或应用程序主动放弃，因为并发控制被放弃(如封锁申请超时等待、死锁)或者发生系统故障\n异常中止(aborted)状态:对于失败状态事务，可能已经进行了一部分修改，为保证原子性，需要撤销已经进行的修改(回退rollback，由DBMS的恢复子系统实现)，进入异常中止状态，此时系统可以取消事务，也可以作为一个新的事务重新启动。\n提交状态：进入预提交后，并发控制子系统检查是否发生干扰，检查通过后执行提交操作，执行后进入提交状态\n有关事务的语句 主要有三条语句：\n 事务的开始(begin transaction): 事务的启动是隐式的，可以通过三种方式启动一个新的事务：数据定义命令DDL(每一条数据定义命令作为一个单独事务执行，在此之前当前用户事务自动提交)，将系统设置为自动提交方式即打开自动提交标志(每一条数据库访问指令都将作为一个单独的事务执行并根据执行结果自动提交或者回退)，数据操纵命令DML(前一个事务执行结束后，下一个数据访问操作执行之前，自动为用户启动一个新的事务)。 提交事务(commit transaction):提交可能因为系统故障或者数据完整性检查而导致失败，事务提交失败后可以通过回退来取消当前事务，系统自动提交的事务将会自动进行回退操作 回退事务(rollback transaction):取消事务执行过程中的所有操作，回滚至起点，在事务执行过程中，用户可以设置若干保存点(savepoint),用户事务可以使用rollback回滚到某一个保存点并继续执行当前事务，不带保存点的回退将结束并放弃整个事务  设置事务的自动提交： SET AUTOCOMMIT ON|OFF\n设置事务的类型（只读型事务与读/写型事务，缺省定义为读/写型事务）： SET TANSACTION READONLY | READWRITE\n设置事务的隔离级别：\nSET TRANSACTION ISOLATION LEVEL READUNCOMMITTED | READCOMMITTED | READREPEATABLE | SERIALIZABLE 设置了不同的隔离级别，系统所采取的封锁策略也不同\n 未提交读：不申请封锁，可能读到未提交结果，禁止以此方式执行写操作 提交读：读数据A前申请对A的共享性封锁，读结束后立即释放该封锁 可重复读：读数据A前申请对A的共享性封锁并将封锁维持到事务结束 可序列化(可串行化)：以一种可串行化的调度策略实现并并发执行，以避免干扰现象  但是不管设置了何种隔离级别，在写数据对象A的时候，会申请对A的排他性封锁并维持到事务结束\n事务的组成 数据对象：\n 数据对象的大小：可以是一个属性值/元组/表/整个数据库，我们不严格区分只是称为数据对象A 数据对象的地址空间：存在三种有关的地中空间概念(保存数据的磁盘空间、内润缓冲区、事务的局部地址空间即内存变量)  一个事务有关的操作分为两类：\n 事务控制操作（其中T0为事务标识符，每启动一个事务，DBMS自动分配一个唯一的事务标识符）  事务的开始：START T0 提交事务：COMMIT T0 回退(放弃事务)： ABORT T0   数据访问操作：  INPUT(A)：将数据A从磁盘读入内存缓冲区 OUTPUT(A)：将数据A从内存缓冲区写入磁盘 READ(A,t)：将内存缓冲区的数据对象A的值读入内存变量t(可能包含INPUT操作) WRITE(A,t) ：将内存变量的值写入对象A    并发控制技术 事务的并发执行 并发控制技术：实现多个用户事务的并发执行\n并发执行的可串行化: 一组事务并发执行的结果等价于他们之间的某种串行执行的结果，称为可串行化调度\n并发控制的目标就是要实现并发事务的可串行化调度\n各个事务的数据库访问操作在DBMS中的实际执行序列构成了事务之间的一个调度，一组事务的调度必须包括所有操作包括一个事务的结束命令，且保证单个事务内部执行顺序不变\n值得注意的是，不同事务的访问请求在DBMS内部的执行顺序可能与到达顺序不一样，但是同一个事务内部的操作顺序一定与到达顺序一致\n串行调度：首先是一个事务的所有操作，然后是另一个事务的所有操作，依次类推，称调度是串行的\n我们用符号 $T_1,T_2..$ 标识事务，用$r_i(X)$标识事务$T_i$读数据库对象X，类似的有$w_i(x)$\n冲突：调度中的一对相邻操作(op1,op2)如果交换他们的顺序，那么涉及的事务中至少有一个的行为会改变，那么称这对相邻操作为冲突\n冲突包括：同一个事务的任意两个相邻操作，对于不同事务的两个相邻操作中涉及同一对象且至少有一个为写操作\n如果对于初始给定的一个调度，可以通过一组非冲突化操作变成一个串行调度，那么认为最初的调度是一个可串行化调度且称为冲突可串行化调度\n注意：冲突可串行化调度一定是一个可串行化调度，但是可串行化调度不一定是一个冲突可串行化的\n如果两个事务$T_1,T_2$分别存在动作$A_1,A_2$,在调度H中，$A_1$在$A_2$之前执行，如果两个动作涉及同一个数据对象并且至少有一个为写动作，那么称$T_1$优先于$T_2$,记为$T_1 \u0026lt;_S T_2$,上述情况下，A1与A2不能交换，在H的冲突等价串行调度中，T1必在T2之前\n判断是否冲突可串行化：如果$T_i \u0026lt;_S T_j$,那么从i到j引一条有向边，如此寻找所有冲突对(可以根据所有被访问的数据对象来发现冲突对)构造优先图，如果事务优先图中无环，则为冲突可串行化调度，否则不是。\n利用优先图，如果一个点不存在指向该节点的有向边，就先执行这个节点对应的事务，再考虑其他节点的优先图。\n三种可串行化调度：视图可串行化是可串行化调度的子集，冲突可串行化是视图可串行化的子集\n视图可串行化调度指的是视图等价为一个串行调度，S与H视图等价当且仅当满足以下三个条件：对每一个数据项D\n 如果在调度S中事务Tk读到D的初始值，则在调度H中事务Tk也必须读到D的初始值； 如果在调度S中事务Tk执行了$r_k(D)$，并且读到的是由事务Tj写入的D的值，则在调度H中事务Tk的$r_k(D)$读到的也必须是由事务Tj 所写入的D的值； 如果在调度S中是由事务Tk来执行最后一条关于D的写操作$w_k(D)$，则在调度H中也一定是事务Tk执行最后一条关于D的写操作$w_k(D)$。  视图可串行化调度不一定是冲突可串行化调度的原因在于：可能存在盲写现象(一个事务没有读取数据项D的值并直接用write操作修改D的值)\n数据不一致现象：\n 丢失修改(lost-update)：一个事务的修改破坏了另一个事务的修改结果，原因在于对多个并发修改同一个值没有限制 脏读（dirty-read）：一个事务读到了另一个事务未提交的结果 不可重复读(unrepeatable-read):在两次读操作之间差入了另一个事务的写操作  封锁 封锁一段事件内禁止其他事务执行某些操作同时也表明持有该封锁的事务在被封锁的数据对象上执行什么样的操作\n排他锁：X锁：只有在数据A上没有任何封锁的时候能申请，如果一个事务申请了X锁，那么其他事务都不能获得A上的任何类型的封锁，获得X锁后可以进行读、写操作，其他事务禁止访问，降低了并行性，但是保证了正确性与一致性，X锁必须维持到事务结束\n共享锁：S锁： 如果数据A没有被封锁或者是以S锁的形式封锁时，可以申请S锁，事务T可以读，但是不可以写，S锁不一定要维持到事务结束\n合适事务：一个事务访问前按照要求申请封锁，操作结束后释放封锁，这种事务称为合适事务\n合适事务时保证并发事件正确执行的基本条件\n封锁管理器的数据结构：数组LOCK(A)记录数据对象A上的封锁状态，分别是Read_locked(共享锁)、Write_locked(排他锁)、Unlocked(无封锁)，数组no_of_reads(A)记录A上的共享锁的个数。\n基于封锁技术的并发控制实现方法：\n 在DBMS的封锁管理器上维护一张锁表，包括了封锁的持有情况(哪些事务在哪些数据对象上持有什么锁)与封锁的申请等待情况(有哪些事务正在等待哪些数据对象上的什么类型的封锁) DBMS对于请求op(A)，将访问操作发送给并发控制子系统的调度器。调度器根据系统的封锁协议来决定是否需要为该操作申请封锁以及申请何种类型的封锁，并将封锁请求发送给封锁管理器，封锁管理器根据锁表的情况决定能够立即满足，并将结果返回给调度器，如果得不到满足，则调度器将访问操作放入被推迟的访问操作序列，否则将该操作发送给系统的执行引擎去执行。  封锁协议 封锁协议规定了何时申请封锁，申请何种类型封锁，何时释放封锁\n最常见的有三级封锁协议与两阶段封锁协议\n三级封锁协议：以单条数据访问操作为单位，定义了锁的申请和释放要求，根据具体要求不同，可以将其分为一级封锁协议、二级封锁协议、三级封锁协议三种级别不同的封锁协议\n 一级封锁协议(可以预防丢失修改)：写对象A之前必须先申请A上的X锁并维持到事务T的结束才释放 二级封锁协议(可以预防丢失修改、脏读)：满足一级封锁，在读对象A之前必须先申请A上的S锁并在操作完成后即可以释放S锁(此处未规定释放时间) 三级封锁协议(可以预防丢失修改、脏读、不可重复读)：满足一级封锁，事务在读对象A之前，必须先获得A上的S锁，并保持到事务结束后才释放  两阶段封锁协议(2PL协议)：以事务为单位规定封锁的使用规则\n 第一阶段:申请并获得锁，在此阶段可以申请整个执行过程中需要的锁，但是不能释放，锁的数量不断上升，可以称为扩展阶段 第二阶段：释放所有的锁，包括释放被挂起的锁申请请求，称为收缩阶段  在两阶段封锁协议中，如果$T_i$已经持有A上的S锁，当处理$xl_i(A)$请求时，会直接将S锁改为X锁\n2PL事务产生的任意合法调度都是冲突可串行化的\n封锁粒度 封锁粒度：一把锁可以封锁的数据对象的大小，可以时数据库中的逻辑数据单元(属性值、元组、关系、索引、整个数据库)，也可以是物理数据单元(页、块)\n封锁粒度大，则系统并发性低，并发控制开销小。封锁粒度小，则并发性高，对应的并发控制开销大\n如果在一个系统中同时支持多种封锁粒度供事务选择使用，这种方法称为多粒度封锁\n可以根据封锁粒度的大小构造一棵多粒度树，以每个节点作为封锁对象，构成一个多粒度封锁协议(显式封锁是可以对每个节点独立加锁，隐式封锁是该节点的所有后裔也被加以同类型的锁)\n意向锁：如果对一个节点加意向锁，说明该节点的下层节点正在被加锁，对任一节点加锁前必须先对他的上层节点加意向锁\n常见的意向锁：\n 意向共享锁(IS锁)：后裔准备加S锁 意向排他锁(IX锁)：后裔准备加X锁 共享意向排他锁(SIX锁)：后裔准备加X锁且自身加S锁  相容表 |准备申请的\\目前有的|S|X|IS|IX|SIX| |:--|--|--|--|--|--| |S|YES|NO|YES|NO|NO| |X|NO|NO|NO|NO|NO| |IS|YES|NO|YES|YES|YES| |IX|NO|NO|YES|YES|NO| |SIX|NO|NO|YES|NO|NO|\n申请封锁的顺序：从上至下\n释放封锁的顺序：由底而上\n死锁与活锁 死锁：每个事务拥有一部分锁，同时申请其他事务的锁而等待，由此形成的循环\n处理办法：\n 预防法：顺序申请法；一次申请法 解除法：  超时死锁检测法：事务执行时间超时；锁申请等待时间超时 等待图法 时间戳死锁检测法：每个事务有一个用于死锁检测的时间戳，时间戳反映事务的新老程度，如果事务T必须等待另一个事务U持有的锁，有两种策略：  等待-死亡方案：如果T比U老，那么允许T等待U持有的锁；如果U比T老，那么事务T死亡(被回滚)； 伤害-等待方案：如果T比U老，他将伤害U，U必须被回滚；如果U比T老，那么T等待U持有的锁      活锁：有部分事务因为封锁得不到满足长期处于等待状态，而其他事务仍可以继续进行；解决方式：先来先解决\n数据库恢复技术 数据库恢复：在暑假库遭受破坏后及时进行恢复的功能\n方法：利用数据冗余原理，将数据库中的数据在不同存储介质上进行冗余存储，在本身遭到破坏时利用冗余信息进行恢复\n常用措施:数据转储、日志、数据库镜像\n故障分类 小型故障：事务内部故障\n中型故障：系统故障；外部影响(可能导致整个系统停止工作，但是磁盘数据不受影响，系统重启时可以根据日志进行恢复)\n大型故障：磁盘故障；计算机病毒；黑客入侵；(可能导致内存及磁盘数据的严重破坏，需要对数据库做彻底的恢复)\n转储 数据转储：定期的将数据库中的内容复制到其他存储设备中去的过程\n转储可分为：静态转储/动态转储；海量转储/增量转储\n转储过程得到的后备副本并不能保证数据库中数据的一致性，如果使用该副本进行故障恢复，需要解和当时记载的日志信息，日志中应该记载：\n 转储的开始点与结束点 转储执行过程中，事务的更新情况：\u0026amp;lt;事务标识,更新对象，更新前的值，更新后的值\u0026gt; 转储执行过程中完成的事务的结束状态：Commit/Abort  日志 数据库系统创建并维护的，用于自动记载数据库中修改型操作的数据更新情况的文件\n内容包括了每个更新操作的事务标识、更新对象、更新前的值 和/或 更新后的值；每个事务的开始、结束等情况；其他信息\n日志是日志记录的一个序列，每个日志记录记载有关某个事物已执行操作的情况\n作用：\n 保证事务执行的原子性 实现增量转储 实现故障恢复  为了修复故障产生的影响，某些事务操作将会被重做，而另一些事务的操作将会被撤销 为了区分哪些事务重做，哪些事务撤销，日志中需要记载每个事务的结束标志：commit：将被重执，abort将被撤销 日志中没有结束标志的事务在恢复时被当作被放弃的事务    先写日志，再修改数据库\nundo日志 undo日志：用于被放弃事务的撤销工作\n记录格式：\n 开始一个事务：\u0026lt;START T\u0026gt; 提交事务：\u0026lt;COMMIT T\u0026gt; 放弃事务: \u0026lt;ABORT T\u0026gt; 更新记录: \u0026lt;T,X,V\u0026gt;(事务T修改X,X的旧值是V)  记载规则：如果事务T修改了数据库元素X，则更新日志必须在新值写入磁盘前写到磁盘，如果事务T提交，则日志记录必须在事务T改变的所有元素已经写到磁盘后再写到磁盘\n恢复过程：\n 将事务区分为已提交事务与未提交事务(有无Commit) 从日志尾向日志头部扫描，对每一条更新记录，如果已经扫描到\\则继续扫描下一条，否则恢复为V 在日志尾部未每一个未结束的事务T写入一条日志记录\u0026lt;ABORT T\u0026gt;并刷新日志(Flush Log)  检查点：为了降低数据库恢复的开销，定期在日志文件中加入检查点\n加入检查点的处理过程：\n 系统停止接受‘启动新事务的请求’ 等到所有当前活跃的事务被提交或中止，并且在日志中写入了\\或\\记录 将日志记录刷新到磁盘 写入日志记录\\，并再次刷新日志 重新开始接受新的事务  在故障恢复时，只要逆向扫描到第一条\\记录(最后一个被记入的检查点)就可以结束故障恢复工作\n非静止检查点：设置过程中，允许新的事务进入\n 写入日志记录\\，并刷新日志；其中：T1,…,Tk是当前所有活跃事务的标识符 等待T1,…,Tk中的每一个事务的提交或中止，在这个过程中允许启动执行新的事务 当T1,…,Tk都已经完成时，写入日志记录\\并刷新日志  恢复时从日志尾部向前扫描，可能遇到两种情况\n 先遇到\\记录：继续向后扫描，直到出现与之相对应的\\记录就可以结束故障恢复工作，在这之前的日志记录是没有用处的，可以被抛弃 先遇到\\记录，此种情况下的故障恢复工作需要撤消两类事务的操作：在\\记录之后启动的事务(在扫描到\\记录时，这类事务的操作已经被撤消);T1,…,Tk中在系统崩溃前尚未完成的事务(继续向后扫描日志，直至其中未完成事务的访问操作被全部撤消)  undo日志不足：事务改变的所有数据写到磁盘前不能提交事务，导致增加了很多写磁盘操作，增加了事务提交的时间开销\nredo日志 格式与undo差不多，唯一的差别在于更新记录中V记载的时更新后的值\n记载规则：在修改磁盘上的任何数据库元素X之前，要保证所有与X的这一修改有关的日志记录（包括更新记录\\ 和提交记录 \\）都必须出现在磁盘上。(这也就意味着从缓冲区写到磁盘上的数据在commit日志已经被写到了磁盘上之后)\n恢复：\n 确定所有已提交的事务（先扫描一遍日志文件） 从日志文件的头部开始扫描日志，对遇到的每一条更新记录\\：如果T是未提交事务，则继续扫描日志如果T是已提交的事务，则为数据库元素X写入新值V 对每个未完成的事务T，在日志的尾部写入结束标志\\并刷新日志  在redo日志中插入(非静止)检查点的步骤：\n 写入日志记录\\，并刷新日志；其中：T1,…,Tk是当前所有活跃事务的标识符，同时获得当时所有已提交事务的标识符集合S 将集合S中的事务已经写到内存缓冲区但还没有写到数据库磁盘的数据库元素写入磁盘； 写入日志记录\\并刷新日志，不必等待事务T1,…,Tk或新开始事务的结束  恢复：找到最后一个被记入日志的\\(记为记录t)，假设与之相对应的检查点记录是\\(记为记录t’)，并找到最早出现的\\(记为记录ti).故障恢复方法如下：针对事务T1,…,Tk以及在t’之后开始的那些事务，重做其中已经被提交的事务\n不足：增加了平均缓冲区的数量\nundo/redo日志 与之前基本一致，不过更新记录变为了\\，其中v为之前值，w为修改后值\n记载规则：由于某个事务T所作的改变而修改磁盘上的元素X之前，关于X的更新记录(\\)必须先出现在磁盘上。每一条Commit日志记录后面必须紧跟一条Flush Log操作\n此时，commit操作和写磁盘(output)操作顺序是随机的\n恢复： 根据\\是否已经出现在磁盘中来决定事务T是否已经被提交。按照从后往前的顺序，撤消(undo)所有未提交的事务，按照从前往后的顺序，重做(redo)所有已提交的事务\n插入检查点：写入日志记录\\，并刷新日志。其中：T1,…,Tk是当前所有活跃事务的标识符,将所有被修改过的缓冲区写到数据库的磁盘中去,写入日志记录\\并刷新日志\n恢复策略 小型故障：利用未结束事务的undo操作\n中型故障：\n 非正常中止：undo 已完成提交，结果还在缓冲区中：redo  大型故障：先利用后备副本进行恢复，在利用日志进行数据库恢复(逆向搜未完成undo，正向搜完成redo)\n数据库镜像 将整个数据库中数据或者主要数据实时复制到另一个磁盘中\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/transaction/","tags":null,"title":"事务管理、并发控制与故障恢复"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 6\n TD：时序差分方法，是一种综合了蒙特卡洛与DP的特点的方法\n6.1 TD Prediction 对于$\\alpha$-蒙特卡洛来说，其更新规则如下：\n$$V(S_t) \\leftarrow V(S_t)+\\alpha[G_t - V(S_t)]$$\n其对于每一个$S_t$所对应的value都需要等待对应的episode结束后才能够更新，而对于一种TD算法（以下为TD(0)或者叫one-step TD），可以如下的更新方式:\n$$V(S_t) \\leftarrow V(S_t)+\\alpha[R_{t+1} + \\gamma V(S_{t+1})- V(S_t)]$$\n这就是把其中的$G_t$替换成立下一个时间点就能得到的reward信息来对其进行更新，这个事实上就是bootstrap（本意为自举，在此处即用后继的值函数来估计当前值函数），而这就是DP的思想 下给出TD(0)的伪代码：\n6.2 Advantages of TD Prediction Methods 6.3 Optimality of TD(0) 6.4 Sarsa: On-policy TD Control 6.5 Q-learning: Off-policy TD Control 6.6 Expected Sarsa 6.7 Maximization Bias and Double Learning 6.8 Games, Afterstates, and Other Special Cases ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl6/","tags":null,"title":"Temporal-Difference Learning"},{"categories":null,"contents":" 因此，我要说，陛下应当受制于法律；而认可陛下的要求，则是叛国；对于我所说的话，布拉克顿曾经这样说过：国王在万人之上，但却在上帝和法律之下。——爱德华·柯克\n 宪政与宪法的基本问题 政府的基本职责与宪法的基本目标都应该是保护公民的自由和权利。因此，一个国家宪法与法治的实施程度是跟该国公民权利和基本自由高度相关的。\n宪法的两个主要内容，一是跟国家的正式政治制度结构有关的，二是跟公民自由和基本权利有关的。\n 宪政，又译立宪主义,一般是指基于宪法与法律来实施统治，或者说是国家的强制性权力受到宪法与法律普遍约束的观念和制度。  宪法与法律限制政府活动和政治权力的范围。这与有限政府原则是一致的。 宪法与法律应明确及保障公民平等的自由和权利。宪政意味着每个公民的自由与权利受到明确的保护。 宪法与法律创造政府越权时给予救济的手段。    法治对应的是“rule of law”，法制对应的是“rule by law”。对于前者，法律具有至高无上的地位；而对于后者，法律不过是一种统治或治理的工具。\n宪法的功能：\n 确立合法性，确立政府合法性和赋予政治权力 确立基本的政治制度结构 明确公民的自由与权利 限制政府活动和政治权力 提供关键政治争端的解决方法  宪政与司法审查 由于宪法既不能自我制定、又不能自我实施，所以宪法必须依赖于机构和人才能起作用。在一些发达国家，实践宪政的一个重要方面就是司法审查或违宪审查制度。\n司法审查一般是指最高法院或宪法法院对行政机构或立法机构的法律与决定进行合宪性审查的机制。\n司法审查或违宪审查通常涉及三项内容：一是裁决具体的法律或决定是否符合宪法；二是解决国家和公民关于基本自由权的冲突；三是解决不同政府机构或不同层级政府之间的冲突。\n一方面，宪政固然是约束政治的规则。从理想上说，宪政是用来约束和规范政治的，是用来规范政府和主要政治集团行为的。但另一方面，现实的宪政首先是某个政治过程的结果，宪政实现与否是政治过程本身塑造和决定的，宪政可以被视为一种政治均衡状态。\n法律体系与司法系统 按照自然法或高级法的学说，自然法或高级法在逻辑上优先于人类制定法，即制定法或实在法。\n自然法学说强调的是自然正义原则，重视人的自然权利，认同天赋人权，认为自然权利不证自明并具有普遍性，而成文法应该遵循自然法的基本原则\n西方世界有两种主要的法律体系：\n 英美法，又称普通法，起源于英格兰，盛行于美国和英联邦国家。是判例法。所谓判例法，就是基于法院的判决而形成的具有法律效力的判定，这种判定对以后的判决具有法律规范效力，能够作为法院判案的法律依据  坚持被告无罪推定的原则，即在证明并判决为有罪之前，被告或嫌疑人均被视为无罪。   大陆法，又法典法。起源于古罗马，完善于法国，盛行于欧洲大陆以及其他多数国家。是成文法，先要立法，即制定规则，包括主要条款及细则——法律条文应该讲清楚什么可以做和什么不能做。倘若有人违法，对照法律，即可判定是否违法或犯罪，处罚细则亦有相应规定。  大陆法系一般要求被告自证清白，当然不同国家的程序是不同的。    普通法系的司法更多地独立于行政，大陆法系的司法跟行政有更为密切的关系。\n公民权利与《世界人权宣言》 《世界人权宣言》的条款反映1948年人类关于公民自由与权利的共识。一方面，宣言包括和强调了像生命权、自由权、财产权和平等权，等等；另一方面，宣言也包括和强调了人的受教育权、保障权、发展权和社会福利权，等等。\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap7/","tags":null,"title":"法治与公民权"},{"categories":null,"contents":" 放大电路模型，基本定义，符号，几种争议的定义，主要的性能指标，频率响应的定义，认识图和图上的点，知道失真与非线性失真的概念（看到图知道什么回事）\n 放大电路模型 信号的基本概念 信号：信息的载体-温度、压力、速度、声音、亮度。。\n电信号：用电量描述信息的变化\n电信号源的电路表达形式：电压源等效电路、电流源等效电路\n模拟信号：在时间和幅值上都是连续的信号\n数字信号：在时间和幅值上都是离散的信号\n按照时间和幅值的连续性和离散性分类：\n 时间连续、数值连续：模拟信号 时间离散、数值连续：AD转换信号 时间连续、数值离散：DA转换信号 时间离散、数值离散：数字信号  放大电路 放大电路是模拟电路中最基本的单元电路\n一般的放大电路基本如下：\n处于简便考虑，通常会将放大电路的工作电源给隐去，如右图所示\n放大电路是一个双口网络，可以利用端口特性来研究放大电路\n输入端口等价为一个电阻，输出端口根据不同情况等效为不同的电路形式\n放大电路模型  电压放大模型  $R_i$：输入电阻 $R_o$: 输出电阻 $A_{vo}$: 负载开路时的电压增益 由$v_o=A_{vo}v_i\\frac{R_L}{R_O+R_L}$可知，电压增益为$A_v=\\frac{v_o}{v_i}=A_{vo}\\frac{R_L}{R_O+R_L}$ 可知：负载大小会影响增益大小，故而要$R_o\u0026lt;\u0026lt;R_L$,理想情况输出电阻为0 输入回路对信号源的衰减，故而$R_i\u0026gt;\u0026gt;R_S$,理想情况取无穷大   电流放大模型  同上分析可知电流增益为$A_i=A_{is}\\frac{R_O}{R_O+R_L}$ 要减少负载的影响，故而要$R_O\u0026gt;\u0026gt;R_L$,理想情况下取无穷 要减小信号源的衰减，故而$R_i\u0026lt;\u0026lt;R_s$,理想情况为0   互阻放大模型 互导放大模型 隔离放大电路模型  放大电路主要性能指标 输入电阻 $R_i=\\frac{v_i}{i_i}$\n输入电阻决定了放大电路从信号源吸收信号幅值的大小\n电压放大和互导放大的输入信号为电压，要求输入电阻大\n电流放大和互阻放大的输入信号为电流，要求输入电阻小\n输出电阻 输出电阻决定了放大电路带负载的能力\n电压放大和互阻放大的输出信号为电压，要求输出电阻小\n电流放大和互导放大的输出信号为电流，要求输出电阻大\n注意：输入、输出电阻为交流等效电阻\n增益 反映了放大电路在输入信号控制下，将供电电源能量转换为输出信号能量的能力\n其中，$A_v$和$A_i$常用分贝（dB）表示\n 电压增益 $= 20\\lg|A_v|$ 电流增益 $= 20\\lg |A_i|$ 功率增益 $= 10lg A_p$  频率响应及带宽 输入正弦信号情况下，输出随输入信号频率连续变化的稳态响应，称为放大电路的频率响应\n$A_V(\\omega)=|\\frac{\\dot{V}_O(j\\omega)}{\\dot{V}_i(j\\omega)}|$： 幅频响应，反映电压增益的模和角频率之间的关系\n$\\angle \\varphi(\\omega) = \\varphi_o(\\omega) - \\varphi_i (\\omega)$：相频响应，反映输入正弦信号的相位差与角频率之间的关系\n带宽BW=$f_H$(上限频率) - $f_L$(下限频率)\n输出功率约等于中频区的一般的点称为半功率点\n失真：\n 频率失真(线性失真)  幅度失真：对不同频率的信号增益不同 相位失真：对不同频率信号的相移不同   非线性失真：由原件非线性特性引起的失真，在频谱图上表现为由新的频率分量产生  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/","tags":null,"title":"放大电路模型"},{"categories":null,"contents":"Mantel's Theorem: Suppose G(V,E) is a graph on n vertices without triangles, then $|E|\\leq \\frac{n^2}{4}$\nTuran's Theorem: Let $G(V,E)$ be a graph with $|V| = n$. If G has no r-clique, $r \\geqslant 2$, then $|E| \\leqslant \\dfrac{r-2}{2(r-1)} n^2$\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/extremal-graph-theroy/","tags":null,"title":"Extremal Graph Theroy"},{"categories":null,"contents":"无线网络与移动网络 7.1 概述 无线主机(wireless host): 类似于有线主机，运行应用程序的端设备。\n无线链路： 主机通过无线通信链路来连接到一个基站。\n基站(base station): 负责向与之关联的无线主机发送数据和从主机那里获得数据(例如分组)。基站通常负责协调与之相关联的多个无线主机的传输。\n与基站相关联的主机通常称为以基础设施模式运行，在自组织网络中，无线主机没有这样的基础设施与之相连，在这种情况下，主机本身必须提供包括路由选择、地址分配等服务。\n当一台移动主机的移动超出一个基站的覆盖范围并到达另一个基站的覆盖范围之后，它将改变其接入到更大网络的连接点。这一过程称为切换(handoff)\n...\n7.2 无线链路和网络特征 ...\n7.3 WIFI: 802.11无线LAN IEEE 802.11无线LAN：WIFI\n7.3.1 802.11体系结构 主要工作频段是2.4GHz和5GHz\n802.11体系结构的基本构件是基本服务集(Basic Service Set,BSS), 一个BSS包括一个或者多个的无线站点和一个**接入点(Access Point,AP)**即中央基站\n与以太网设备类似，每个802.11无线站点都有一个6字节的MAC地址，这个地址存储在该站适配器的固件中。\n配置AP的无线LAN通常被称为时基础设施无线LAN，其中的基础设施指的是AP连同互联AP和一台路由器的有线以太网。\n信道与关联 网络管理员安装一个AP时，管理员为该接入点分配一个单字或者双字的服务集标识符(SSID),还必须分配一个单信号\nWIFI丛林：一个任意物理位置，能够从多个AP中收到很强的信号\n为了获得因特网接入，你的无线站点需要加入其中一个子网并因此需要和其中一个AP相关联。关联意味着这一无线站点在自身和该AP间建立一个虚拟线路\n802.11标准要求每个AP周期性的发送信号帧，该信号帧包括了AP的SSID和MAC地址。\n无线站点扫描11个信道，找到其中可能位于该区域的AP发出的信号帧\n 主动扫描  无线站点广播探测请求帧 自AP发送探测响应 无线站点选择AP发送关联请求帧 选择的AP相无线站点发送关联的响应帧   被动扫描  自AP发送信标帧 无线站点选择AP发送关联请求帧 AP相无线整点发送关联响应帧    7.3.2 802.11 MAC 协议 采用CSMA/CA协议：带碰撞避免的载波侦听多路访问\n并没有实现碰撞检测，这也就意味着一旦站点开始发送一个帧，他就完全的发送该帧\n不使用碰撞检测的原因：\n 检测碰撞的能力要求站点有同时发送和接收的能力，而在802.11适配器上，接收信号强度远小于发送信号强度，制造相关设备的硬件代价较大 适配器由于隐藏终端问题和衰减问题无法检测到所有的碰撞  802.11的链路层确认方案：目的站点收到一个通过了CRC检验的帧之后等待一个称做短帧间间隔的一小段时间，然后发挥一个确认帧。如果发送站点在给定时间内未收到确认帧，就假定出现了错误并重传该帧，使用CSMA/CA访问该信道。如果在若干固定次重传后仍未收到确认则放弃传送并丢弃该帧。\nCSMA/CA协议过程：\n 某站点监听到信道空闲，他将在一个**分布式帧间间隔（DIFS）**的短时间段后发送该帧 否则，选取一个随机回退值，并且在侦听信道空闲时递减该值。当侦听信道忙时，计数值保持不变 计数值减为0后(这只可能发生在信道空闲时)，发送整个数据帧 收到确认后，发送站点知道他的数据帧已经被接收，则发送第二帧，否则回到第二步，在更大的范围内选取回退值  处理隐藏终端：RTS与CTS 由于信号问题，两个无线站点对AP不隐藏但是对彼此隐藏。这可能导致一个无线站点正在传输一个帧时，另一个站点未听到正在传输，于是发起传输导致了碰撞\n处理方法：站点发送一个短请求发送(RTS)控制帧和一个短允许发送(CTS)控制帧来预约对信道的访问。当发送方需要发送数据时，先向AP发送一个RTS帧，指示传输DATA帧和确认帧需要的总时间，AP收到预约后广播一个CTS帧。既是为了给发送方明确的发送许可，也是为了指示其他站点预约期间不要发送\n实际上设置了RTS门限值，只有帧长超过了门限值才会预约\n7.3.3 IEEE 802.11帧 |帧控制|持续期|地址|地址2|地址3|序号控制|地址4|有效载荷|CRC| 有效载荷通常是一个IP数据报或者ARP分组组成。通常小于1500字节\nAP是链路层设备，他会对802.11帧和以太网帧进行转化\n 地址1：接收该帧的无线站点的MAC地址 地址2：发送该帧的MAC地址 地址3：路由器接口的MAC地址  序号：使接收方区分新传输的帧和以前的帧的重传\n持续期：预约信道一段时间的长度\n控制字段：包括很多子字段，如类型等\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wu-xian-wang-luo-yu-yi-dong-wang-luo/","tags":null,"title":"无线网络与移动网络"},{"categories":null,"contents":"游标管理与索引  游标管理\n 游标的作用 游标的定义、打开、使用、关闭 可滚动游标的定义及其在数据更新命令中的使用  索引 (index)\n B+索引的数据结构，搜索算法   游标管理 游标的定义(declare a cursor):为某一映像语句（可能返回多个结果元组）的结果集合定义一个命名的游标\nEXEC SQL DECLARE cursor-name CURSOR FOR subquery [ ORDER BY ...... ] [ FOR { READ ONLY | UPDATE [ OF columnname, ...... ] } ] ; 游标的打开(open the cursor):执行相应的映像语句并打开获得的结果集，此时游标处于活动状态并指向结果集合的第一条记录的前面\nEXEC SQL OPEN cursor-name ; 游标的使用(fetch a row by the cursor):将游标推向结果集合中的下一条记录，读出游标所指向记录的值并赋给对应的主语言变量，举例如下：\n/*其中agent_dollors是游标名，前带：的是表示主语言定义的变量*/ exec sql fetch agent_dollars into :agent_id, :dollar_sum; 每一个fetch的下一个是随机的（如果没有order by的话），所以每一个被打开过的游标只能遍历一次(但是可以打开多次)\n游标的关闭(close the cursor):关闭所使用的游标，释放相关的系统资源\nEXEC SQL CLOSE cursor-name ; 游标一旦被定义(declare)，可以被重复使用(open-fetch-close)。每一次open一个游标，都将重新执行对应的query，并生成新的结果集。\n应用程序可以通过‘游标状态变量’来了解一个游标的当前状态(是否处于打开状态、结果元组的个数、是否fetch到结果元组...\n可滚动游标的定义:\nEXEC SQL DECLARE cursor_name [ INSENSITIVE ] [ SCROLL ] CURSOR [ WITH HOLD ] FOR subquery { UNION subquery } [ ORDER BY ...... ] [ FOR READ ONLY | FOR UPDATE OF columnname ...... ]; 可滚动游标的更新：\nEXEC SQL FETCH [ { NEXT | PRIOR | FIRST | LAST | { ABSOLUTE | RELATIVE } value_spec } FROM ] cursor_name INTO ......; 索引 顺序文件：按照某个属性的取值进行排序的而构成的数据文件\n索引文件：为了加快数据文件的检索速度，根据用于定义查询条件的属性（索引关键字）来建立索引文件。由一个索引关键字值k_val和一个元组指针t_ptr所构成的二元组称为索引项\n为数据文件中的每个元组都生成一个索引项，由与某个数据文件相关的所有索引项而组成的文件被称为索引文件\n索引的查找：在索引文件中按照特征字段的值进行查找，找到具有该特征的记录的记录指针，从而可以在数据文件中直接定位读出需要的记录\n顺序文件上的索引 如果索引属性的值唯一，采取前三种，否则采取最后一种\n稠密索引 稀疏索引 多级索引 具有重复键值的索引 B/B+树上索引文件 树的最下一级索引是叶节点\nB+树的特点：\n 平衡性：根节点到每个叶节点的路径等长 过半性：除根节点之外每个节点所对应的磁盘空间至少被占用一半 顺序性：既可以从根节点开始随机查找关键字，也可以根据索引关键字的值进行排序进行顺序访问 自适应性：自动保持与数据文件大小相适应的索引层次  B+树的节点：每个节点占用一个磁盘块，每棵B+树有一个称为秩的整形参数n，每个结点可以容纳n个键和n+1个指针。\n结点的内容：$P_1,K_1,P_2,K_2,..,P_m,K_m,P_{m+1}$,其中K为关键字值，且关键字按照从小到大的顺序进行排列\n 根节点：$P_1$到$P_{m+1}$分别指向另一棵子树根节点 叶节点：前m个指针指向数据，最后一个指针指向右边的下一个叶子节点 非叶节点：对于夹在关键字$K_i$与$K_{i+1}$之间的那个指针，其指向的子树的键值都满足$K_i\u0026lt;K\u0026lt;K_{i+1}$  B+树上的随机查找：输入关键字K，根据节点的性质进行比较找到叶节点，判断叶节点中是否有关键字\nB+树上的范围查找：输入范围[a,b],先按照上述算法找到a对应的叶子节点，然后对叶子节点中的每个值与b进行对比直到大于b为止，这个叶节点中都小于b那么利用指向下一个叶节点的指针在下一个叶结点中重复上述判断\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/data-exchange/","tags":null,"title":"游标管理与索引"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 7\n ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl7/","tags":null,"title":"n-step Bootstraping"},{"categories":null,"contents":" 富裕国家更有可能成为民主国家，不是因为民主的出现是威权统治下经济发展的一个结果，而是因为民主——无论民主是怎样出现的——在一个富有的社会更有可能存活下去。\n​ ——亚当·普沃斯基\n  民主是成功还是失败，将继续主要取决于政治领导人和领导集团的选择、行为和决策。\n​ ——西摩·马丁·李普塞特\n 民主转型遭遇僵局 乌克兰、泰国、埃及的转型\n这一转型僵局由循环往复的三个阶段构成：一是威权体制的瓦解和启动转型；二是民主运转的困难及其引发的各种难题；三是威权方式作为解决问题方案的登场和威权政体的回归。\n由于种种原因，很多国家政治参与和政治竞争的结果，并不是稳定有效的政府和良好的公共治理，而是政治冲突的激化，政治家与党派竞争的不择手段，甚至可能是政治秩序的失控。\n第三波民主化国家的经验揭示，转型可能会出现三种不同的结局：最好的结局是完成民主转型并实现民主巩固；最坏的结局是转型失败并重新回到威权政体，在此过程中可能还伴随着秩序失控、暴力事件和流血冲突，甚至是国家分裂的危机；中间状态的结局则是新政体兼具民主因素与威权色彩，反复摇摆于民主和威权之间，但已丧失继续转型的政治动力。\n如何理解民主转型   民主转型（democratic tran-sition）现在跟民主化一般是混用的，尽管两者的侧重点不同。民主转型是指从非民主政体转变为民主政体的过程。\n  民主巩固（democratic consolidation）后来成为民主转型研究中的一个重要议题。简单地说，民主巩固是指一国的民主政体不断被强化的过程——通过这一过程，民主能够继续生存并能防止可能的逆转。\n 一是行为层面，主要的政治力量不再考虑推翻民主政体 二是态度层面，压倒性多数的公众接受民主为唯一的游戏规则 三是宪法层面，所有政治行动者都在宪法框架内解决政治冲突。    民主崩溃是指从民主政体蜕变为非民主政体的过程。\n  民主转型往往是一个充满不确定性、时间漫长的过程。\n民主史：从雅典、英国到现代 英国宪政和民主的演进：\n 第一阶段是规定国王不能做什么，标志性事件是1215年6月15日英格兰贵族武力胁迫国王签订的《大宪章》。 第二阶段是设立一个专门机构来监督国王的行为和贯彻《大宪章》。这一设想最终导致了13世纪英格兰议会的产生 第三阶段是责任内阁制的出现和发展。从最初的“王在议会”到后来的政治权力从国王向议会的转移，在18世纪内阁制逐步形成。 第四阶段是议会改革、选举资格限制的放开和普选权的落实。  三波民主化浪潮：亨廷顿认为，第一次民主化长波是1828—1926年，第一次回潮是1922—1942年；第二次民主化短波是1943—1962年，第二次回潮是1958—1975年；第三次民主化始于1974年，而到他1991年出版《第三波》时世界还正在经历第三波民主化浪潮\n托马斯·卡罗瑟斯悲观地认为，第三波民主化浪潮中的大多数国家并没有实现成功的民主转型和巩固。\n现代化导致民主化？ 亨廷顿认为大约有27个变量可以解释民主转型。在具体分析第三波民主化时，他认为主要有5个原因：（1）威权政体合法性的削弱；（2）长期经济增长以及对生活质量的影响，教育水平和中产阶级成长的推动；（3）天主教政治立场的转变；（4）美国、苏联外部政策的变化；以及（5）滚雪球或示范效应\n解释民主化的模型(一)：关注一个国家的经济发展水平和富裕程度\n 观点的最早提出：西蒙·马丁·李普塞特《民主的一些社会条件：经济发展与政治合法性》 观点质疑：  亨廷顿《变化社会中的政治秩序》：在很多发展中国家，经济发展不仅不能导致政治民主，反而会导致政治不稳定。 普沃斯基及其合作者《民主与发展：1950—1990年全球的政治制度与福利》：经济发展本身并不会导致民主。绝大多数富裕国家是民主国家，仅仅是因为民主在富裕国家更容易存活。 林茨、奥唐奈和施密特：对于民主前提条件的研究是误导性的，因为一国的条件只是设定了政体转型的情境，而政治民主能否出现或存活下去更多地取决于政治精英的战略互动和行为选择。这一观点是对丹克沃特·拉斯托1970年研究的延续   李普塞特本人也开始从原有的学术立场上退却了。他后来承认，对于民主转型来说，社会经济条件以外的其他变量，包括政治文化、宗教传统、制度设计、公民社会、法治、政治精英的行为等等，也具有同样重要的作用  驱动民主转型的阶级力量 用阶级结构和阶级斗争的视角来分析政治，一般被认为是马克思主义的方法。\n解释民主化模型（二）：主要关注的是一个国家的阶级与社会结构\n 巴林顿·摩尔《专制与民主的社会起源》：土地贵族、农民和资产阶级在政治舞台上扮演的不同角色和力量，决定了政治发展的不同道路。在由传统社会通往现代社会的三条道路中，只有资产阶级强大的国家才有可能建成民主国家。  民主的五个条件：一是“建立某种均势，避免王权或土地贵族畸轻畸重的局面出现”；二是“向形式适宜的农业商品经济过渡”；三是“削弱土地贵族”；四是“防止建立针对工农的地主资产阶级联盟”；五是“以革命手段粉碎过去”。 遭受质疑：从方法论、核心论点以及国别案例  过于夸大资产阶级对民主的正面作用 尽管资本主义发展与民主发展存在密切的关系，但在研究了西欧、拉丁美洲和加勒比海地区的政治变迁以后，他们认为：“资产阶级不是像传统上认为的那样是完全的、正宗的民主制度的推进者。当它的利益受到来自于工人阶级和其他群众运动需要的有力挑战时，它会选择威权主义的方式。” 资产阶级其实存在两种相互矛盾的恐惧：一方面恐惧威权统治者的胡作非为，另一方面恐惧民主政治下工人阶层的再分配政策。按照这一逻辑，资产阶级究竟倾向于支持还是反对民主，取决于他们对这两种恐惧的判断与权衡。     约翰·斯蒂芬斯：摩尔的研究“大大低估了民主转型过程中有组织的工人阶级的作用”。 鲁思·贝琳斯·科利尔则干脆认为，工人阶级是民主和民主化过程中的核心力量。 认为主要依靠中产阶级。最早可追溯亚里士多德。在亨廷顿看来，“第三波民主化运动不是由地主、农民或产业工人来领导的。几乎每一个国家民主化最积极的支持者是来自城市中产阶级。  政治文化重要吗 解释民主化理论（三）:主要关注一个国家的政治文化和宗教因素\n 托克维尔《论美国的民主》：“美国之能维护民主制度，应归功于地理环境、法制和民情。\u0026quot;“我确信，最佳的地理位置和最好的法制，没有民情的支持也不能维护一个政体；但民情却能减缓最不利的地理环境和最坏的法制的影响。” 阿尔蒙德： 一个稳定的和有效率的民主政府，不光是依靠政府结构和政治结构；它依靠人民所具有的对政治过程的取向——即政治文化。除非政治文化能够支持民主系统，否则，这种系统获得成功的机会将是渺茫的。 有利于民主的政治文化：公民文化。一种参与者取向、臣民取向和村民取向混合的文化。 达尔：“信念指导行动”，“在一个特定的国家里，对多头政治体制合法性的信念越强，则实行多头政体的可能性越大”。 罗伯特·帕特南：把这种公民传统视为社会资本——“这里所说的社会资本是指社会组织的特征，诸如信任、规范以及网络，它们能够通过促进合作行为来提高社会的效率。” 民主转型能否成功以及民主政体能否巩固，取决于政治参与者的政治行为，而政治行为的背后则是政治文化。 质疑：  政治文化与政治制度何为因何为果？ 政治文化是否真的有很强的政治效应？  杰克曼和米勒《政治文化的复兴？》对罗纳德·英格尔哈特和罗伯特·帕特南的研究提出了质疑，认为前者只考察了工业化国家，而后者在分析手段上存在偏差。 文化是什么往往难以界定；政治文化研究常常是事后解释；政治文化研究常常借助少数案例得出普适性的理论。   政治文化是否是一成不变的？   政治文化的另一个重要方面是宗教。在有些学者的眼中，宗教可能是最重要的政治文化。（但并非主流）  亨廷顿：宗教传统对民主化的成功具有重要的影响。20世纪60年代以后天主教的活动和信条发生变化，从保守的力量变为变革的力量，从支持威权的力量变为支持民主的力量，主教教廷的这种变化实际上使它自身成为第三波民主化浪潮的重要推动因素。 肯尼思·博伦：“新教徒的人口比例越大，民主的程度也就越高。”通常认为，基督教或新教强调个人尊严和宗教与国家的分离，都有利于民主的兴起。    影响转型的国际因素 解释民主化理论（四）:主要关注一国民主转型的国际环境或国际因素。\n今日的国际经济体系、世界政治格局和全球意识形态，是以英国为首的西欧文明在过去500年的崛起和扩张所塑造的。从这个意义上讲，世界性的民主革命不过是全球化和全球秩序重建的一部分。\n其实早在1971年，达尔就注意到了国际因素的重要影响，他说：“一个国家的命运永远不会完全掌握在它自己的人民手里。……每个国家都是在与他国共处的环境中生存的。”亨廷顿则认为：“外国政府或机构的行动也许会影响、甚至是决定性地影响到一个国家的民主化。”\n达尔: “一个国家的命运永远不会完全掌握在它自己的人民手里。……每个国家都是在与他国共处的环境中生存的。”\n怀特海德归纳总结出三种机制:\n 传染（Contagion），即民主经验不借助强制力的扩散 控制（Control），即一国借助强制力或约束力对另一国民主的推动 同意（Con-sent），这是国际力量通过与国内集团的一系列复杂互动产生影响的一个过程。 施密特在此研究的基础上，认为还有第四种机制：制约（Conditional-ity），即国家或国际组织通过审慎地使用强制力和讨价还价推动一国的民主。  强调国际因素的一个挑战是，国际因素比较接近的同一地区国家的民主转型和民主绩效的差别非常之大。\n转型政治中的精英行为 解释民主化理论（五）:主要关注一国民主转型政治行动者的行为。\n第五种理论强调的是民主转型和巩固的“过程性因素”。或者说，一个国家能否实现民主转型和巩固取决于该国政治转型的过程，特别是民主转型过程中政治精英的政治行为、战略选择和政治互动。\n这一理论视角现在也被称为**“转型研究”**或**“转型学”**（transitology）。\n如果说前四种理论是结构主义的，那么这里要介绍的是民主转型的能动理论。两者的主要分歧在于对民主转型过程中结构性因素和能动性因素看法的差异。\n  这种理论认为前四种理论的不足：\n 带有决定论的色彩，认为经济、社会、文化、历史和国际因素能够决定政治结果，而忽视政治行为者的作用。 结构主义关注长期的历史变迁，无法很好地解释民主转型或政治变革发生的时机 结构主义范式更多是功能性的，而不是发生学的。    丹尼沃克·拉斯托认为关键不在于解释民主制度如何能得以维持，而在于解释民主是如何产生的，因而发生学的研究更重要。\n  林茨和斯泰潘《民主政体的崩溃》：结构性环境条件越是不利，民主的生存就越需要高超的、创造性的、富有勇气的和忠于民主的政治领导力。即使障碍是巨大的，民主的崩溃也不是不可避免的。但如果领导无力、决策频频出错，民主崩溃就会加速。\n  三种不同的转型模式：\n 改革（transformation）：执政联盟中的改革派主导的政治转型； 置换（replacement）：威权政体垮台后反对派主导的政治转型； 移转（transplacement）：执政联盟被迫与反对派谈判启动的政治转型。    反对：\n 有学者批评这种理论过于精英主义、过于经验主义、惟意志论和短期化倾向。过于精英主义，往往会忽视大众的政治力量和政治行为；过于经验主义，容易把主要由南美和东欧转型过程研究的结论普遍化；惟意志论往往会过分强调政治精英的主动选择而忽视转型国家客观的经济社会条件；短期化倾向往往过分重视短期政治变迁而忽视一个国家的长期因素。    ","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap8/","tags":null,"title":"民主转型的政治逻辑"},{"categories":null,"contents":" 运算放大器:组成单元，参数特点，什么是理想运放与其模型，反馈的概念（不要求分析，即不要求判断正反），深度负反馈是什么回事 重要：虚断等 求差求和等电路的基本形式与特征，输入输出电阻啊等\n 运算放大器 集成电路运算放大器 功能：\n 信号放大 信号运算 信号处理（滤波、调制） 波形的产生和变换  分类\n 通用运放和专用运放 单运放、双运放、四运放  内部组成单元 不讨论集成运放的内部电路，仅从其电路模型和外特性出发，讨论运放构成的放大电路和典型的线性应用电路\n$v_p$称为同相输入端，因为当$v_n=0$时$v_o$和$v_P$同相，而$v_n$被称为反相输入端，因为$v_o$在$v_P$为0时的信号与$v_n$反相\n符号：\n电路模型 放大：在输入信号控制下，放大电路将供电电源能量转换为输出信号能量\n通常开环电压增益很高，输入电阻很大，输出电阻很小。\n$v_O=A_{vo}(v_p-v_N)$ $(V_-\u0026lt;v_O\u0026lt;V_+)$\n当$v_O$超过端值之后取端值，如下：\n理想运算放大器 理想运算放大器的特点：\n 开环差模电压增益无穷大 差模输入电阻无穷大 输出电阻为0  其$V_P-V_N\u0026gt;0$时取$V_+$,小于0时取$V_-$\n基本线性运算放大电路 同相放大电路  反馈：系统的输出返回到输入端并以某种方式改变输入，进而影响系统功能的过程，即将输出量通过某种恰当的检测装置返回到输入端并与输入量进行比较的过程 反馈通路：信号反向传输的渠道 反馈形式：  正反馈：输入量不变，引入反馈后，输出量变大(也可以认为输出不变净输出量减小) 负反馈：输入量不变，引入反馈后，输出量变小（也可以认为输出不变，净输出增大） 判断方法：瞬时极性法    同相放大电路的负反馈：$v_p(v_i)$上升导致，$v_o$上升，导致$v_n$上升，进而导致$v_{id}$下降从而导致$v_o$下降\n利用输出电压通过反馈元件对放大电路起自动调整作用\n如上，其中$A_v$的分母$(1+𝐴_{vo}F_v)$被称为反馈深度，当其远大于1也就是$1+A_{vo}F_v \\approx A_{vo}F_v$时，被称为**深度负反馈**\n运放的两个重要概念：\n 虚短：在深度负反馈作用下，$v_N$自动跟踪$v_P$,净输入电压$(v_P-v_N)\\to 0$,即P端和N端相当于短路 虚断：由于虚短的存在，而输入电阻又很高，即流经两输入端之间的电流$i_P=i_n \\approx 0$ 虚短是本质的，虚断是派生的  在同向放大电路中，加到两输入端的电压接近相等，相位相同是它在闭环状态下工作的重要特征\n几项技术指标的近似计算：\n 电压增益 $A_v=1 + \\frac{R_2}{R_1}$  根据虚短和虚断的概念，$v_p\\approx v_n$,$i_p=i_n=0$,故而$v_i=v_p\\approx v_n = v_f =\\frac{R1}{R1+R2}v_o$   输入电阻$R_i = v_i/i_i \\to \\infty$ 输出电阻 $R_o = r_o||[(R_1||r_i)+R_2] \\to 0$  电压跟随器：\n 令$R_1=\\infty, R_2=0$，电压增益为1，可以用于阻抗变换器和缓冲器  反相放大电路 根据虚短和虚断的概念，有$v_n=v_p=0$,因此反相输入端电位接近地电位， 称为虚地\n$𝐴_𝑣 = 𝑣_𝑜/𝑣_𝑖 = −𝑅_2/𝑅_1$（负号表示和输入反向）\n输入电阻：$𝑅_𝑖=𝑣_𝑖/𝑖_𝑖 =𝑣_𝑖/(𝑣_𝑖/𝑅_1)=𝑅_1$\n输出电阻：$𝑅_𝑜=𝑟_𝑜||𝑅_2→0$\n如果信号源是非理想的电压信号源，应当采用同向放大电路，因为输入电阻更大(避免非理想信号源分压过大)\n同向输入和反向输入放大电路的其他应用 求差电路 又称为是差分放大电路，是反相输入和同相输入相结合的放大电路\n求和电路 ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","tags":null,"title":"运算放大器"},{"categories":null,"contents":"Extremal Set Theroy Sunflowers Definition (sunflower): A set family $ {\\mathcal {F}}\\subseteq 2^{X}$ is a sunflower of size $ r$ with a core $ C\\subseteq X$ if $ \\forall S,T\\in {\\mathcal {F}}$ that $ S\\neq T$, $ S\\cap T=C$.\nSunflower Lemma (Erdős-Rado) Let $ {\\mathcal {F}}\\subseteq {X \\choose k}$. If $ |{\\mathcal {F}}|\u0026gt;k!(r-1)^{k}$, then $ {\\mathcal {F}}$ contains a sunflower of size $ r$.\nErdős–Ko–Rado theorem Erdős–Ko–Rado theorem (proved in 1938, published in 1961): Let $ {\\mathcal {F}}\\subseteq {X \\choose k}$ where $ |X|=n$ and $ n\\geq 2k$. If $ {\\mathcal {F}}$ is intersecting, then $ |{\\mathcal {F}}|\\leq {n-1 \\choose k-1}$.\nSperner Theorem A set family $ {\\mathcal {F}}\\subseteq 2^{X}$ with the relation $ \\subseteq $ define a poset. Thus, a chain is a sequence $ S_{1}\\subseteq S_{2}\\subseteq \\cdots \\subseteq S_{k}$.\nA set family $ {\\mathcal {F}}\\subseteq 2^{X}$ is an antichain (also called a Sperner system) if for all $ S,T\\in {\\mathcal {F}}$ that $ S\\neq T$, we have $ S\\not \\subseteq T$ .\nTheorem (Sperner 1928) Let $ {\\mathcal {F}}\\subseteq 2^{X}$ where $ |X|=n$ . If $ {\\mathcal {F}}$ is an antichain, then $ |{\\mathcal {F}}|\\leq {n \\choose \\lfloor n/2\\rfloor }$ .\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/extremal-set-theroy/","tags":null,"title":"Extremal Set Theroy"},{"categories":null,"contents":"计算机网络中的安全 RSA MD5 ","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ji-suan-ji-wang-luo-zhong-de-an-quan/","tags":null,"title":"计算机网络中的安全"},{"categories":null,"contents":"关系数据库规范化理论  8.1 概述\n  模式设计质量的评价指标：数据冗余度，插入/删除等更新异常\n  为什么要研究关系的规划化设计：规范化的目的与手段\n8.2 规范化理论\n8.2.1 函数依赖（FD）\n  函数依赖的定义\n  如何寻找函数依赖：函数依赖与数据完整性约束的关系\n  完全/部分FD，平凡/非平凡FD，直接/传递FD\n  Armstrong公理系统：3条基本规则 + 3条扩充规则\n  基于函数依赖的关键字定义\n  属性集闭包的计算算法\n  关键字的计算算法\n8.2.2 与函数依赖有关的范式\n  范式定义：1NF，2NF，3NF，BCNF\n  理解各级范式与数据冗余度、插入/删除异常的关系\n8.2.3 多值依赖与第四范式\n  多值依赖，平凡多值依赖，非平凡多值依赖\n  多值依赖与函数依赖的关系\n  4NF\n8.3 规范化所引起的一些问题\n  函数依赖的逻辑蕴涵，函数依赖集的等价\n  最小函数依赖集及其判定方法\n  最小函数依赖集的计算算法\n  模式分解的无损联结性、依赖保持性及其判定方法\n  直接到3NF且满足无损联结性和依赖保持性的模式分解算法\n  从3NF到BCNF、4NF的分解方法\n   概述 好的关系模型设计：有合理的数据冗余度，又没有插入和删除等操作异常现象\n在一个关系中，属性之间的内在依赖有两种：函数依赖与多值依赖\n在每个关系中，属性与属性之间的语义连续需要满足一定的要求，称为关系的规范化\n对属性间所存在的内在语义的不同可以将关系的规范化分为几个等级，称为范式。\n规范化理论 规范化的途径：将一个关系分解成多个子关系\n规范化的途径：\n 竖向规范化：采用投影和联接运算，将一个关系模式的属性集分解成若干个子关系模式，有关理论形成了关系数据库的规范化理论，模式分解理论有：无损联接性和依赖保持性 水平规范化：采用选择和并运算，将一个关系元组集合分解成若干个子集，从而构成若干个与原来关系模式相同的子模式，尚未形成成熟的规范化理论  函数依赖（FD） 函数依赖： 一个关系中两组属性之间的某种取值约束\n给定一个关系R，X和Y是关系R的两个子集，如果说每一个X值都有唯一的一个Y值与之对应(即如果两元组X值相同则Y值相同，反之则不一定)，那么我们说X函数决定Y(Y函数依赖于X)，其中X称为决定因素，Y称为依赖因素\n如果一个函数依赖关系$X \\rightarrow Y$ 满足Y不是X的子集，则称这个函数依赖为非平凡的函数依赖，否则为平凡函数依赖\n在关系函数R(U)中，如果有$X\\subset U,Y\\subset U$,且$X\\rightarrow Y$ ,并且对于任何X的真子集X'有$X'\\nrightarrow Y$ ,则称Y完全函数依赖于X，并记作$X\\overset{f}{\\to} Y$ .如满足前者而不完全依赖则称为部分依赖，并记作$X \\overset{P}{\\to} Y$（注意此处的真子集不是针对元组讨论，而是针对属性讨论）\nArmstrong公理系统 基本规则：\n 自反规则：若Y是X子集，则Y依赖于X 增广规则：如果$X \\to Y$,则$XZ \\to YZ$ 传递规则：如果$X \\to Y$,$Y \\to Z$,则$X \\to Z$  扩充规则：\n 分解规则：如果$X\\to YZ$,则$X \\to Y$ 且$X \\to Z$ 合并规则：如果$X\\to Y$且$X \\to Z$，那么$X\\to YZ$ 伪传递规则：如果$X\\to Y$且$WY \\to Z$,则$WX\\to Z$  如果F是关系的一个函数依赖集，X，Y是R的关系子集，如果能从F中已有的函数依赖出发，根据Armstrong公理系统推出$X\\to Y$,则称F逻辑蕴涵$X\\to Y$ 。记为$F \\models X\\to Y$.所有能被F逻辑蕴涵的函数依赖称为F的闭包，记作$F^+$\n关键字：在关系模式R(U,F)中，如果有$K \\subset U$ 且满足$K \\overset{f}{\\to} U$ ,则称K为关系R的关键字\n在关系R中所有关键字中的属性构成的集合称为主属性集，主属性集中的属性称为主属性，对应的其他属性称为非主属性\n如何寻找关键字：\n 利用Armstrong公理系统推导 利用属性集闭包的概念，寻找满足$K_F^+ = U$ 的最小属性集合K 利用最小函数依赖集来优化方法二  属性集闭包：$X_F^+ = {A | F\\models X\\to A}$\n计算属性集X在函数依赖F上的闭包算法（就是对于F中的每一个依赖关系的决定因素，如果决定因素是X+的子集就把对应的依赖因素加入X+，一直重复循环到无法有加入为止）\n输入：关系模式R(U,F),属性集X X+ := X; repeat oldX+ := X+; for each functional dependency Y\\to Z in F do if Y\\subset X+ then X+ := X+ \\cup Z; until ( oldX+ = X+ ) return X+; 寻找关键字的方法二:设置初始关键字K为U，对于K中的每一个元素A，考虑(K-A)之后的属性闭包集，如果为U那么删去A\n对于方法二的优化：考虑根据最小函数依赖集F，只出现在函数依赖左边或者没有出现在函数依赖关系中的为$U_L$,只出现在右边过的为$U_R$，两边都出现过的为$U_A$。考虑到$U_R$的属性不可能出现在任何一个关键字中，而$U_L$中的属性必然是关键字，所以设置初始关键字为$U-U_R$,然后对$U_A$中的每个元素进行判断即可\nset K := U－UR ; for each attribute A in UA { compute $(K – {A})_F^+$ ; if $(K – {A})_F^+$ contains all the attributes in R then set K := K – { A } ; } return K ; 与函数依赖有关的范式 第一范式：关系R(U)中的每个属性都不可分割，则称关系模式满足第一范式。每一个关系都必须满足第一范式1NF\n第二范式：如果有关系$R(U) \\in 1NF$,且其每个非主属性都完全函数依赖于关键字，则称关系满足第二范式（判断第二范式：判断每一个非主属性A与每一个关键字之间是否存在部分函数依赖）\n不满足第二范式的：存在非主属性对关键字的部分函数依赖导致出现了数据冗余导致了产生更新异常\n模式分解：如果存在一组子关系模式 { R1, R2, …, Rk } 满足下述的两个条件，则我们称 { R1, R2, …, Rk } 是关系模式R的一个分解 (Decomposition)：\n $Head(R) = Head(R1)\\cup Head(R2) \\cup … \\cup Head(Rk)$ 设子关系Ri上的函数依赖集为Fi (i=1,2,…,k), 则：$Fi = { X\\to Y | X\\to Y \\in F+ 且 (X∪Y)\\in Head(Ri) }$  模式分解的办法：\n  找出所有不满足范式M要求的函数依赖关系\n  选择一个不符合要求的函数依赖关系作如下的分解：假设 $X\\overset{f}{\\to}Y \\in F+$ 且不满足范式M的要求，则我们将关系模式R分解为如下的两个子关系：\n $R1 ( X\\cup Y, { X\\to Y } )$ $R2 ( Head(R) – Y, F2 )$，其中：$F2 = { A\\to B | (A \\to B) \\in F+ 且 (A∪B)\\subset Head(R2) }$    对于分解得到的子关系模式R2重复上述的步骤1)和步骤2)，直到所有的子关系模式都能满足范式M的要求\n合并那些具有相同关键字的子关系模式\n  对于2NF，要找到的分解出来的依赖关系是$X\\overset{f}{\\to} Y$,其中X是某个候选关键字的真子集，Y是非主属性\n考虑到模式分解的基础是函数依赖集F，而F不是一个最小函数依赖集的情况下，要将关键词相同的子模式合并，故而可以将分解的方法优化为$Head(R1)=X+,Head(R2)=(Head(R)-X+)\\cup X$,其各自的依赖集中属性在Head中\n第三范式：有关系$R(U)\\in 2NF$,且其每个非主属性都不传递函数依赖于关键字，则称关系模式R(U)满足第三范式\n如果关系$R\\notin 3NF$，那么在关系R中必然存在以下形式的函数依赖$X\\overset{f}{\\to} Y $，其中：依赖因素Y是单个的非主属性，而决定因素X则是以下的两种情况之一：\n X是关系R的某个关键字的真子集($R\\notin 2NF$) X并不是关系R的关键字($R \\notin 3NF$ )  BCNF:若关系R(U)满足1NF，且若$X\\to Y$时X必含有该关系模式的关键字，则称其满足BCNF\n满足BCNF的必然是3CNF，但是满足3CNF的不一定是BCNF\n多值依赖与第四范式 多值依赖(MVD): 设有关系模式R(U)，X, Y是U的子集,如果关系模式R(U)满足下述要求：对X的一个确定值，存在Y的一组值与之对应；且Y的这组值又与关系中的其他属性(U-X-Y)(此处是减号)的取值不相关。此时称Y多值依赖于X，并记为：X→→Y\n如果$U-X-Y$是不是空集，则为非平凡的多值依赖，否则为平凡的空值依赖\n多值依赖的性质：\n 如有 X→→Y，则必有 X→→(U-X-Y) 如有 X→Y，则必有 X→→Y (函数依赖是一种特殊的多值依赖)  多值依赖的推导规则：\n 规则 IR1(自反规则)：如果Y是X的子集，则： X → Y 规则 IR2(增广规则)：如果 X → Y，则：XZ → YZ 规则 IR3(传递规则)：如果 X → Y，Y → Z，则：X → Z 规则 IR4(求补规则)：如果 X→→Y，则 X→→(U–X–Y) 规则IR5(多值依赖的增广规则)： 如果 X→→Y 且 $W\\supseteq Z$，则 WX→→YZ 规则IR6(多值依赖的传递规则)：如果 X→→Y，Y→→Z，则 X→→( Z – Y ) 规则IR7(转换规则)：如果 X→Y，则 X→→Y 规则IR8(结合规则)：如果 X→→Y, 且存在另一个属性集合W满足：$W\\cap Y = \\emptyset, W\\to Z, Y \\supseteq Z$, 则：X→Z  第四范式：如果在关系模式$R(U)$中，$X\\to\\to Y$ 是非平凡多值依赖，则X必含有关键字，则称R满足第四范式\n满足第四范式的必然满足BCNF，同时意味着对于不是函数依赖的多值依赖必须是平凡多值依赖\n规范化所引起的一些问题 如果两个函数依赖集的闭包相等，则称这两个函数依赖集等价\n与函数依赖集F相等价的所有函数依赖集中最小者被称为函数依赖集F的最小函数依赖集(也称最小覆盖)\n输入函数依赖集F，找到与F等价的最小的函数依赖集G：\n 消除F中的部分函数依赖，转变为完全函数依赖 消除冗余的函数依赖 以上两部顺序可以对调，但是将部分函数依赖转变为完全函数依赖过程中可能产生新的冗余函数，所以如果先消冗余需要再最后再检查一遍有无冗余函数依赖  具体算法如下： 1. 令 G := F 将 G 中每一个形如 $X\\to (A1,A2,…,An)$ 的函数依赖替换为如下一组依赖因素为单个属性的函数依赖：$X\\to A1, X\\to A2, …, X\\to An$\n 对 G 中的每一个函数依赖 $X\\to A$ 作如下的处理： 对决定因素 X 中的每一个属性 B 作如下处理： 计算属性集的闭包 $(X – B)_G^+$； 如果 $A\\in (X – B)G+$, 则用新的函数依赖 $(X – B)\\to A$ 替换原来的函数依赖 $X\\to A$; 对 G 中的每一个函数依赖 $X\\to A$ 作如下处理： 令 $N := G – { X\\to A }$ ; 计算属性集的闭包 $X_N^+$ ; 如果 $A\\in X_N^+$ , 那么从G中删去函数依赖 $X\\in A$； 将 G 中每一组形如 $X\\to A1, X\\to A2, …, X\\to An$(决定因素相同)的函数依赖合并为一个函数依赖: $X\\to (A1,A2,…,An)$  无损联接性:分解后，原关系中的信息不会丢失.设R是一个关系模式，F是关系模式上R的函数依赖集，$\\rho ={R1,R2,…,Rk}$ 是对R的一个分解。如果对R中满足F的每一个关系实例 r 都有：$r = \\pi_{R1}(r)\\bowtie \\pi_{R2}(r) \\bowtie …… \\bowtie \\pi_{Rk}(r)$ 则称该分解 $\\rho$ 相对于F是“无损联接分解”，或称分解 $\\rho$ 具有无损联接性。\n如果R的分解为 $\\rho = {R1,R2}$，F为R所满足的函数依赖集合，分解$\\rho$具有无损联接性的充分必要条件是：$R1 \\cap R2 \\to (R1 – R2)$ 或 $R1 \\cap R2 \\to (R2 – R1)$\n依赖保持性：原有的函数依赖关系再分解后的关系模式上仍然存在.用 $\\pi_Z(F)$ 来表示函数依赖集F在子关系Z上的投影： $\\pi_Z(F) = { X\\to Y | X\\to Y\\in F+ 且 (X∪Y) \\subseteq Z }$ 如果有：$F+ = (\\pi_{R1}(F) \\cup \\pi_{R2}(F) \\cup … \\cup \\pi_{Rk}(F))^+$. 则称 “分解具有依赖保持性”\n在必须同时满足无损连接性和依赖保持性的要求下，一个关系模式最高可以被分解到满足3NF,分解方法如下：\n   计算F的最小函数依赖集，并用来代替F进行下面的模式分解;     $S = \\emptyset$ ;     对 F 中的每一个函数依赖 $X\\to Y$ 做如下处理： 如果在集合 S 中找不到满足下述条件的子关系模式Z:$X\\cup Y \\supseteq Heading (Z) $,则由X和Y合并构成一个新的子关系模式并加入到集合S中     如果关系 R 的每一个候选关键字 K 都没有出现在分解后的子关系模式中，即：找不到一个原关系R的关键字K和一个子关系模式 Z，且他们之间满足 $K \\subseteq Heading(Z)$ 那么，就从关系R中任选一个候选关键字K, 由K中的属性单独构成一个子关系模式并加入到集合S中去。    ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/normal-form/","tags":null,"title":"关系数据库规范化理论"},{"categories":null,"contents":" 他们只有激起较根深蒂固的团结一致感和身份认同，才能创造一场社会运动。因此，我们几乎可以肯定，作为运动组织的基础，民族主义和种族或宗教总是比社会阶级的绝对律令更可靠，原因就在于它们能促进团结一致和集体认同。 ——西德尼·塔罗\n 什么是政治参与 政治参与通常是指公民通过正式途径影响统治者或公共决策的行动与过程。当然，有人认为，非正式途径的参与（甚至是突破现有法律框架的参与）也是政治参与的重要内容。\n政体类型与政治参与 通常，民主政体下政治参与的数量和程度是适中的。在民主政体下，政治参与是公民个人的自由选择。当然，个别国家有强制投票的规定，法律规定这是公民的法定义务，但这也仅限于选举投票。\n威权政体下的政治参与程度要比民主政体低很多，大量民众没有卷入政治参与活动。即便有政治参与，通常情况下这种政治参与有可能是被操纵的。主要目标是为了维护统治者的权力，是为了制造民主的假象。\n极权政体是一种高度动员的政体类型，所以该政体下政治参与程度是很高的。这种政治参与的特点是高度的组织化。极权政体下的政治参与，往往与改造社会有关。特点是存在着受到政府或政党严格控制的高度的政治参与。\n投票与选举权的普及 公民政治参与的基本形式就是选举投票。民主政体下的公民通过投票来选择反映自己政治偏好的政治家，投票是公民控制政府和落实问责制的基本形式。\n法国从1789年大革命到19世纪晚期、再到20世纪上半叶的政治变迁中，其投票权经历了“有产公民模式”到成年男子普选权，再到包括妇女在内的成年公民“一人一票”的演进。\n造成政治冷漠现象的原因：\n 理性选择理论强调，不少比例的选民不参加投票是其理性决策的结果。选民参加投票通常需要支付成本——比如参加投票的时间和交通费用等，但一张选票通常并不会改变选举结果，其边际影响微乎其微。 关于政治冷漠的政治文化理论则强调民主精神与公民文化的衰退。也就是说，人们从价值观和信念上更少关心公共事务了。这也是很多社会较为普遍的现象。  社会运动与非暴力抗争 社会运动是政治参与的一种重要形式。除了选举投票，社会运动是很多普通公民卷入过的最重要的政治活动。社会运动一般是指一种特定形式的集体行动或集体行为，其动机主要来源于成员的态度和期望，通常有松散的组织框架，具有明确的诉求。社会运动一般被视为社会抗争的一种表现形式。\n任何非暴力运动，都要包括四个阶段：收集事实，以判定不公正是否存在；谈判；自我净化；以及直接行动。\n如何理解社会运动   西德尼·塔罗：社会运动是“以潜在社会网络和使人产生共鸣的集体行动框架为基础，能发展出对强大对手保持持续挑战力的斗争（抗争）政治事件”\n 社会运动的基本特征：  集体挑战 共同目标 团结和集体认同 持续的斗争（抗争）政治      查尔斯·蒂利：社会运动有三个主要的特征\n 是一种不间断和有组织地向目标当局公开提出群体性的诉求声张，表现为运动的形式。 它有一系列的常备剧目，包括为特定目标组成的专门协会和联盟，经常举行的公开会议，依法示威游行，大型集会，请愿活动，各种各样的声明，用于专题宣传的小册子，等等。 社会运动中的参与者协同一致地表现出特定的价值（Worthiness）、统一（Unity）、规模（Numbers），以及参与者和支持者所作的奉献（Commitment）    怨愤理论，或者叫相对剥夺感理论。就是说，社会运动之所以发生，是社会上有一部分人口受到了严重的不公待遇或剥削。一个社会中有人占有很多，有人占有很少，后者会产生强烈的相对剥夺感。\n 但该理论没有很好解释一个问题，即社会运动的领导和组织问题。相对剥夺感固然为社会运动准备了社会条件，但按照曼瑟尔·奥尔森的说法，这里仍然无法解决搭便车的问题。换句话说，社会上是否有人不满并不重要，重要的是能不能把不满的人群动员和组织起来。所以，这一观点认为，能否解决资源动员和资源组织问题是理解社会运动的关键。    安东尼奥·葛兰西认为社会运动的核心问题是构造集体认同。后来，这一观点被发展为一种集体认同的理论。\n  基于新古典经济学的集体行动理论：曼瑟·奥尔森《集体行动的逻辑》：集体行动始终存在一个搭便车的问题。在集体行动中搭便车是常见现象，克服搭便车问题的关键是能不能提供选择性激励，而一般的社会运动通常难以有效提供选择性激励。\n  市民社会理论 公民社会大体上说有两个含义\n 第一个含义是指私人领域，这里既可以指不包括家庭的私人领域，也可以指包括家庭的私人领域。这里的私人领域是与政治社会相对的。所以，这个含义上的公民社会，几乎等同于整个的私人领域。 第二个含义是指第三部门，一般是指非营利组织和非政府组织所处的领域，也就是既非市场部门又非政府部门的一个领域。这种含义上的公民社会所具有的特征是，它既不受国家权力的控制，又不受商业利益的支配。  公民社会的主要特征：\n 公民社会具有明显的自主性。公民社会跟私人领域有关，独立于国家权力和国家控制，因而具有充分的自主性。 公民社会具有比较强的组织性。公民社会的一个显著特征是它以各种社会团体的形式呈现出来，特别是经常提及的非营利组织和非政府组织。 公民社会看上去属于私人领域，但它又有一定的公共性。公民社会的很多社团都会积极介入到公共领域中，它们试图影响政治社会。 民社会中存在着大量的集体行动，而社会运动是集体行动的一种方式。公民社会，其实是社会运动存在的一种有利空间。  公民社会的发达有利于公民自治能力的发展。这意味着公民获得了独立于国家或政府的组织化的参与方式，因而有利于塑造民主政治的社会条件；反之，则不利于塑造民主政治的社会条件。\n戴维·赫尔德:能否重新构建有效的市民社会，是民主政治得以有效运转的关键。“由于公民社会之正式和非正式组织的成长，以及它们的能力、资源、自主性和主动性的增强——所有这些能够极大地改变权力的平衡……曾经轻松地处于主导和控制地位的威权政府被迫处于防守地位。……在世界的很多地方，上述独立组织的能力和数量的提升才是民主真正的本土根源“\n如果说发育健全的市民社会有利于民主的运转和巩固，但非民主政体又往往不利于健全的市民社会的成长，这就使得两者的关系陷入了某种困境。\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap9/","tags":null,"title":"如何参与，如何抗争"},{"categories":null,"contents":" ppt上的概念怎么回事，基本运算的逻辑符号 与逻辑表达式认识就够了\n 数字逻辑 数字集成电路的分类\n 根据结构特点和输入信号的响应规则的不同  组合逻辑电路与时序逻辑电路   器件不同  TTL和CMOS电路    数字集成电路的特点\n  电路简单，便于大规模集成，批量生产\n  可靠性、稳定性和精度高，抗干扰能力强\n  体积小、通用性高、成本低\n  可编程性\n  高速度、低功耗\n  加密性好\n  模拟信号：时间、数值连续变化\n  数字信号：时间、数值均离散\n  由于数字信号便于储存分析传输，通常将模拟信号通过模数转换器转换为数字信号\n  数字信号的描述方式 二值数字逻辑与逻辑电平 二值数字逻辑：0、1编码\n表示方式：用高电平表示1，低电平表示0\n数字波形：信号逻辑电平对时间的图形表示\n 非归零型 归零型(1个时间拍内归零)  比特率：每秒钟传输数据的位数\n周期：两个相邻脉冲之间的时间间隔\n脉冲宽度($t_W$): 脉冲幅值的50%的两个时间所跨越的时间\n占空比：脉冲宽度占整个周期的百分比\n上升时间和下降时间：从脉冲幅值的$10%$到$90%$上升下降的时间(ns)\n二进制 进位规律：逢二进一\n优点：\n 易于电路表达 所用元件少，电路简单可靠 运算规则简单  传输：\n 串行传输 并行传输：将一组二进制的所有位同时发送  二值逻辑变量和基本逻辑运算 逻辑运算：二进制数码按照某种特定的因果关系进行运算，使用的数学工具是逻辑代数\n逻辑代数中，有与、或、非三种基本运算\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/","tags":null,"title":"数字逻辑"},{"categories":null,"contents":"多媒体网络 9.1 多媒体网络应用 视频最显著的特点：高比特率\n9.2 流式存储视频 流式存储视频：UDP流、HTTP流、适应性HTTP流\n广泛应用客户端应用缓存，以此缓解变化的端到端时延和变化的服务器和客户之间带宽量的影响\nB：用户应用缓存的长度 Q: 客户应用缓存开始播放之前必须被缓存的比特数 r: 视频消耗速率 x：服务器以恒定速率发送比特，也可以是和时间相关的x(t)\n9.5 支持多媒体的网络 对多媒体应用提供网络层支持：\n 尽可能利用尽力而为服务：公平处理所有流量 区分服务：不同类型流量处理不同 **每连接服务质量(QoS)**保证：每个源到目的地流处理不同，每个应用显式的预约端到端带宽，并因此具有确定的端到端性能。  每连接服务质量保证  标记分组是为了路由器区分不同类型流量的分组 希望在流量类型之间提供流量隔离的度，以便一类流量不会受到另一类流量的负面影响 当为流量类型之间提供隔离的时候，希望尽可能有效的使用资源 如果不总是能够提供充分的资源，并且要确保QoS，则需要一个呼叫准入过程，在这个过程中申告其QoS需求，要么被网络准入，要么无法提供而被网络阻塞  监管：漏桶 分组进入令牌等待队列，在漏桶处取得令牌的分组被发送，桶高度不超过b，每秒生成r个令牌加入桶\n平均速率：r+b/t(长期后为r)\n突发长度：b\n要限制峰值速率：在后面串联一个高度为1的桶，速率r’限制峰值速率\n漏桶+加权公平队列 $$d_{max}=\\frac{b_1}{R*\\frac{w_i}{\\sum w_j}}$$\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/duo-mei-ti-wang-luo/","tags":null,"title":"多媒体网络"},{"categories":null,"contents":"数据库设计  9.1 数据库设计概述\n  数据库设计的基本任务\n  数据库的生命周期\n9.2 数据库设计的需求分析\n  需求说明书\n9.3 数据库的概念设计\n  数据库概念设计的过程\n  E-R模型与扩充E-R模型的设计\n9.4 数据库的逻辑设计\n  从E－R模型和扩充E－R模型向关系模型的转换\n  对转换得到的关系模式进行规范化设计\n 根据给定的数据完整性约束发现函数依赖（最小函数依赖集） 关键字的计算 范式的判断及分解  9.5 数据库的物理设计\n  索引的作用及其设计策略\n   数据库设计概述 设计的基本任务：\n 根据用户对象的信息需求(用户的数据、结构及其要求)、处理需求(用户对数据的处理过程和方式)和数据库的支持环境(包括硬件、操作系统、DBMS)设计出数据模式 在一定平台制约下，根据信息需求和处理需求设计出性能良好的数据模式  数据库设计的生命周期法：需求分析、概念设计、逻辑设计、物理设计、编码、测试、运行、进一步修改\n其中数据库设计的四个阶段：需求分析、概念设计、逻辑设计、物理设计\n数据库设计的需求分析 确定需要在数据库中保存其信息的客观事物及其相互关系\n可以从三个角度分析数据库的数据需求：\n Things Atrributes Relationships  数据库的概念设计 数据库概念设计的过程：\n 用户分解：首先将所有用户划分为功能相对独立的若干个用户组，然后针对每个用户组进行视图设计。 视图设计：针对每个用户组设计其数据视图，以反映该组用户对于数据的需求。 视图集成：将设计好的若干个局部数据视图集成为一个完整的全局数据视图。  确定所采用的原理与策略 规划视图的集成步骤 发现并解决可能存在的冲突现象    视图集成的原理与策略：\n 等同：指两个或多个数据对象具有相同的语义。包括：属性等同，实体等同，语义相关等同(属性-实体)。如同义同名，同义异名 聚合：数据对象之间的一种组成关系。  由属性聚合成实体 由属性和实体聚合成新的实体   抽取: 将不同实体中的相同属性提取成一个新的实体，并构造成具有继承关系的结构。 常见的几种冲突现象（通过视图修改来解决）  命名冲突:同义异名，同名异义。通过重命名来实现 “同名同义，异名异义” 概念冲突：同一概念在一处为实体，而在另一处则为属性或联系。解决方式：统一为同一个概念（一般为“实体”） 域冲突：例如类型冲突，度量单位的冲突。解决方式：统一 “数据类型” 和 “度量单位” 约束冲突。解决方式：统一数据约束。如果无法统一数据约束，可以视情况来处理：1）如果不同数据约束的语义之间有包含关系，可以尝试构建具有‘父子’关系的继承层次结构，子类可以有比父类更严格的数据约束。2）构建不同的实体集    E-R模型：实体、属性、联系\n扩充E-R模型的设计：属性、实体、联系、嵌套、继承\n数据库的逻辑设计 任务：将前一阶段得到的概念数据模型转换成用户所选择的数据库管理系统支持的逻辑数据模型\n从E－R模型和扩充E－R模型向关系模型的转换：\n 每个实体集被转换成一个关系（模式）。关系及其属性的命名采用原实体集及其属性的名称。实体集的标识属性为关系中的关键字 在一般情况下，每个联系也被转换成一个关系模式，联系名被用作转换得到的关系模式的关系名，该关系模式中的属性由两部分组成：联系自身所具有的属性与该联系相关的实体集的标识属性。来自于相关实体集的标识属性也是相关实体集转换得到的关系模式的主关键字，因此它们也是联系转换得到的关系模式中的外关键字  命名与属性域的处理 关系及属性的命名：\n 尽量采用在EE-R模型中原有的名称 可以重新命名，但要避免命名的冲突现象：在同一个数据库模式中，关系名具有唯一性；在同一个关系模式中，属性名具有唯一性  属性域的定义：根据DBMS的选型进行必要的数据类型转换\n非原子属性处理 集合属性：关系模式不变，但原有关系的一个元组将被纵向展开成多个元组。在上述转换过程中，虽然实体集(或关系模式)中的属性没有增加，但转换得到的关系模式的主关键字由原实体集的标识属性和该集合属性联合构成（红色的属性名集合）。如一个学生对应多门课程，展开后，学号和课程名的组合构成了新的关键字\n元组属性:将一个元组属性横向展开成多个属性.如一个圆对应了半径和圆心(圆心包括x轴，y轴),就将其展开为半径、x轴、y轴\n联系的特殊转换 在一般情况下，一个联系可以被转换成一个关系。但是在有些情况下,联系也可被归并到相关联的实体所对应的关系模式中去，即将联系与某个(或几个)相关联的实体集共同转换成一个关系模式。（考虑是否全参与）\n考虑以下的关系：E1(有属性k1,a),E2(有属性k2,b),(其中k1,k2为两者的关键词)两者之间的联系R(有属性r)，考虑参与基数（下面前者为E1，后者为E2）：\n (0,1)(0,1):即都是非全参与，且关系为1:1,此时分解为三个关系模式：E1(k1,a),E2(k2,b),R(k1,k2,r) (1,1)(0,1):一个全参与一个非全参与，关系1:1,此时分解成两个模式：E1(k1,a,k2,r),E2(K2,b) (1,1)(1,1):即都是全参与，且关系为1:1,此时分解为一个关系模式：E(k1,a,k2,b,r) (?,n)(1,1):关系为一对多，一的这一方全参与，此时分解为两个：E2(K2,b，k1,r),E1(k1,a) (?,n)(0,1):关系为一对多，一的这一方非全参与，此时分解为三个关系模式：E1(k1,a),E2(k2,b),R(k1,k2,r) (?,m)(?,n)：关系为多对多，此时分解为三个关系模式：E1(k1,a),E2(k2,b),R(k1,k2,r)  继承的转换 可以有三种转换方式：\n 每一个实体集都将被转换为一个关系 只有最底层的叶子结点才会被转换为关系，并从其所有超实体集中继承属性。 被转换为单个关系，其中含有所有实体集中的属性。  规范化 通过关系数据库的规范化过程，使设计得到的结果关系模式至少需满足第三范式(3NF)\nRDBMS性能调整 为满足RDBMS在性能、存储空间等方面的要求及其它限制条件所做的调整与修改。包括：\n 逆规范化：减少关系的连接运算次数，提高系统性能 关系的分割：调整每个关系的大小，提高存取效率  水平分割：将一个关系的元组集合划分为若干个不相交的子集，每个子集对应一个子关系模式 垂直分割：将一个关系模式纵向分解成若干个子关系模式（不同于规范化设计中的模式分解）   尽量使用快照  快照(snapshot)：用数据查询命令定义，在创建快照时就执行对应的子查询，并将查询结果以‘实’关系的形式保留在数据库中。 快照的维护：周期性地刷新 / 由用户手工刷新    约束条件设置  完整性约束 安全性约束 数据类型约束 数据量的约束 重新设置每个表的候选键、主键及外键  关系视图的设计 在关系模式基础上所设计的直接面向操作用户的视图即用户的’外模式’，它可以根据用户的需求随时构作，一般 RDBMS 均提供关系视图的功能。\n关系视图的作用\n 提供数据的逻辑独立性 能适应用户对数据的不同需求 有一定数据保密功能  数据库的物理设计 对数据库内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度及有效利用存储空间\n在关系数据库设计中，用户参与物理设计的内容有：存取方法的设计 与 存储结构的设计\n索引 考虑设计的因素：\n 在主关键字及外关键字上建立索引：提高关系联接查询的速度，有利于实体完整性及引用完整性的检查 以读为主的关系应尽可能多地建立索引 如果根据某属性的等值查询所得到的结果元组数量较少，则可以考虑对该属性建立索引 对经常用于统计查询的属性建立索引：可以根据索引数据直接获取统计结果，不必再去访问对应关系的数据块。  ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/db-design/","tags":null,"title":"数据库设计"},{"categories":null,"contents":" 一个稳定的和有效率的民主政府，不光是依靠政府结构和政治结构：它依靠人民所具有的对政治过程的取向——即政治文化。除非政治文化能够支持民主系统，否则，这种系统获得成功的机会将是渺茫的。 ——加布里埃尔·A.阿尔蒙德与西德尼·维巴\n 政治文化与政治社会化 鲁恂·派伊：政治文化是一组态度、信仰和情感，它赋予政治过程以秩序和含义，并提供一种基本的假设和规则用以规范政治体系中的行为。它包裹着政治观念和政制运行的规则。因此，政治文化是对政治中心理和主观层面的一种集合形式和表述\n安德鲁·海伍德：政治学家在更为狭隘的意义上用该词来指人们的心理倾向，政治文化就是针对政党、政府和宪法等政治客体的倾向模式，并表现为信仰、符号和价值。\n英美国家的民众不认为政党能代表全体。\n讨论政治文化，还需要理解政治社会化问题，这是指对政治文化习得的过程，包括政治认知、态度、价值观与行为的习得。\n托克维尔论政治文化 托克维尔在《论美国的民主》中阐述了大量与政治文化有关的内容，他甚至把政治文化视为美国民主政体得以稳固的基本原因。\n“它（民情）不仅指通常所说的心理习惯方面的东西，而且包括人们拥有的各种见解和社会上流行的不同观点，以及人们的生活习惯所遵循的全部思想。”\n托克维尔在书中总结道，对于维护美国的民主政体，“自然环境不如法制，而法制又不如民情”。这里的民情，当然是指政治文化。\n阿尔蒙德与公民文化 托克维尔研究美国政治文化是基于经验观察。美国学者加布里埃尔·阿尔蒙德和西德尼·维巴的重要贡献则是在政治文化研究中引入了问卷调查和定量分析的方法。\n政治文化之所以重要，在阿尔蒙德和维巴看来，政治文化是微观的政治和宏观的政治之间的连接纽带。通过研究政治文化，特别是从微观层次上观察公民个体的政治行为、信念与倾向，可以发掘出一个国家民主或不民主这一宏观政治现象的成因。他们认为，可以用政治文化来解释从微观的个体行为到宏观的政治现象之间的机制。换句话说，这些个体拥有什么样的政治文化，会影响到民主政体能否维系或实现稳定。\n政治文化的三种不同类型：\n 村民文化（paro-chial culture）。这里的村民概念，强调的是他们的活动范围和视野都局限在一个非常小的范围之内，也只关心极小范围内的一些事情。- 臣民文化（subjectculture）。这种文化的直接表现是政治上比较消极，这些人认为普通民众是无力影响政治的，他们具有更好的服从权威的意识 参与者文化（participantculture）。这种文化强调公民意识，这些人关心政治，正如美国新英格兰的乡镇居民一般。他们通常是政治积极分子，希望参与政治，希望通过政治参与来改善公共治理。  他们认为公民文化有利于民主政体的稳定。公民文化是参与者文化、臣民文化和村民文化三者的混合。阿尔蒙德认为，公民文化有时明显地包含着互相矛盾的诸种政治态度，但这似乎特别适合于民主政治系统，原因在于民主政治系统也是一种矛盾的混合体。简单地说，身为民主政体下的公民，理想状态应该是：该参与的时候就要参与，该服从的时候就要服从；该积极的时候就要积极，该消极的时候就要消极。当公民文化把这三种东西结合起来时，最有利于民主政体的维系和稳定\n英格尔哈特：政治文化的集大成者 研究的核心问题是：在工业化国家，经济社会变迁和现代化会对政治文化产生何种影响？\n按照托克维尔对美国乡镇治理的观察，人际信任会影响一个国家公民的自治能力。越是人际信任度高的国家，越有可能发展出自治的治理方式；越是人际信任度低的国家，越有可能产生威权领导人和政治压制的统治方式。\n按照英格尔哈特的研究，人际信任程度跟人均GNP也有相关性，但这种关系并不那么确定。总的来说，人均GNP高的国家，人际信任度也较高。但同时人均GNP并不能决定人际信任度\n一个国家的公民文化跟三个因素呈现显著的相关性：生活满意度、人际信任度和支持激进变革的程度，相关度分别高达0.79、0.81和0.60\n随着西方发达工业国家1973—1988年间（更早可以追溯至20世纪50年代）的经济社会发展，大众的价值观念发生了重大的变化，开始从“物质主义”价值观转向“后物质主义”价值观。英格尔哈特认为，这是由于二战之后西方发达国家获得了相对持久的和平和前所未有的经济繁荣，这样大众不再把已经实现的经济安全作为首要选项，而开始转向后物质主义的需要和诉求\n（物质主义：经济安全、人身安全。后物质主义：归属与自尊、审美和知识）\n 经济发展、文化转型和政治转型以一种有着内在联系的、大体可预测的模式共同出现，社会经济转变的某些轨迹远远比其他轨迹更明显。\n但是转变是非线性的。在发达工业国家里，主流发展方向是从现代化转变到后现代化。这条新的轨迹使得对作为工业国家标志的功能理性的强调出现衰退，而对自我表现和生活质量的强调在增加。随着后现代主义价值观日渐扩散化，从妇女权利平等到民主政治制度的各种社会转变，以及国家社会主义政权的衰落，都变得日益可能。随着后现代化进程的推进，一种新的世界观正在逐步替代工业革命以来一直支配工业化国家的信仰框架。它反映了某个问题上的态度转变，即人们到底渴望从生活中得到什么这一问题。它正在转变那些支配政治、工作、宗教、家庭和性行为的基本规范。\n 社会资本理论的兴起 罗伯特·帕特南《使民主运转起来》：社会资本指的是普通公民的民间参与网络，以及体现在这种约定中的互惠和信任的规范。社会资本是指社会组织的特征，诸如信任、规范以及网络，它们通过促进合作行为来提高社会的效率。\n福山认为社会资本是——群体成员之间共享的非正式的价值观念、规范，能够促进他们之间的相互合作。如果全体的成员与其他人将会采取可靠和诚实的行动，那么他们就会逐渐相互信任。信任就像是润滑剂，可以使人和群体或组织更高效的运作。\n社会资本大概有几个主要特征：首先，它不是正式的制度安排；第二，它存在于人与人之间、群体与群体之间的网络之中；第三，它总体上跟人际互动、互惠机制、合作互助、信任关系这些东西有关。\n《让民主运转起来》：在一个具有良好公民共同体传统的社会，自愿合作更容易出现，互相信任更有可能，互惠网络更容易形成\n社会资本理论也遭到很多批评：\n 如何衡量社会资本？这是社会资本研究需要回应的挑战，尽管有人做了很多努力来衡量社会资本，但衡量和测定社会资本的挑战仍然是很大的。 社会资本这个概念由于缺少明确所指，容易被拿来作为一个可以蒙混过关的解释变量。究竟什么是社会资本？有学者认为，从帕特南到科尔曼都没有说得很清楚。这样，社会资本这一概念容易成为一个包罗万象的框。  ","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap10/","tags":null,"title":"政治文化真的起作用吗？"},{"categories":null,"contents":" 逻辑门电路：基本参数知道叫什么，不要求分析，但是反相器，与非门，或非门的电路要认识（不要求异或门），传输门要知道怎么回时，不要求分析TTL的工作分析，但是看到要认识\n 逻辑门电路 逻辑门：实现基本逻辑运算和复合逻辑运算的单元电路\n逻辑门电路的分类\n 分立门电路  二极管门电路 三极管门电路   集成门电路  MOS门电路  NMOS门 PMOS门 CMOS门   TTL门电路    一般特性 输入和输出的高低电平 噪声容限：保证输出电平不变的情况下，输入电平允许波动的范围，表示门电路的抗干扰能力 输入高电平的噪声容限$V_{NH}=V_{OH(min)}-V_{IH(min)}$\n输入低电平的噪声容限：$V_{NL}=V_{IL(max)}-V_{OL(max)}$\n传输延迟时间 表征门电路开关速度的参数，说明门电路在输入脉冲波形作用下，输出波形相对于输入延迟了多久的时间\n功耗 静态功耗：门电路没有状态转换时的功耗，即电源总电流$I_D$和电源电压乘积\n动态功耗：指电路输出状态转换时的功耗\n对于TTL而言，静态功耗是主要的\nCMOS的静态功耗很低，有动态功耗\n延时-功耗积 速度功耗综合性指标，用DP表示\n扇入与扇出数 扇入数：取决于逻辑门的输入端个数\n扇出数：在正常工作情况下，所能带同类门电路的最大数目\nMOS开关与等效电路 CMOS反相器 CMOS逻辑门 CMOS传输门(双向模拟开关) TTL逻辑门 ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/","tags":null,"title":"逻辑门电路"},{"categories":null,"contents":"Ramsey theory Ramsey's theorem ramsey's theorem for graph Let $ k,\\ell $ be positive integers. Then there exists an integer $ R(k,\\ell )$ satisfying: If $ n\\geq R(k,\\ell )$, for any coloring of edges of $ K_{n}$ with two colors red and blue, there exists a red $ K_{k}$ or a blue $ K_{\\ell }$ .\nRamsey's Theorem (graph, multicolor) Let $ r,k_{1},k_{2},\\ldots ,k_{r}$ be positive integers. Then there exists an integer $ R(r;k_{1},k_{2},\\ldots ,k_{r})$ satisfying: For any $ r$ -coloring of a complete graph of $ n\\geq R(r;k_{1},k_{2},\\ldots ,k_{r})$ vertices, there exists a monochromatic $ k_{i}$-clique with the $ i$ th color for some $ i\\in {1,2,\\ldots ,r}$.\nramsey number $ R(k,\\ell )\\leq {k+\\ell -2 \\choose k-1}$\nramsey's theorem for hypergraph Ramsey's Theorem (hypergraph, multicolor) Let $ r,t,k_{1},k_{2},\\ldots ,k_{r}$ be positive integers. Then there exists an integer $ R_{t}(r;k_{1},k_{2},\\ldots ,k_{r})$ satisfying: For any $ r$ -coloring of $ {[n] \\choose t}$ with $ n\\geq R_{t}(r;k_{1},k_{2},\\ldots ,k_{r})$, there exist an $ i\\in {1,2,\\ldots ,r}$ and a subset $ X\\subseteq [n]$ with $ |X|\\geq k_{i}$ such that all members of $ {X \\choose t}$ are colored with the $ i$th color.\nApplications \u0026quot;Happy Ending\u0026quot; problem Yao's lowe bound on implicit data structures ","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/ramsey-theroy/","tags":null,"title":"Ramsey Theroy"},{"categories":null,"contents":" 如果要用一个对句来概括我们的民族原则，我们可以说：如果民族原则是用来把散居的群体结合成一个民族，那么它就是合法的；但若是用来分裂既存的国家，就会被视为非法。——莫里斯·布洛克\n  它（民族）是一种想象的政治共同体——并且，它是被想象为本质上是有限的，同时也享有主权的共同体。——本尼迪克特·安德森\n 什么是民族主义 安东尼·史密斯《民族主义：理论、意识形态、历史》：民族主义是一种为某个群体争取和维护自治、统一和认同的一种意识形态运动。该群体的部分成员认为有必要组成一个事实上的或潜在的一种“民族”。“民族主义的基本目标有三个：民族自治、民族统一和民族认同”\n了解民族有两种主要路径：客观路径与主观路径。\n 过去苏联教科书中对民族的定义是客观路径，这一观点认为：民族是人们在历史上形成的一个有共同语言、共同地域、共同经济生活以及表现于共同文化上的共同心理素质的稳定的共同体。 主观路径是把民族视为一个“想象的共同体”，这是本尼迪克特·安德森的著名观点。安德森认为，民族“是一种想象的政治共同体——并且，它是被想象为本质上是有限的（limited），同时也享有主权的共同体”。  安东尼·史密斯认为民族主义有个六个基本主张：\n 世界由不同的民族所组成，每个民族都有自己的特定、历史和认同 民族是政治权力的唯一源泉 还有对于民族的忠诚超出对其他所有的忠诚 为了赢得自由，每个个人必须从属于某个民族 每个民族都需要完全的自决与自治 全世界的和平和正义需要一个各民族自治的世界。  民族主义认为，民族是政治权力的来源。\n尽管民族主义具有诸多的共有特征，但在其内部，不同类型的民族主义差异很大。\n 自由主义的民族主义——寻求民族自决的美国独立战争呈现的是这样一种特征 保守主义的民族主义——欧盟内部的反移民运动同时兼具保守主义和民族主义两种特质 扩张主义的民族主义——纳粹德国当年追求扩张与侵略的做法即是一例 反殖民主义的民族主义——印度谋求国家独立的民族主义运动展现的基本诉求就是反对殖民主义。  民族不是族群，因为尽管两者有某种重合并都属于同一类现象（拥有集体文化认同）。但是族群通常没有政治目标，并且在很多情况下没有公共文化；且由于族群并不一定要有形地拥有其历史疆域，因此它甚至没有疆域空间。而民族至少要在相当的一个时期必须在其自己所谓的祖国中定居，以将自己构建成民族；而且为了立志成为民族并被承认，它需要发展某种公共文化，以及追求相当程度的自决。\n民族主义的起源与理论 解释民族主义的几种主要理论：\n 社会经济的解释。“在这一视角中，各种民族主义和民族源自新型的经济社会因素，如工业资本主义、区域不平等和阶级冲突。” 社会文化的解释。  “根据欧内斯特·盖尔纳的观点，各种民族主义和民族都是在‘现代化’转型过程中产生的，是现代的、工业化时代的必然社会现象。”这里强调的是，民族和民族主义是一种高级文化现象，而正是现代化实现对社会文化的改造，作为现代现象的知识增长和教育普及是其基础。 另一种角度则强调地理上的接近和经济上的相似会催生出相似的文化，然后形成共同的传统。在现代化过程中，这种文化上的相似性会逐渐上升到民族主义。   政治的解释。“在这里，民族和民族主义是由现代专业化国家，或直接地，或在对抗特定的（帝国的/殖民的）国家中所造就的。”换句话说，民族和民族主义是现代国家兴起的伴随物。 意识形态的解释。“这种视角强调民族主义意识形态的欧洲本源及其现代性；强调民族主义类似宗教的力量，以及它在分裂帝国和在没有出现民族的地方创立民族所起的作用。”这种视角认为启蒙运动在动员民族主义方面发挥了重要作用，所以民族主义本身是现代意识形态兴起的产物。 建构主义的解释。“这种视角与其他的现代主义形式有相当的不同，尽管它也采纳民族和民族主义是完全现代的观点，但是却强调它们的社会建构特征。”本尼迪克特·安德森所谓的民族是“想象的共同体”，就是建构主义的路径。这种观点把民族主义的出现跟工业资本主义引发的印刷品和阅读的普及关联起来。总的来说，民族是通过想象来构建的。  民族国家和族群政治 民族国家被视为一种政治组织形式和政治理想，是指民族和国家的重叠状态。所以，严格意义上的民族国家是指，一个国家就是一个民族，一个民族成为一个国家。但是今天看来，一般意义上的国家只要内部没有太明显的民族或族群裂痕的话，通常都被视为民族国家。\n现有的主流研究认为，族群被视为基于血缘或世系而互相认同的一个群体，这个群体拥有共同的语言文化、宗教习俗及身体特征。\n马丁·麦格认为，族群具有如下主要特征：独特的文化特征；社群意识；族群中心主义/优越感；与生俱来的成员资格；领地\n族群国家的国内族群关系主要有两种类型：一种是以竞争与冲突为主，一类是以合作与融合为主。当然，有些国家族群之间的关系是既冲突又融合的中间模式。\n西欧国家主要通过三个途径来实现了民族整合和族群融合：\n 现代化，即充分发展工业化和工业社会。 建立一个平等主义的国家 塑造民族认同。这里民族认同是超越族群认同之上的、基于民族国家身份的认同感。  族群政治和政治发展 唐纳德·霍洛维茨：“族群冲突是一个世界性的现象。”\n从现有的趋势看，族群冲突在相当长时间内仍然是很多发展中国家国内政治的主要挑战。\n在族群分化程度较低的阶段，随着族群分化程度的提高，族群冲突的程度会增加；但族群分化高到一定程度之后，随着族群分化程度的继续提高，族群冲突反而会趋于缓和。\n族群政治通常还跟发展中国家的政治发展和民主转型有关。在发展中世界，很多国家的族群冲突正在成为威胁新兴民主政体稳定的主要问题。\n学者研究发现，对多族群国家来说，民主转型前期有可能加剧族群冲突；随着民主政体维系时间的延长，族群冲突会趋于缓和。解释：在威权政体之下，尽管国内存在不同族群并且这些族群有着历史上的恩怨关系，但由于缺少充分的政治参与，不同族群集团的政治诉求被压制了，这样就表现为直接的族群冲突程度较低。但是，随着民主转型的启动，所有族群集团都拥有政治参与和政治竞争的权利，都可以通过公开方式表达政治诉求，甚至都组建政党参与政治竞争。在这样的国家，族群身份会成为主要的政治动员手段。所有这些，都可能会推动族群冲突的快速上升。而当民主转型时间较长、民主政体趋于巩固时，不同族群集团开始学会用和平而非暴力、制度化而非冲突方式来表达政治诉求和处理族群关系，这样族群冲突程度会逐步降低。\n如何有效地控制族群冲突就是一个重大议题：\n 注重族群关系的社会结构：不平等多元主义的族群关系模式最有可能导致族群冲突 另一理论视角则偏向于制度主义。关于如何在多族群社会或高度分裂的社会通过控制族群冲突来维系新兴民主政体的稳定。对于呈现高度族群分裂的社会来说，离心型制度安排很容易导致民主政体的不稳定。要想在高度分裂的社会实现民主政体稳定，关键是要通过有效的宪法设计和制度安排为政治精英提供跨族群的政治激励。  ","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap11/","tags":null,"title":"民族主义与族群政治"},{"categories":null,"contents":"半导体存储器是一种能大量存储二值信息的半导体器件\n半导体存储器：\n RAM(Random-Access Memory)：在运行状态可以随时进行读/写操作，必须有电源供应才能保存，掉电后数据丢失  静态随机存储器SRAM 动态随机存储器DRAM  异步存储 同步存储 伪静态随机存储器PSRAM     ROM(Read-Onlu Memory)：正常工作只能读出信息，断电后信息不丢失  固定ROM-掩模ROM 可编程ROM  PROM EPROM E2PROM FLASH      基本概念：\n 字长（位数）：表示一个信息的多位二级制码位一个字，字的位数位字长 字数：字的总量。字数$=2^n$(n为存储器外部地址线的线数) 地址：每个字的编号 存储容量（M）：存储二值信息的总量 = 字数 $\\times$ 位数  ROM ROM的分类：\n 按照存贮单元中器件划分  二极管ROM 三极管ROM MOS管ROM   按写入情况  固定ROM 可编程ROM    掩模ROM 存储矩阵中的每个交叉点是一个存储单元，存储单元中有器件存入1，无器件存入0\n特点：出厂时已经固定，不能更改，适合大量生产，便宜\n可编程ROM（PROM） 总体结构与掩模ROM一样，但存储单元不同\n熔丝由易熔合金制成，出厂时每个结点上都有，编程时将不用的熔断。是一次性编程，不能改写\n写入时，要使用编程器\n可擦除的可编程ROM（EPROM） 总体结构与掩模ROM一样，但存储单元不同\n用紫外线擦除的PROM（UVEPROM） EPROM是采用浮栅技术生产的可编程存储器，它的存储单元多采用N沟道叠栅MOS管（SIMOS），其结构及符号如图所示。除控制栅外，还有一个无外引线的栅极，称为浮栅。当浮栅上无电荷时，给控制栅（接在行选择线上）加上控制电压，MOS管导通；而当浮栅上带有负电荷时，则衬底表面感应的是正电荷，使得MOS管的开启电压变高，如图(b)所示，如果给控制栅加上同样的控制电压，MOS管仍处于截止状态。由此可见，SIMOS管可以利用浮栅是否积累有负电荷来存储二值数据。 在写入数据前，浮栅是不带电的，要使浮栅带负电荷，必须在SIMOS管的漏、栅极加上足够高的电压（如25V），使漏极及衬底之间的PN结反向击穿，产生大量的高能电子。这些电子穿过很薄的氧化绝缘层堆积在浮栅上，从而使浮栅带有负电荷。当移去外加电压后,浮栅上的电子没有放电回路，能够长期保存。当用紫外线或X射线照射时，浮栅上的电子形成光电流而泄放，从而恢复写入前的状态。照射一般需要15至20分钟。为了便于照射擦除，芯片的封装外壳装有透明的石英盖板。EPROM的擦除为一次全部擦除，数据写入需要通用或专用的编程器。\n电可擦除的可编程ROM（$E^2PROM$） 为克服UVEPROM擦除慢，操作不便的缺点，采用FLOTOX（浮栅隧道氧化层MOS管）\n快闪存储器：FLASH RAM 静态随机存储器SRAM 动态随机存储器（DRAM） 动态存储单元是利用MOS管栅极电容可以存储电荷的原理。\n SRAM：速度快，贵 DRAM：相对速度慢，便宜  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8/","tags":null,"title":"半导体存储器"},{"categories":null,"contents":"Matching theroy Systems of Distinct Representatives (SDR) A system of distinct representatives (SDR) (also called a transversal) for a sequence of (not necessarily distinct) sets $ S_{1},S_{2},\\ldots ,S_{m}$ is a sequence of distinct elements $ x_{1},x_{2},\\ldots ,x_{m}$ such that $ x_{i}\\in S_{i}$ for all $i=1,2,\\ldots ,m$.\n就是指每个集合中找到一个代表的元素，这些元素各不同。(代表元素也可以存在其他集合中)(相当于每个集合有一个元素与之匹配)\nHall's marriage theorem Hall's Theorem： The sets $S_{1},S_{2},\\ldots ,S_{m}$ have a system of distinct representatives (SDR) **if and only if** $\\left|\\bigcup _{i\\in I}S_{i}\\right|\\geq |I|$ **for all** $I\\subseteq {1,2,\\ldots ,m}$.\nMin-max theorems König-Egerváry theorem Dilworth's theorem Application: Erdős-Szekeres Theorem Application: Hall's Theorem Flow and Cut Flows Cuts Augmenting paths Max-Flow Min-Cut The max-flow min-cut theorem Flow Integrality Theorem Applications: Menger's theorem Applications: König-Egerváry theorem ","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/matching-theroy/","tags":null,"title":"Matching Theroy"},{"categories":null,"contents":" 即使是最强者，也决不会强大到主人永远做主人，除非他把自己的强力转化为权利，把服从转化为责任。——卢梭\n 政治有时呈现出一幅和平的图像，有时呈现出一幅暴力的图像。\n政治暴力与常见暴力现象 国家是一个合法垄断暴力的机构，这是国家的本质属性。从这一定义出发，站在国家角度看，垄断暴力是政治的基本问题。如果一个社会充斥着暴力，那意味着国家不能有效地垄断暴力。当国家不能有效垄断暴力时，一个社会的政治秩序就失去了控制。\n 首要的问题不是自由，而是建立一个合法的公共秩序。人当然可以有秩序而无自由，但不能有自由而无秩序。必须先存在权威，而后才谈得上限制权威。——塞缪尔·亨廷顿\n 集体暴力: 至少是部分地来源于施暴者的相互协作。\n政治暴力是跟政治有关的集体暴力，是由政治动机引发的、包含明确政治目标或意图的集体暴力。\n有人认为，街头是一个非常重要的政治场域，街头政治是一种重要的政治类型。\n有人把政治大罢工也视为准政治暴力行为\n还有一种典型的政治暴力现象是政治暗杀\n典型的政治暴力现象还有军事政变\n20世纪以来另一个严重的政治暴力现象是族群屠杀或种族屠杀，甚至包括族群清洗或种族清洗。\n政治暴力的类型与逻辑 迈克尔·罗斯金《政治科学》：\n 原生型的（primordial）原生型暴力产生于基本的社会群体冲突——种族的、民族的或宗教的——这些都是人们与生俱来的。 分裂型（separatist）分裂型暴力——有时是原生型暴力冲突的产物——目标是要实现相关群体的独立。 革命型（revolutionary）革命型暴力旨在推翻或取代现政权，例如伊斯兰教主义者想要接管穆斯林国家并把他们变成信奉正统派的人。 政变型（coups）政变通常是为了反对革命、腐败和混乱。一般来说，政变几乎总是军事性的，尽管军队通常与关键的文官集团有联系并从他们那里获得支持，就像1964年巴西的政变那样。 问题型（issues）一些暴力不适合这些类型中的任何一种。由某一特定问题所引发的暴力是一种兼容的类型，并且常常不像其他类型的暴力那样具有致命性。  查尔斯·蒂利则用两个维度对人际暴力类型进行了区分：一是暴力伤害的严重程度，二是暴力行为者之间的协同程度\n对高能力的民主国家来说，从政治诉求上讲，只有较低比例的人愿意或需要用政治暴力来表达政治诉求，大量的政治诉求都能在现有民主体制框架内表达；从国家能力上讲，有效的国家能力使得政治暴力不容易发生和蔓延。所以，两者的结合导致的是低强度的政治暴力。\n一个国家的政体和国家能力产生变化后，该国的政治暴力程度亦可能发生变化。\n还有学者从另一个角度来探讨政体与政治暴力之间的关系，即政治竞争本身会导致更多的政治暴力。\n国家与社会革命 革命通常是指一种快速剧烈的系统性变革。\n政治革命主要是指对旧政体和旧政权的革命。\n社会革命是一个社会的国家政权与阶级结构都发生快速而根本转变的过程；与革命相伴随，并部分地实施革命的是自下而上的阶级反抗。社会革命之所以不同于其他类型的冲突和转型过程，首先在于它是两个同时的组合：社会结构变迁与阶级突变同时进行；政治转型与社会转型同时展开。\n社会革命通常可以分为几个阶段。第一个阶段是旧制度的衰朽。第二个阶段是能量的集聚和革命的发动，这是社会革命的启动阶段。第三个阶段是旧制度的垮台，然后整个政治和社会发生急剧变革，中间还伴随着大规模的社会动员与底层反抗。第四个阶段是经过急剧的变动，出现了政治力量的重组和新制度的诞生，最终达到一种新的政治均衡。\n为什么会发生社会革命：\n 马克思主义的解释。社会革命可以归结为生产关系与生产力的冲突与断裂，直接表现为剧烈的阶级斗争和阶级冲突，下层阶级的反抗直接导致了社会革命的发生，最后表现为一个阶级用暴力方式推翻另外一个阶级 革命的群体心理理论。这种心理学理论更关心作为参与群体行动的个人何时会卷入政治暴力、何种条件下会卷入大规模的政治冲突。革命，就是这种群众性集体情感急速攀升过程中爆发的。 系统/共识价值理论，这种理论强调的是整个社会体系和系统中的严重失衡。这种理论借鉴了系统论的方法 政治冲突理论，这种理论认为社会革命是源自不同社会集团对政治权力的争夺，这种对政治权力的争夺会导致剧烈的政治冲突。 西达·斯考切波《国家与社会革命》：  一个变量是整体性的危机和旧制度的崩溃  一是原有专制体系中行政和军事系统的能力下降 二是国际结构中政治压力和国家间竞争因素的上升。   另一个变量是下层阶级的反抗所引发的政治冲突：这就要求原有传统社会中支配阶级和下层阶级的冲突比较激烈，最后引发严重的政治对抗。 两者的结合导致社会革命的发生。    为什么通常不是改革而是革命：托克维尔在《旧制度与大革命》中的观点与米涅在《法国革命史》中陈述的思想非常相似，即依附于旧制度的既得利益集团通常都不会放弃自己的既得利益，所以要发动一场成功的改革相当困难。\n内战的理论解释 内战是大规模政治暴力的主要形式之一。内战是在一个国家内部不同的组织化武力集团为控制或推翻政权而引发的持续暴力冲突。\n内战为什么发生？多种理论解释：\n 内战主要起源于身份认同的危机。身份认同跟人的归属感有关 对资源的争夺。一国内部不同群体的实际境遇可能差异很大。 着眼于政治权力。这种理论认为，政治就是一个争夺政治权力的过程。不同的人和集团都想控制一个国家的最高政治权力。 革命理论。简单地说，一个国家内部，有的社会集团或政治力量要推翻现有政治秩序，要发动政治革命或社会革命。在此过程中，有人反对革命，希望维持现有政治秩序。 科利尔-霍夫勒模型（C-H模型）：一个国家未来5年中是否会爆发内战会受到六个因素的显著影响  财务资源获取的容易程度  该国有没有可供出口的石油资源。 该国某些政治集团是否能获取国外侨民的财务援助   反叛机会成本的高低。入学率越低，人均收入越低，经济增长率越低，则机会成本越低，这种条件更容易爆发内战 基于人口和地理因素的军事优势 怨恨。一个国家内部部分人口的怨恨主要来自经济不平等、政治权利受压制以及一般意义上的族群和宗教分裂因素。 人口规模。总的来说，人口规模愈大，愈有可能发生内战。 时间。研究发现，距上次内战的时间越短，越有可能发生内战    内战通常都会导致非常严重的政治后果。内战意味着打破了国家对暴力的垄断。当国家不再能垄断暴力时，国家就容易趋于解体。所以，内战不仅意味着大规模的军事冲突和大量的人员死伤，而且还意味着政治秩序的混乱和局部的无政府状态。\n如何从暴力的政治走向非暴力的政治？如时间。研究发现，距上次内战的时间越短，越有可能发生内战何实现日常政治的去暴力化？这都是塑造现代政治文明的关键。实际上，现代政治文明的一个主要特征是把暴力的政治转变为非暴力的政治。这在很大程度上关系到一个国家未来的政治命运。\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap12/","tags":null,"title":"暴力、革命与内战"},{"categories":null,"contents":"微电子学的新发展  生物探测芯片 神经网络计算（人工智能）  忆阻器   超高频电路  石墨烯   超低功耗逻辑/存储  量子隧穿晶体管 自旋电子学晶体管   量子计算  自旋电子学晶体管   智能穿戴  柔性电子学   拓扑绝缘体  忆阻器 用数学模型和算法来描述和模仿神经元的行为和相互关系，但计算仍然运行在传统的计算机上——冯诺依曼架构\n用电子器件模拟生物神经元的功能，构建新的神经计算机——非冯诺依曼架构\n传递信息-处理信息-存储信息\n𝑉(𝑡)=𝑀(𝑞(𝑡))𝐼(𝑡)\n功能如同电阻，但在关掉电源后，仍能“记忆”先前通过的电荷量。忆阻器的电阻值取决于多少电荷经过了这个器件。也就是说，让电荷以一个方向流过，电阻会增加；如果让电荷以相反的方向流过，电阻就会减小。\n 工作原理  一块极薄的二氧化钛被夹在两个电极中间，这些二氧化钛又被分成两个部份，一半是正常的二氧化钛，另一半进行了“掺杂”，少了几个氧原子。因此“掺杂”的那一半带正电，电流通过时电阻比较小，而且当电流从“掺杂”的一边通向正常的一边时，在电场的影响之下缺氧的“掺杂物”会逐渐往正常的一侧游移，使得以整块材料来言，“掺杂”的部份会占比较高的比重，整体的电阻也就会降低。反之，当电流从正常的一侧流向“掺杂”的一侧时，电场会把缺氧的“掺杂物”从回推，电阻就会跟着增加。因此，整个器件就相当于一个滑动变阻器一样。   特点  忆阻器输入输出关系是非线性的。 忆阻器的输入和输出都是连续的, 因而其存储的精度理论上是无限的。 由于忆阻器是基本无源电路元器件，可以方便的将其应用在电路中，形成混合型电路。 由于在电荷流经的时候，忆阻器的内部结构产生变化并能在新的状态下长时间保持。因而具有非易失性的特点。 以上特点都使得忆阻器具备了传统存储器材无可比拟的优势，它的高集成密度、高读写速度、低功耗、多值计算使得它成为下一代存储元件的理想选择。   发展前景  在目前的工艺水平下，基于忆阻器的内存芯片存储密度要比目前基于晶体管的芯片高出至少一个数量级。此外，该存储芯片的运行速度也非常快，将信息存储在忆阻器内存上的速度比存储在快闪内存上的速度高出 3 个数量级 非易失性——目前广泛使用的 DRAM 上存储的内容会随着时间而丢失，因此必须不断地刷新，在存储器数量庞大的时候会消耗巨大的能量。而忆阻器内存因内部构造的原因，一旦写入可以长期保存，不需要被反复刷新。 存算一体    石墨烯 石墨烯（Graphene）是一种由碳原子构成的单层片状结构的新材料。由碳原子以sp2杂化轨道组成六角型呈蜂巢晶格的平面薄膜，只有一个碳原子厚度的二维材料。\n是构建碳纳米管和富勒烯的基本单元\n性能：\n 极薄极轻，厚度为0.34nm，比表面积为2630m2/g 导热率为3000-5000W/mK，与碳纳米管相当 极强的力学性能：拉伸模量1.01TPa，极限强度116GPa 优良的导电性，室温下载流子迁移率是硅的100倍  制备方式：\n 物理方法  机械剥离法 液相或气相直接剥离法   化学方法  表面析出生长法 氧化石墨还原法 化学气相沉积(CVD)法 化学合成法    应用前景\n 低成本石墨烯电池 可折叠弯曲屏 石墨烯传感器：高导电性、高强度、超轻薄 石墨烯过滤器 石墨烯生物器件：可修改化学功能、大接触面积、原子尺寸厚度、分子闸极结构等等特色 石墨烯感光元件 太阳能电池 柔性微处理器  从石墨烯到二维材料：\n 结构有序 二维平面生长 在第三维度超薄  自旋场效应晶体管 在半导体材料中有电子和空穴两种载流子 极化电子有自旋向上和向下的两种载流子\n当电子通过铁磁金属时，电子由简并态，变成向上(+1/2)和向下(-1/2)的非简并态，表现出自旋极化\n柔性电子学 材料：\n 碳纳米管 金属氧化物半导体薄膜 金属纳米薄膜、金属纳米线 有机高分子薄膜 水凝胶离子导体 液态金属  制造方法：\n 转移印刷 喷墨印刷 纤维结构形成  通常具有高导电性和透明性的材料是不可拉伸的。然而，通过几何结构设计，可以使坚硬的材料实现结构上的可拉伸。\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%BE%AE%E7%94%B5%E5%AD%90%E5%AD%A6%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95/","tags":null,"title":"微电子学的新发展"},{"categories":null,"contents":" 当存在激励因素促使人们去攫取而不是创造，也就是从掠夺中而不是从生产或者互为有利的行为中获得更多收益的时候，那么社会就会陷入低谷。——曼瑟·奥尔森\n 蛋糕政治定律 做大蛋糕”意味着经济增长和总量扩张，“切好蛋糕”意味着合理分配和规则公平\n最简明的“蛋糕经济定律”：只有切好蛋糕才能做大蛋糕。切好蛋糕是塑造正确的激励结构，鼓励那些扩大生产、改进效率和推动创新的经济行为，奖励那些对经济增长做出贡献的个人与组织。这样，人们才有动力去做大蛋糕，并使整个社会受益。\n“蛋糕经济定律”所忽略的是政治在“做蛋糕”和“切蛋糕”过程中扮演何种角色\n蛋糕与国家：\n 没有国家时的主要规则是抢蛋糕 绝对主义国家的主要规则是分蛋糕 立宪主义国家的主要规则是做蛋糕。  作为微观基础的经济人假设 经济人假设：人是自利的，人是理性的，人追求效用最大化\n经济人假设尽管并不完美，却是一个较为恰当的分析起点。\n私人部门治理 实现私人部门有效治理需要三个基本条件：\n 一是产权的界定和保护  由人的自利性可以推导出：财产权利构成了人类社会的基本激励结构。如果财产不受保护，这种激励结构就会遭到破坏，社会的基本规则就会乱套   二是交易与经济自由  经济自由至少有两个好处：第一，市场主体可以自主选择；第二，不同市场主体之间可以自由竞争   三是契约的强制执行与法治。  公共部门治理 在现代政治中，公共部门存在着三种主要角色：政治家、官员和选民。政治家和官员被视为公共服务的供应者，而选民被视为公共服务的需求者。\n如何让公共部门治理更有效：\n 如果政治家和官员都是经济人，公共部门的资源和权力就不应该由少数人控制，而应该由多数人控制。 政治竞争，言论自由和媒体自由 要确立政治权力与民主决策的范围与边界，亦即实施宪政原则  现代政治的一项常识是：即便是民主决策，亦须限定其范围和边界。换句话说，不管你拥有多少比例的选民支持，有些事情是民主决策所不能做的，这样才能保证公共部门治理的有效性。实际上，这就涉及立宪政治或宪政原则。\n在现代民主政体下，宪政有两个重要功能：一方面，宪政是对政治权力和政府的一种约束，另一方面，宪政是对民主本身的一种约束。\n激励结构与经济增长 从政治经济学视角来看，每个人都身处一定的激励结构之中。正是激励结构决定了一个人行为的激励与约束机制。如果激励结构鼓励一个人提高产出，他大概倾向于提高产出；如果激励结构不鼓励提高产出，他大概不会去努力提高产出。\n不同的激励结构一旦确立以后，久而久之还会塑造整个机构的文化。\n基于这个视角，一个国家经济增长的关键在于能否普遍建立起有效的激励结构。这种激励结构的核心是个人与组织之间的激励相容。\n现有的经济学和政治学理论已经揭示了一条最简单的规则：一个国家要实现有效治理和经济增长，就需要在两个领域——私人部门和公共部门塑造好的激励结构。\n私人部门的激励规则应该是：只有那些为他们的顾客、用户、委托人或社会创造真正价值的人，才能获得自身的回报与成功。\n公共部门需要类似的激励规则：只有那些为大众与社会提供有效公共产品和服务的人，才能获得自身的回报与成功。\n腐败的政治经济学 腐败的最简单定义是钱权交易。更一般地说，腐败是一种用公共权力谋取私人利益的行为。\n腐败程度取决于权力控制的资源多少和分权制衡程度。更具体地说，权力控制的资源越多，分权制衡程度越低，则越腐败；权力控制的资源越少，分权制衡程度越高，则越不腐败。\n","permalink":"http://tristonk.com/notes/%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/chap13/","tags":null,"title":"经济增长与国家治理的政治学"},{"categories":null,"contents":"原文链接：https://mongoing.com/archives/38461\nMongoDB副本事务集  副本集的复制基于raft协议，只支持single-master，对应的，MongoDB的副本集是主从架构，而且只有主节点支持写入操作。MongoDB副本集的事务管理，包括冲突检测，事务提交等关键操作，都只在主节点上完成。 使用SI作为事务的隔离急别  SI简介 SI：Snapshot Isolation，即快照隔离，一种MVVC的实现机制\n根据快照时间点的选取：\n CSI（convensional SI）  选取最新的系统快照作为事务的读取快照 一般说一个数据库支持SI隔离级别，其实默认是说CSI   GSI（Generalized SI）  GSI选择历史上的数据库快照作为事务的读取快照，因此CSI可以看作GSI的一个特例。 对主节点来说每次事务开始选取最新的快照，但是对于其他节点没有统一的最新的概念。 关于时间点的选择，有以下的规则 (其中Ti表示事务i，Xi表示被事务i修改过的X变量)    读规则  G1.1,如果变量X被本事务修改了值且读取到了新的值， 那么 读操作一定在写操作后面; G1.2, 如果事务i读取了事务j更新的变量的X， 那么一定不会有事务i更新X的操作，在事务i读取了事务j更新的变量的X这个操作前面; G1.3, 事务j的提交时间早于事务i的快照时间； G1.4, 对于任意一个会更新变量X的事务k， 那么这个事务k一定满足， 要么事务k的提交时间小于事务j， 要么这个事务k的提交时间大于事务i。   写规则  G2, 对于任意已经在提交历史里的两个事务，Ci, Cj, 那么一定可以保证当 事务j的commit时间戳在 事务i的观测时间段内时(snapshot(Ti), commit(Ti))， 那么他们更新的变量交集一定为空。       PCSI  ","permalink":"http://tristonk.com/blog/mongodbsi/","tags":null,"title":"MongoDB的事务，复制与分片"},{"categories":null,"contents":"","permalink":"http://tristonk.com/notes/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/chap3/","tags":null,"title":"Data Flow Analysis - Applications"},{"categories":null,"contents":"数据仓库：\n subject-oriented：面向主题的 integrated time-variant nonvolatile  Data Cube: The lattice of cuboids\n多维数据模型：\n 每一维都被存储在维表中，数据存储在事实表中，多张表通过join方式连接   星型模型(Star schema)    雪花模型(snowflake schema)：节省了空间，使得效率稍微受到影响\n  星系模型(Fact constellation schema)：是一个网状连接的\n  concept hierarchy：\n  schema hierarchy：\n 全序关系 偏序关系    set-grouping hierarchy：对于一个维度可以有多种定义方式，取决于应用\n  OLAP operations on data cube  roll-up：通过概念集爬升的方式把低层的数据进行聚合，比如说把各个城市的销售量roll-up成不同国家的销售量 drill-down：往概念集向下或者增加细分维度来将数据进行拆分，如将一年的数据分成四个季度的数据 dice：从多维中选择一块数据 pivot：将数据坐标系进行旋转  Measure 一个数据立方体的measure是一个数值函数，可以在数据立方体的任何一个地方进行计算.measure 有以下三种方式：\n  Distributive:是一个分布式聚合函数(distributive aggregate function)：想要知道一个值，可以把数据分成若干小块，在不同块上分别操作再聚合在一起 e.g., count(), sum(), min(), max()\n  Algebraic: 可以分成若干块，在每一块上进行分布式聚合函数运算，将得到的值应用一个算术函数进行运算得到结果。e,g,. avg(),min_N(), standard_deviation()\n  Holistic: 需要把原始数据拿过来从底层开始计算。e,g,. rank(), median()\n  预计算\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/2datacubeandolap/","tags":null,"title":"Data Cube and OLAP"},{"categories":null,"contents":"Contest 174 2月最简单的一场周赛，不提了\nContest 175 检查整数及其两倍数是否存在 题意：给定一个数组，检查数组中是否存在两个数恰好一个是另一个的两倍\n题解：类似两数和，一个哈希表搞定\n制造字母异位词的最小步骤数 给你两个长度相等的字符串 s 和 t。每一个步骤中，你可以选择将 t 中的 任一字符 替换为 另一个字符。找到使 t 成为 s 的字母异位词的最小步骤数。\n题解：比较字母计数即可，s中出现的+1，t中的-1\n推文计数 请你实现一个能够支持以下两种方法的推文计数类 TweetCounts：\n recordTweet(string tweetName, int time): 记录推文发布情况：用户 tweetName 在 time（以 秒 为单位）时刻发布了一条推文。 getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime): 返回从开始时间 startTime（以 秒 为单位）到结束时间 endTime（以 秒 为单位）内，每 分 minute，时 hour 或者 日 day （取决于 freq）内指定用户 tweetName 发布的推文总数。  freq 的值始终为 分 minute，时 hour 或者 日 day 之一，表示获取指定用户 tweetName 发布推文次数的时间间隔。 第一个时间间隔始终从 startTime 开始，因此时间间隔为 $[startTime, startTime + delta1\u0026gt;, [startTime + delta1, startTime + delta2\u0026gt;, [startTime + delta2, startTime + delta3\u0026gt;, ... , [startTime + deltai, min(startTime + delta*(i+1), endTime + 1)\u0026gt;$，其中 i 和 delta（取决于 freq）都是非负整数。\n题解：可以将每个用户的推文时间存储方式换成更有效的平衡二叉树。在查询时只要先在对应用户的所有推文中查询时间范围的上下界，然后在上下界范围内遍历推文发布时间即可。（实际上使用set即可）\nclass TweetCounts { map\u0026lt;string, set\u0026lt;int\u0026gt;\u0026gt; user; public: TweetCounts() { } void recordTweet(string tweetName, int time) { user[tweetName].insert(time); } vector\u0026lt;int\u0026gt; getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) { int length = 0; if (freq == \u0026#34;minute\u0026#34;) length = 60; else if (freq == \u0026#34;hour\u0026#34;) length = 60 * 60; else length = 60 * 60 * 24; vector\u0026lt;int\u0026gt; ans((endTime - startTime) / length + 1); auto begin = user[tweetName].lower_bound(startTime); auto end = user[tweetName].upper_bound(endTime); for (; begin != end; ++begin) { ++ans[(*begin - startTime) / length]; } return ans; } }; 参加考试的最大学生数 题意：给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 '#' 表示；否则，用 '.' 表示。 学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。学生必须坐在状况良好的座位上。\n题解： 方法1[https://leetcode-cn.com/problems/maximum-students-taking-exam/solution/er-fen-tu-zui-da-du-li-ji-by-lightcml/]：只关心可以坐人的座位，我们把作为按照列下标的奇偶建二分图，S向奇数下标的座位连边，偶数下标的座位向T连边，有冲突的座位奇数座位向偶数座位连边。图中所有边流量都是1。直接跑二分图最大点独立集就行，即可以坐人的座位数-最大流。\n方法2：DP+记忆化\nclass Solution { int memory[8][1 \u0026lt;\u0026lt; 8]; vector\u0026lt;int\u0026gt; compressed_seats; int f(int X, int row_num, int width) { if (memory[row_num][X] != -1) return memory[row_num][X]; int ans = 0; for (int scheme = 0; scheme != (1 \u0026lt;\u0026lt; width); ++scheme) { if (scheme \u0026amp; ~X || scheme \u0026amp; (scheme \u0026lt;\u0026lt; 1)) continue; int curans = 0; for (int j = 0; j != width; ++j) if ((1 \u0026lt;\u0026lt; j) \u0026amp; scheme) ++curans; if (row_num == compressed_seats.size() - 1) ans = max(ans, curans); else { int next_seats = compressed_seats[row_num + 1]; next_seats \u0026amp;= ~(scheme \u0026lt;\u0026lt; 1); next_seats \u0026amp;= ~(scheme \u0026gt;\u0026gt; 1); ans = max(ans, curans + f(next_seats, row_num + 1, width)); } } memory[row_num][X] = ans; return ans; } int compress(vector\u0026lt;char\u0026gt;\u0026amp; row) { int ans = 0; for (char c : row) { ans \u0026lt;\u0026lt;= 1; if (c == \u0026#39;.\u0026#39;) ++ans; } return ans; } public: int maxStudents(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; seats) { for (int i = 0; i != seats.size(); ++i) for (int j = 0; j != (1 \u0026lt;\u0026lt; seats[0].size()); ++j) memory[i][j] = -1; for (auto row: seats) compressed_seats.push_back(compress(row)); return f(compressed_seats[0], 0, seats[0].size()); } }; 链接：https://leetcode-cn.com/problems/maximum-students-taking-exam/solution/can-jia-kao-shi-de-zui-da-xue-sheng-shu-by-leetcod/ Contest 176 相对难一点的一次周赛\n统计有序矩阵中的负数 题意：一个矩阵，每行每列都非降序排列，找出矩阵内的负数个数\n解法：行顺序，列倒序遍历，时间复杂度$O(m)$,空间复杂度$O(1)$\n最后 K 个数的乘积 题意：设计一个类，含有两个函数与一个构造函数，构造出一个数字列表后，可以调用addNum函数来添加数到数字列表最后，也可以调用getProduct(int k)来获取最后k个数的乘积，已知这两个函数的调用次数和不超过40000次，可以保证数字列表中任意k数的乘积都不会超过32-bits范围\n题解：直接考虑维护一个前缀积 $pre[i]$ 表示前 i 个数的乘积即可,然后遇0则将整个数组清零，维护数组长度，求最后k个数的乘积的时候，只需要先考虑数组长度是否达到了k，否则返回0（因为这意味着最后k个数中含有0）。如果达到了返回$pre[n]/pre[n-k]$即可（n为数组长度）\n最多可以参加的会议数目 题意：多个会议，给出每个会议的开始时间与结束时间，每天只能参加一个会议，但是每个会议可以只参加其中的某几天或1天，请问最多能参加多少个会议。\n题解：贪心，选择end尽可能早的会议参加\n多次求和构造目标数组 题意：给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：令 x 为你数组里所有元素的和，选择满足 0 \u0026lt;= i \u0026lt; target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。你可以重复该过程任意次。 如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。\n示例 1： 输入：target = [9,3,5] 输出：true 解释：从 [1, 1, 1] 开始 [1, 1, 1], 和为 3 ，选择下标 1 [1, 3, 1], 和为 5， 选择下标 2 [1, 3, 5], 和为 9， 选择下标 0 [9, 3, 5] 完成\n题解：我们正向难以解决的时候，可以考虑使用逆向的方式进行思考。我们可以考虑是否能从目标数组得到全1数组，我们发现，最后一次操作生成的数是之前所有数的和所以必然是最大的，即原数为$maxn-(sum-maxn)$.这样只要能倒推回全1数组就返回true。但是这种情况会在$[1,1000000]$此类的测试用例下可能超时，所以可以考虑减去多次，即倒退一次后仍为最大继续倒退这个数的情况，这种情况下，每次倒退幅度都是其他数的和$maxn-(sum-maxn)$,我们只要考虑一次减去k个幅度使得最大数比第二大的数小或者为1即可（分类讨论下即第二大的是否为1）.\n注意整数的溢出，注意边界情况\nbool isPossible(vector\u0026lt;int\u0026gt;\u0026amp; target) { priority_queue\u0026lt;int\u0026gt;q; long long sum=0; if(target.size()==1){ if(target[0]==1)return true; return false; } for(auto x:target){q.push(x);sum+=(long long)x;} while(q.top()\u0026gt;1){ long long maxn =(long long) q.top();q.pop(); long long secMax =(long long) q.top(); long long k; if(secMax == 1){ k=(maxn-1+sum-maxn-1)/(sum-maxn); }else{ k=(maxn-secMax)/(sum-maxn)+1; } long long delta = k*(sum-maxn); sum-=delta; maxn-=delta; if(maxn\u0026lt;=0) return false; q.push((int)maxn); } return true; } Contest 177 非常简单的一次，可惜我白痴了一下（\n日期之间隔几天 题目：给定两个日期，求解日期差多少天\n题解：由于限制了范围，可以全部以0000-01-01作为起点或者1971-01-01作为起点，然后再相减就可以\n验证二叉树 题目：给定两数组，$left[i]$表示节点i的左子节点序号，对应的有right数组，验证是否是二叉树且只有一棵。\n题解： 对于一个包含 n 个节点 m 条边的无向图，如果它是一棵树，那么必须满足以下三个条件中的两个：边数 = 点数 - 1；该无向图连通；该无向图无环。 第一点通过统计-1个数即可，第二点可以利用搜索遍历的方式进行，第三点可用并查集检查。\n最接近的因数 题意：给定一个数x，求x+1和x+2中因数最接近的一对。如给定x=4，最接近的一对就是(2,3)\n题解：暴力每一次从平方根递减即可，注意及时跳出循环\n形成三的最大倍数 题意：给一个数组里面的数，你对其选择其中的一部份数进行组合成一个字符串，使得组合出来的字符串代表的数字尽可能大并为3的倍数\n考虑3的余数，要最大肯定时位数最多，那么我们就要尽可能的保留多的数字，只需要考虑如何将全部的数相加后的和减少尽量少的数字使其能够维持在3的倍数即可。考虑余数即可。\nclass Solution { vector\u0026lt;int\u0026gt; a[3],b; string ans; public: string largestMultipleOfThree(vector\u0026lt;int\u0026gt;\u0026amp; digits) { int s=0,i; for(i=0;i\u0026lt;3;i++)a[i].clear(); b.clear(); for(auto c:digits) { s+=c; a[c%3].push_back(c); } for(i=0;i\u0026lt;3;i++)sort(a[i].begin(),a[i].end(),greater\u0026lt;int\u0026gt;()); if(s%3)if(!a[s%3].empty())a[s%3].pop_back(); else for(i=0;i\u0026lt;2;i++)a[s%3^3].pop_back(); for(i=0;i\u0026lt;3;i++)for(auto c:a[i])b.push_back(c); sort(b.begin(),b.end(),greater\u0026lt;int\u0026gt;()); ans=\u0026#34;\u0026#34;; if(b.empty()||b.front())for(auto c:b)ans+=c^\u0026#39;0\u0026#39;; else ans=\u0026#34;0\u0026#34;; return ans; } }; ","permalink":"http://tristonk.com/blog/leetcodecontest20-02/","tags":null,"title":"Leetcode 2020年2月周赛题解"},{"categories":null,"contents":"双指针 双指针是这样的模式：两个指针朝着左右方向移动（双指针分为同向双指针和异向双指针），直到他们有一个或是两个都满足某种条件。双指针通常用在排好序的数组或是链表中寻找对子。比如，你需要去比较数组中每个元素和其他元素的关系时，你就需要用到双指针了。\n我们需要双指针的原因是：如果你只用一个指针的话，你得来回跑才能在数组中找到你需要的答案。这一个指针来来回回的过程就很耗时和浪费空间了 — 这是考虑算法的复杂度分析的时候的重要概念。虽然brute force一个指针的解法可能会奏效，但时间复杂度一般会是O(n²)。在很多情况下，双指针能帮助我们找到空间或是时间复杂度更低的解。\n左右指针 有些情形下，不应该用左右指针，比如我们在单链表上不能往回移动的时候\n识别使用双指针的招数：\n 一般来说，数组或是链表是排好序的，你得在里头找一些组合满足某种限制条件 这种组合可能是一对数，三个数，或是一个子数组  举例 11\tContainer With Most Water 题意：给定数组，在数组对应的图中求面积最大值（$S = (j-i)*min(a[i],a[j])$）\n解法： 使用双指针，从两个边界开始，每次都让更短的那条边向内移动。\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int left=0,right = height.size()-1; int area = 0; while(left!=right){ int areatmp = (right-left)*min(height[left],height[right]); if (areatmp\u0026gt;area){ area=areatmp; } if(height[left]\u0026lt;height[right]){ left++; }else { right--; } } return area; } }; 方法正确性说明：\n通俗的讲就是因为我们缩短了矩形在x轴上的边长，必须增大y轴上的边长，这只能通过移动最短边得到可能更大值。\n严格一点：我们用(i,j)表示left的index为i，right为j。 我们可以知道：在(i,j)时，i，j中必有一个是经历过的H中最大的(否则按照算法在该点将停止不动)。 我们只需要证明，我们移动后，被消去的可能状态要么被计算过，要么小于我们已经被计算过的某个状态即可。简单讨论下就可以得证了\n15 3-Sum 题意：给定数组，返回所有使得三数之和为0的三元组(不能出现重复的三元组)\n题解：排序后使用双指针\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; int n = nums.size(); if(n\u0026lt;3){ return ans; } sort(nums.begin(),nums.end()); for(int i=0;i\u0026lt;n;i++){ if(i\u0026gt;0 \u0026amp;\u0026amp; nums[i]==nums[i-1]){ continue; } int left = i+1, right = n-1; while(left\u0026lt;right){ if(nums[i]+nums[left]+nums[right]\u0026gt;0){ right--; } else if(nums[i]+nums[left]+nums[right]\u0026lt;0){ left++; } else { vector\u0026lt;int\u0026gt; anstmp ({nums[i],nums[left],nums[right]}); ans.push_back(anstmp); while(left\u0026lt;n-1 \u0026amp;\u0026amp; nums[left]==nums[left+1]) left++; while(right\u0026gt;0 \u0026amp;\u0026amp; nums[right]==nums[right-1] ) right--; left++; right--; } } } return ans; } }; 167 Two Sum II - Input array is sorted 977\tSquares of a Sorted Array\n 输出一个排好序的数组的平方数组（简单） 比较两个字符是否相等，字符中包括得有退格键（中等）  快慢指针 这种方式下，两个指针的在数组上（或是链表上，序列上）的移动速度不一样，可以利用线性同余方程证明他们肯定会相遇（类似于跑道上面跑得快的人套圈跑得慢的人）。这种方法在解决有环的链表和数组时特别有用。\n一般需要用快慢指针模式的问题：\n 问题需要处理环上的问题，比如环形链表和环形数组 当你需要知道链表的长度或是某个特别位置的信息的时候  举例  链表是否有环（简单） 链表是否满足回文（中等） 环状数组中检测环（困难）  ","permalink":"http://tristonk.com/blog/twopointer/","tags":null,"title":"TwoPointer"},{"categories":null,"contents":"思考题与作业题 出于考虑，我们删掉了此部分\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/homework/","tags":null,"title":"思考题与作业题"},{"categories":null,"contents":"样卷复习法 出于考虑，我们删掉了此部分\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/sample-exam/","tags":null,"title":"样卷整理"},{"categories":null,"contents":"当我痛苦地站在你的面前\n你不能说我一无所有\n你不能说我两手空空。\n博客迁移中，稍后再补\nlast edit\n","permalink":"http://tristonk.com/about/","tags":null,"title":"About Me"},{"categories":null,"contents":" 本blog基本搬运jyy的讲义和slides\n FAT FAT文件系统的基本思想是使用链表管理所有的数据块。FAT文件系统把若干个连续的扇区(sector)作为一个簇(cluster)\n希望表示一个文件，我们只需要知道：文件的第一块的编号,对于每一块，它下一块的编号\nFAT文件系统专门在磁盘中开辟一个区域(File Allocation Table, FAT)，来存储每一块的下一块编号。除了编号之外，还有两种特殊的编号：free (0, 该块可以使用),EOF (-1, 该块代表了某个文件的末尾)\n缺点是文件系统可能碎片化，不利用I/O优化，lseek需要读取大量FAT数据块\next2 与上一篇博客中的vsfs基本类似\n采用bitmap进行内存管理\ninode中用多个级别的索引（direct blocks、indirect blocks、double indirect.....）\n目录中顺序存储文件/子目录名字 inode编号 inode--rec_len--name_len--file_type--name\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fat%E4%B8%8Eext2/","tags":null,"title":"FAT与ext2"},{"categories":null,"contents":"System Architecture A Canonical device 硬件接口 + 内部结构\nA Canonical protocol 如上图，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。\n一种典型的协议如下： 对于第一步的while循环，我们称为polling the device (轮询)，在第二步的写数据的时候，如果有main cpu的参与,即称为是programmed I/O(PIO), 即通过CPU执行I/O端口指令来进行数据的读写的数据交换，\nLowering CPU Overhead With Interrupts 为了避免PIO模式下，cpu处于轮询状态而导致资源的浪费，可能有以下几种措施：\n 加入中断操作（但如果device执行操作很快，加入中断反而可能是效率下降） （hybrid，如无法确定device速度）先轮询一会，如果没结束则执行中断  More Efficient Data Movement With DMA DMA(Direct Memory Access)并不负责与计算机系统外的I/O，它的出现主要是为了解决设备访问速度慢的一个缺点：试想我们希望从磁盘中读出海量的数据。\nDMA设备可以看成是只执行memcpy操作的设备\n To transfer data to the device, for example, the OS would program the DMA engine by telling it where the data lives in memory, how much data to copy, and which device to send it to. At that point, the OS is done with the transfer and can proceed with other work. When the DMA is complete, the DMA controller raises an interrupt, and the OS thus knows the transfer is complete.\n Methods Of Device Interaction how the OS actually communicates with the device\n 来源：jyy讲义\n 端口I/O (Port IO, PIO)，相当于是为I/O设备提供了一个单独的地址空间，通过读/写端口的方式实现设备控制。通常，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。顾名思义，我们可以通过控制寄存器实现设备控制(例如设置设备的模式等)，从数据寄存器读写数据，并且读取状态寄存器来查看设备执行命令的状态。（教材上写的是IO instruction） 内存映射I/O (Memory-Mapped I/O, MMIO)。给特定的内存地址赋予特殊的含义，从而读/写内存地址就能实现设备的访问。在PA中，显存就是通过这种方式实现的。一方面，内存映射I/O完全可以用来实现状态/控制/数据寄存器，另一方面，在设备从外部看来是一段连续数据时(例如显存)，MMIO能减少I/O指令的数量。   Fitting Into The OS: The Device Driver device driver(设备驱动程序): 用于对设备进行抽象使得更加上层的部分（通常为文件系统）能够以统一的接口来访问这些设备, 设备驱动程序会将对这些接口的调用翻译成设备的指令发送给设备，并等设备完成.\n设备驱动层帮助我们屏蔽了底层设备的具体实现细节(例如寄存器的含义)。同理，如果我们想创建“虚拟”设备，也是非常容易的，只需要为它编写一个驱动程序即可，实现设备的读接口。Linux系统中就有一些虚拟的设备，如/dev/random, /dev/null\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/io%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8/","tags":null,"title":"IO设备与驱动"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` ... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ... ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ] ```\n","permalink":"http://tristonk.com/search/","tags":null,"title":"Search Results"},{"categories":null,"contents":"FSCK(The File System Checker) 检查的对象：\n  superblock: making sure the file system size is greater than the number of blocks that have been allocated\n  free blocks: 检查inode指向的block和inode本身的状态，确认和bitmap一致，如果不一致，选择相信inode\n  inode state：检查其数据是否看起来合法，如检查文件类型是否有效，如果出错则删除inode并且随之更改bitmap\n  inode links： 检查链接情况（遍历文件树中看link count与inode中是否一致） (没有链接的inode被移到lost+found目录中)\n  duplicates：checks for duplicate pointers, i.e., cases where two different inodes refer to the same block\n  bad blocks：A pointer is considered “bad” if it obviously points to something outside its valid range\n  directory checks：performs additional integrity checks on the contents of each directory, making sure that “.” and “..” are the first entries, that each inode referred to in a directory entry is allocated, and ensuring that no directory is linked to more than once in the entire hierarchy.\n  Journaling(write-ahead logging) 在写之前，在disk的某个确定的位置记录你要做什么，如果发生崩溃，则可以继续执行\n  Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.\n  Checkpoint: Write the pending metadata and data updates to their final locations in the file system.\n  为了节约时间，可以让前几个并发的一起写\n Journal write: Write the contents of the transaction (including TxB, metadata, and data) to the log; wait for these writes to complete. Journal commit: Write the transaction commit block (containing TxE) to the log; wait for write to complete; transaction is said to be committed. Checkpoint: Write the contents of the update (metadata and data) to their final on-disk locations.  Metadata Journaling  Data write: Write data to final location; wait for completion (the wait is optional; see below for details). Journal metadata write: Write the begin block and metadata to the log; wait for writes to complete. Journal commit: Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction (including data) is now committed. Checkpoint metadata: Write the contents of the metadata update to their final locations within the file system. Free: Later, mark the transaction free in journal superblock.  ","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E4%B8%8E%E6%97%A5%E5%BF%97/","tags":null,"title":"崩溃恢复与日志"},{"categories":null,"contents":"CZ 9.1 平面图 若G能够花在一个平面上使得任何两条边都不交叉，称G为一个平面图(planar graph)，若G已经被画在了一个平面上，且任意两条边不交叉，则称G为\t平图(plane graph)。\n一个平图把平面分为一些连通片，这些连通片被称为区域(regions), 在每个平图中总有一个区域是无界的，该区域称为外区域，在一个平图中，顶点与边都与某个给定区域R相关联的子图称为是R的边界.\n 如果G是一个至少含有三条边的连通平图，则G的每个区域的边界至少有三条边\n  **定理9.1 Euler恒等式 **：\n如果G是一个阶为n，边数为m且含有r个区域的连通平图，则n-m+r = 2\n ​ [最小反例证法]\n​ --\u0026gt; 若G是树，显然成立\n​ ---\u0026gt; 若G不是树，取一个含有最小边数且不满足Euler等式的图G，则存在一不是割边的边e，而G-e满足Euler等式，...\n 定理9.2\n如果G是一个阶为$n\\geq 3$且边数为m的平面图，则有$m\\leq 3n-6$\n ​ [直接证法] 计算每个区域的边数之和，割边只计算一次，非割边将计数两次，利用欧拉恒等式构建\n可以利用定理9.2证明有些图不是平面的\n 推论9.3\n每个平面图都含有一个度小于或等于5的顶点\n ​ [逆否证法]\n 推论9.4\n完全图$K_5$是非平面的\n 若G是平面的，且在G的任意两个不邻接的顶点之间添加一条边就可以产生一个非平面，则称G 是极大平面的(maximal planar)，另一种表述形式是：若G是平面的，但G不是其他任何平面图的一个生成子图\n 定理9.5\n图$K_{3,3}$是非平面的\n ​ [反证法] 利用欧拉恒等式，求出其区域数是5，然后计算每个区域的边数之和为2m，再根据其每个区域都不是三角形得出其边数和大于20，即$m\\geq 10$,与m值矛盾\n如果有一个或者多个度为2的顶点插入到了G的一条或者多条边中，则称G‘是G的一个细分(subdivision)\n 定理9.7 Kuratowski定理\n一个图G是平面的当且仅当G不含$K_5，K_{3，3}$，或者是$K_5，K_{3，3}$的一个细分作为子图\n CZ 10.1 顶点染色 地图的对偶是指将一个地图上的一个区域视为图G中的一个点，区域相邻即对应的两个顶点是邻接的，每张地图的对偶都是平面图\n图的一个真染色(proper coloring),或简称为染色(coloring)，指的是给图G每个顶点分配颜色且邻接顶点颜色不同，在所有染色中，使用颜色最少的颜色数称为是色数(chromatic number), 记为$\\chi (G)$, 若能用k中颜色的集合给G染色，则称G是k可染色的(k-colorable),若$\\chi(G)=k$,则也称G是k色的(k-chromatic)的，且G的每个k染色都是G的最小染色(minimum coloring)\n 定理10.1 四色定理\n每个平面图的色数至多是4\n $\\chi(G)=1$当且仅当$G \\cong \\overline{K_n}$(n阶空图)\n若顶点集 S中任意两个顶点不邻接，则称其是独立的，最大独立集的点独立数记为$\\alpha(G)$,\n若G是一个k色图，则可以把V(G)划分为k个独立集，此时这些独立集被称为色类(color classes)\n 定理10.2\n图G的色数是2当且仅当G是一个非空的二部图\n 又由定理1.12，图G是二部的当且仅当没有奇圈，故而若图G有奇圈，则$\\chi(G)\\geq 3$\n图G的一个团(clique)是指G的一个完全子图，图G中最大团的阶数被称为是G的团数(clique number),记为$\\omega(G)$.\n事实上，我们有$\\alpha(G)=k$ 当且仅当 $\\omega(\\overline{G})=k$\n **定理10.5 **\n对于每个n阶图G，我们都有\n​\t$\\chi(G)\\geq\\omega(G)$, $\\chi(G)\\geq \\frac{n}{\\alpha(G)}$\n  定理10.7\n对于每个图G，我们都有$\\chi(G)\\leq 1+\\Delta(G)$ (其中$\\Delta(G)$表示的是图G的最大度)\n  定理10.8 Brooks定理\n对于每个非奇圈也非完全的连通图G，有$\\chi(G)\\leq\\Delta(G)$\n  定理10.9\n对于每个图G，\n​\t$\\chi(G)\\leq 1+max{\\delta(H)}$ （$\\delta(G)$表示G的最小度）\n其中max取遍G的所有诱导子图H\n 图G的影子图(shadow graph)S(G) 是指通过在G中，对每个顶点v，增加一个顶点v'，称为v的影子顶点(shadow vertex)，并连接v’在v中的所有邻点所得到的图（此时v不与原本G中对应的邻点相连）\n 定理 10.10\n对于每个整数$k\\geq 3$,都存在 一个色数为k的无三角的图\n ","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A33/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9D%80%E8%89%B2/","tags":null,"title":"平面图与图着色"},{"categories":null,"contents":" 对应教材：Sutton \u0026amp; Barto's book Reinforcement Learning: An Introduction (2nd Edition) Chap1\n Reinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal\nThe history is the sequence of observations, actions, rewards $$Ht = O_1, R_1, A_1, ..., A_{t−1}, O_t, Rt$$\nState is the information used to determine what happens next, Formally, state is a function of the history: $$S_t = f (H_t)$$\nAn RL agent may include one or more of these components: Policy: agent’s behaviour function Value function: how good is each state and/or action Model: agent’s representation of the environment\nDeterministic policy: $a = π(s)$ Stochastic policy: $π(a|s) = P[A_t = a|S_t = s]$\nValue function is a prediction of future reward. Used to evaluate the goodness/badness of states\nA model predicts what the environment will do next $P$ predicts the next state $R$ predicts the next (immediate) reward, e.g. $$P^a_{ss'} = P[S_{t+1} = s'| S_t = s, A_t = a]$$ $$R^a_s = E [R_{t+1} | S_t = s, A_t = a]$$\n","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A01/","tags":null,"title":"强化学习-介绍"},{"categories":null,"contents":"Redundant Array of Inexpensive Disks(RAID): 独立磁盘冗余阵列，通常简称为磁盘阵列\n评价维度 capacity：given a set of N disks each with B blocks, how much useful capacity is available to clients of the RAID\nreliability：How many disk faults can the given design tolerate\nperformance\nRAID-0：striping RAID-0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。\n将每一行的block称为是一个stripe\n也可能是按照chunk来排列，比如一个block为4kb，如果我一个chunk取8kb，将是如下情况：\nRAID-1:Mirroring RAID-1 采用镜像技术,同时在阵列中产生两个完全相同的数据副本，分布在两个不同的磁盘驱动器组上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。\nRAID1+0 RAID0+1 RAID Level 4: Saving Space With Parity 对每一bit做奇偶校验存在一个专门的磁盘的对应bit上\n对于sequential write，先计算出P，然后直接一次写一个stripe\n对于random wirte，将面临如何一边写一边改P，对应的有两种方式： additive parity: 先将其余盘的所有对应的block读出来然后计算P，然后同时写对应block与P，这样的缺点是当disk比较多的时候需要大量的读次数 subtractive parity: 就是看要覆盖的block和要写的block对应bit是否相同，如相同，则对应p不变，如不同则翻转p值，即$P_{new} = (C_{old} ⊕ C_{new}) ⊕ P_{old}$ 在性能分析时，我们分析subtractive parity， 虽然可以并行的读data disk 但是由于parity disk只有一个，故而只能依次来进行（small-write problem），同时每个周期需要读一次写一次，故而只有r/2\nRAID Level 5: Rotating Parity summary To conclude, if you strictly want performance and do not care about reliability, striping is obviously best. If, however, you want random I/O performance and reliability, mirroring is the best; the cost you pay is in lost capacity. If capacity and reliability are your main goals, then RAID-5 is the winner; the cost you pay is in small-write performance. Finally,if you are always doing sequential I/O and want to maximize capacity,RAID-5 also makes the most sense.\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/","tags":null,"title":"持久数据的可靠性"},{"categories":null,"contents":"一些基本定理 除法定理 ： 对于任何整数a与任何正整数n，存在唯一整数q和r，满足$0 \\leq r \u0026lt; n$, 且 $a = qn +r$\n$gcd(a,b) = ar+bs$\n如果任意整数a，b都不为0，那么$gcd(a,b)$为a和b的线性组合集{$ax+by: x,y \\in Z$}中的最小正元素\n$gcd(a,0) = |a|$\ngcd递归定理： $gcd(a,b) = gcd (b, a\\mod b)$\n若x，y为满足$ax+ny=1$的整数，则a在$Z_n$中的乘法逆元是 x mod n\n扩展欧几里得算法 求解$d = gcd(a,b) = ax+by$, 算法返回值为$(d,x,y)$\n模运算 $Z^*_n = {[a]_n : gcd(a,n)=1}$\n$Z^*_n $的规模表示为$\\phi(n)$, 且\n$$\\phi(n) = n \\prod_{p为能整除n的素数}(1-\\frac{1}{p})$$\n中国剩余定理 计算满足$a_i = a\\mod n_i$的a：\n​\t取$m_i = n / n_i$(其中$n=n_1n_2*...*n_k$) ​\t定义$c_i = m_i(m_i^{-1} \\mod n_i)$ ​\t$a = (a_1c_1+a_2c_2+..)\\mod n$\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/","tags":null,"title":"数论基础及数论算法"},{"categories":null,"contents":"基本概念 每一个file都有一个low-level name， 一般我们指inode number,\ndirectory：存储a list of pairs (user-readable name, low-level name)\n UNIX/Linux的File System Hierarchy标准规定了文件系统目录树中各个目录的功能：\n /boot - 系统启动数据 /bin - 应用程序 (bash, ps, grep, ...) /dev - 设备文件 /sbin - 系统程序 (mkfs, fdisk, ifconfig, dhclient, ...) /etc - 配置文件 (= \u0026quot;etcetera\u0026quot;) /home - 用户目录 /lib - 库文件 (libc.so, libpthread.so, ...) /media - 可移动设备 (cdrom, USB flash ,...) /usr - 用户程序 (/usr/bin/, /usr/lib/, /usr/local/) /var - 可变文件 (logs, snapshots, ...) /tmp - 临时文件   File System Interface Creating files int fd = open(\u0026quot;foo\u0026quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);\nO_CREAT :creates the file if it does not exist, O_WRONLY: ensures that the file can only be written to, and, O_TRUNC: if the file already exists, truncates it to a size of zero bytes thus removing any existing content\nReading And Writing Files cat :dump the contents of the file to the screen.\n...(还有一些 不想抄了)\nShared File Table Entries: fork() And dup() dup() call allows a process to create a new file descriptor that refers to the same underlying open file as an existing descriptor.\nWriting Immediately With fsync() fsync(int fd). When a process calls fsync() for a particular file descriptor, the file system responds by forcing all dirty (i.e., not yet written) data to disk, for the file referred to by the specified file descriptor.\nrename rename(char*old, char *new), call is that it is (usually) implemented as an atomic call\nGetting Information About Files stat() or fstat()\nReading Directories opendir(), readdir(), and closedir()\nreaddir()得到以下结构体： Hard Links link() system call takes two arguments, an old pathname and a new one; when you “link” a new file name to an old one, you essentially create another way to refer to the same file. The command-line program ln is used to do this\nlink后的两个指向相同的inode number，对于文件系统而言，对用户可见的名字不同没有关系，因为他们指向相同的内部的结构metadata，这个是根据inode number来查找的\n当你删除一个文件的时候，会调用unlink()，将检查对应inode number对应的reference count（link count），并将其减少1，只有其变为0的时候，才会free掉对应的数据结构\nSymbolic Links(soft links) The way a symbolic link is formed is by holding the pathname of the linked-to file as the data of the link file\nMaking And Mounting A File System mkfs：give the tool, as input, a device (such as a disk partition, e.g., /dev/sda1) and a file system type (e.g., ext3), and it simply writes an empty file system, starting with a root directory, onto that disk partition.\nmount完成的工作是把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里。\n文件系统实现 VSFS(Very Simple File System) Overall Organization 我们假设以4kb为一个block，现在我们假设有一个非常小的disk，只有64个block，考虑其应该有的组成 a) 首先必然存储数据且应该是大部分block都存储数据 b）对于每一个文件，都应该有一个inode c）需要有一个分配结构来追踪每一个data或者inode的block是否为free，有多种实现方式，如链表，此处采用bitmap的方式，每一个bit为0/1表示对应的block是否被占用，此处应有两个bitmap，data和inode各一个 d）一个superblock， 用于存储关于这个文件系统的信息，如有多少各inode和data blocks，inode table从哪里开始等（当挂载一个文件系统的时候，首先读superblock的信息来初始化各种参数）\nFile Organization: The Inode Inode: index node\n每一个inode都会被一个数字所指代（i-number），在操作系统中，给你这个数字，你可以直接计算出在这个磁盘中对应inode的位置\ninode有多种存储方式，如下：\n 连续存储在文件系统中的某个区域，这样可以直接根据inode的编号计算出inode在磁盘中的位置，这也是实现文件唯一id的一个途径；（上图采用的方式） 存储在文件头部，文件唯一id = 第一个数据块的编号； 存储在目录文件中，文件唯一id = 第一个数据块的编号，在支持链接的文件系统中，文件的元数据会有多份拷贝。  在inode中，几乎存储了所有关于其对应文件的信息，我们将这些信息称为metadata,\n包括\n 文件的唯一id； 文件的类型，用于区分普通文件和目录文件； 访问权限，就是大家熟知的rwxrwxrwx； 所有者信息 (uid, gid)，但这在跨系统访问时成为很大的麻烦； 文件大小； 文件访问的时间信息：创建时间、访问时间、修改时间； 链接数量 (刚才已经提到)； 一些其他信息，例如文件的第一个数据块的编号等  一种inode存储的信息示例如下：\n在inode中有一个重要信息是指向文件data所在block的地址的指针，一种实现方式是采用direct pointer，但是这样对于较大的文件，存储在多个不同的block中时会比较麻烦，此时一种方式时采用indirect pointer,这个指针指向一个全部存储对应的direct pointer的block，而如果还要更大的话，则可以采用double indirect pointer(即指向一个全是indirect pointer的block)，如果还要更多，可以以此类推triple indirect pointer\nDirectory Organization each entry has an inode number, record length (the total bytes for the name plus any left over space), string length (the actual length of the name), and finally the name of the entry.\n目录同样被操作系统认为是一个文件，有对应的inode，只是inode中其类型为directory\nFree Space Management 在vsfs中，用的是bitmap，还可以用链表来实现，现代操作系统中有更多的实现方式如b-tree\nAccess Paths: Reading and Writing 对于一个路径，如果我们想找到对应的文件或目录的inode值，其值一般会存储在其父目录中，而**/**没有父目录，故而一般在unix系统中设置其inode值为2，找到父目录的inode之后，就根据指针找到其data区域，在data中找到其对应文件的入口，找到后，文件系统就获取的该文件的inode number，之后类似的重复直到找到对应文件为止。在open（）操作中，找到文件后，会把文件的inode读入，并在pre-process open-file table中分配一个fd给这个process。\n打开文件后如执行read操作，则会更新inode中的存储的时间变量，然后回更新fd对应的in-memory open file table，修改文件偏移量\n如果要写文件的话，要先读inode，再读bitmap，再写bitmap，分配后再写data，写完后更新inode\nFAT与ext2 断章了，见下一篇blog\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","tags":null,"title":"文件系统"},{"categories":null,"contents":"这一章 毫无打字的想法 最讨厌打公式了的说(╯°Д°)╯︵┻━┻\n28.1 求解线性方程组 对于线性方程组，设$A=(a_{ij}),x=(x_i),b=(b_i)$,记为 $Ax=b$, 若A为非奇异矩阵，则其具有逆向量，于是$x=A^{-1}b$ 是其解向量。若A的秩为n， 若方程数目少于n，则其是**欠定的**，若多于，则为**超定的**\nLUP分解综述 LUP分解就是要找到三个$n \\times n$ 的矩阵L,U,P，从而满足 $PA=LU$, 其中L是一个单位下三角矩阵，U是一个上三角矩阵，P是一个置换矩阵。满足要求的L,U,P被称为是矩阵A的LUP分解，每一个非奇异矩阵A都有这样一种分解。\n求解Ax=b时，将其转化为$LUx=Pb$, 进而设$y=Ux$, 通过正向替换的方法求解下三角系统$Ly=Pb$ 得到未知向量y, 然后通过一种反向替换的方法来求解上三角系统$Ux=y$ 得到未知向量x，此时的x就是解向量。\n正向替换与反向替换 重写等式，替换，代入。\n上算法中，我们假定维数n出现在属性L.rows中，置换矩阵P使用数组$\\pi$表示\n计算一个LU分解\n分解$A=LU$, 我们利用高斯消元法来创建一个LU分解\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A33/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/","tags":null,"title":"矩阵计算"},{"categories":null,"contents":" 参考阅读\n 终端默认是“cooked mode”，即自带一个“行编辑器”，只有按下回车键，read系统调用才返回\nshell执行程序 int pid = fork(); if (pid == 0) { // 管道、重定向、……  execve(...); } else { if (!endswith(\u0026#34;\u0026amp;\u0026#34;)) { wait(NULL); } } ","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%88%E7%AB%AF%E4%B8%8Eshell/","tags":null,"title":"终端与shell"},{"categories":null,"contents":" 参考书籍：\n 群论-李新征讲义 Thomas Judson: Abstract Algebra - Theory and Applications, 2018.   群 群：设𝐆是一些元素（操作）的集合，记为𝐆 = {⋯，g，⋯}，在𝐆中定义了乘运算，如果𝐆中元素对这种运算满足下面四个条件：\n 封闭性：∀两个元素（操作）的乘积仍属于这类元素（操作）的集合 结合律：对∀三个元素（操作）𝐟、𝐠、𝐡，有(𝐟𝐠)𝐡 = 𝐟(𝐠𝐡) 有唯一单位元素 e，使得对∀𝐟 ∈ 𝐆，有𝐞𝐟 = 𝐟𝐞 = 𝐟 对∀𝐟 ∈ 𝐆，存在且唯一存在$𝐟^{−𝟏}$属于 G，使$𝐟^−𝟏𝐟$ = $ 𝐟𝐟^{−𝟏} $ = 𝐞； 这时我们称𝐆是一个群，其中元素是群元，𝐞为其单位元素，$𝐟^{−𝟏}$为𝐟的逆。  有限群： 群内元素的个数称为群的阶，群阶有限时称为有限群\nAbel群：群内的运算可以互换（可以看出abel群的乘法表都是关于对角线对称的）\n重排定理：设𝐆 = {⋯，$𝐠{𝛂}$，⋯}，对∀𝐮 ∈ 𝐆，当$ 𝐠_𝛂 $取遍𝐆中所有元素时，$𝐮𝐠_𝛂$给出且仅仅一次给出𝐆中所有元素。\n子群与陪集 子群：设 H 是群 G 的一个子集（部分元素的集合），若对群 G 相同的乘法运算，H 也构成一个群，则称 H 为 G 的子群。 要证明一个群为子群，只需要证明其封闭性与每个元素唯一逆即可，单位元可以通过封闭性得证，结合律必然成立\nn 阶循环群：它的定义是$a^n = e$，由${a、a^2、⋯ 、a^{n−1}、a^n = e}$组成。这样的群是 Abel 群，乘法可易。\n群元的阶：对任意一个有限群𝐆，从中取一个元素𝐚，从𝐚出发作幂操作，总是可以构成𝐆的一个循环子群$𝐙_𝐤$的，这个𝐙𝐤等于${𝐚、𝐚^𝟐、 ⋯、𝐚^{𝐤−𝟏}、𝐚^𝐤 = 𝐞}$，这时称𝐤（满足这个性质的最小的𝐤）为群元𝐚的阶。\n陪集：设𝐇是群𝐆的子群，𝐇 = {$𝐡_𝛂$}，由固定的𝐠 ∈ 𝐆，可生成子群𝐇的左陪集：$𝐠𝐇 = {𝐠𝐡_𝛂|𝐡_𝛂 ∈ 𝐇}$，也可生成子群𝐇的右陪集：𝐇𝐠 = {$𝐡_𝛂𝐠|𝐡_𝛂 ∈ 𝐇$}。\n陪集定理：设群𝐇是群𝐆的子群，则𝐇的两个左（或右）陪集或者完全相同，或者没有任何公共元素。\n拉格朗日（Lagrange）定理：有限群子群的阶，必为群阶的因子。\n类与不变子群 共轭：所谓共轭，指的是群𝐆中两个元素𝐟、𝐡，如果在𝐆中存在一个𝐠，使得𝐟、𝐡可以通过$𝐠𝐟𝐠^{−𝟏} = 𝐡$联系起来，则称𝐟、𝐡共轭，记为𝐟~𝐡。\n 类：群 G 中所有相互共轭的元素形成的集合，称为群 G 的一个类。\n 一个群中的单位元素自成一类，因为对任意 f 属于 G，$fef^{−1} = e$； Abel 群的所有元素都自成一类，因为对任意 f 属于 G，取任意 h 属于 G，$hfh^{−1} = hh^{−1}f = f$； 设群元素 f 的阶为 m，即$f^m = e$，则与它同类的元素的阶也为 m  定理 1.4 有限群的每个类中元素的个数都是群阶的因子。\n共轭子群：设 H 和 K 是群 G 的两个子群，若存在 g 属于 G，使得$𝐊 =𝐠𝐇𝐠^{−𝟏} = {𝐠𝐡𝐠^{−𝟏}|𝐡 ∈ 𝐇}$。这时，称 H 和 K 是共轭子群\n正规子群：设 H 是 G 的子群，如果 H 中所有元素的同类元素都属于 H，则称 H是 G 的不变子群（数学上一般称为正规子群）。\n定理 1.5 设 H 是 G 的不变子群，那么对任意固定的 f 属于 G，当$h_α$取遍 H 中所有元素的时候，$fh_αf^{−1}$给出且仅仅一次给出 H 中所有元素 实际上，所有 Abel 群的子群都是其不变子群。因为每个元素自成一类，其同类元素自然在这个子群中\n定理 1.6 不变子群的左陪集与右陪集是重合的。 不变子群的陪集还有另外一个更加重要的性质，就是两个（非子群的）不同陪集中元素的乘积，必为第三个陪集中的元素。这个说的是什么呢？就是H是G的不变子群，由H，可将G分解为G={g0H、g1H、g2H、…}。这样的话在这一系列的陪集中，取giH与gjH这两个陪集中的元素gihα与gjhβ相乘，结果是这样的：当giH与gjH都不是g0H时，必属于giH与gjH外的另一个陪集；当giH、gjH其中一个是g0H时，必属于giH与gjH中的另一个；giH与gjH都是g0H时，必属于g0H。\n同态与同构 同构映射：若从群 G 到群 F 上，存在一一对应的满映射$\\Phi$，且这个映射本身保持群的乘法运算规律不变，也就是说 G 中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同构，记作 G≅F。映射$\\Phi$ 称为同构映射。\n群 G 的两个互为共轭的子群H与K，由定义，是存在一个固定的 g 属于 G，使得对任意的hα ∈ H，都有$k_α = gh_αg^{−1} \\in K$与之对应。这个对应关系是一对一的，同时单位元素对应单位元素，互逆元素对应互逆元素。所以同一个群的两个共轭子群同构。\n同态：设存在从群 G 到群 F 的满映射（注意，没有一对一了）𝚽，且这个映射本身保持群的乘法运算规律不变，也就是说G中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同态，记作 G~F。映射𝚽称为同态映射。\n同态核：设 G 与 F 同态，那么 G 中与 F 的单位元素对应的所有元素的集合称为同态核。\n（同态核定理）设 G 与 F 同态，则有：\n 同态核 H 是 G 的不变子群； 商群 G/H 与 F 同构。  第一同态定理: 若$\\varphi:G\\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\\phi:G\\to G/K$是规范同态函数。则存在唯一的同构函数$\\eta:G/K\\to\\varphi(G)$使得$\\varphi=\\eta\\phi$\n规范同态函数产生的商群与原同态函数的像同构\n第二同态定理: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\\cap N$是$H$的正规子群，且$$H/H\\cap N\\cong HN/N$$ 一致性定理: 设$N$是$G$的正规子群，则$H\\mapsto H/N$是包含$N$的子群$H$的集合与$G/N$的子群的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。 第三同构定理: 设$N$和$H$是$G$的正规子群满足$N\\subseteq H$,则$$G/H\\cong\\frac{G/N}{H/N}$$.\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E7%BE%A4%E8%AE%BA%E5%9F%BA%E7%A1%80/","tags":null,"title":"群论基础"},{"categories":null,"contents":"基本概念 $$ε_A(x)=\\dfrac{|cost(A(x))−OptU(x)∣}{Opt_U(x)}$$\n$$R_A(x)=max{OptU(x)/cost(A(x)),costA(x)/OptU(x)}.$$\nNPO问题分类 NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)\nNPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)\nNPO(III): 包含所有$U∈NPO$ 满足：\n 对某些δ\u0026gt;1存在多项式时间的δ−近似算法 对某些d\u0026lt;δ不存在多项式时间的的d−近似算法 i.e.U没有PTAS  NPO(IV): 包含所有$U∈NPO$满足：\n满足：\n 对某些f:N→R+,存在多项式时间的f(n)−近似算法,其中f以某个多项式函数为界  对任意$δ∈R^+$不存在任何多项式时间的δ−近似算法 e.g.集合覆盖问题    NPO(V): 包含所有$U∈NPO$，满足若存在多项式时间的f(n)−近似算法，则f(n)不以任何多项式函数为界(e.g. TSP, 最大团问题)\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/","tags":null,"title":"近似算法"},{"categories":null,"contents":"基本概念 $RandomA(x):$ 对于所有A在x上的随机计算中使用的random bits的最大数量 $Prob_{A,x}(C)$: 某一次AA对输入xx的计算CC, 由相应的随机序列的概率决定 $Prob(A(x)=y)$: A 对于输入x输出y的概率 $Time(C)$: the time complexity of the run C of A on x\n随机算法 Las Vegas Algorithms 要么给出问题的正确答案，要么得不到答案\n$$Prob(A(x)=F(x))⩾ \\frac{1}{2}$$,and $$Prob(A(x) = “?”) = 1 - Prob(A(x) = F(x)) \\leqslant \\dfrac{1}{2}.$$\nOne-Sided-Error Monte Carlo Algorithms for every $x \\in L$, $Prob(A(x) = 1) \\geqslant \\dfrac{1}{2}$, and for every $x \\notin L$, $Prob(A(x) = 0) = 1$ 跑k次，只要有一次输出1，则其必然为1，若均为0，则出错概率小于$(1/2)^k$, (只会单向出错)\nTwo-Sided-Error Monte Carlo Algorithms $Prob(A(x)=F(x))⩾ \\dfrac{1}{2}+ε$.\n跑t次，输出至少出现了$\\lceil t/2 \\rceil$ 次的结果\nUnbounded-Error Monte Carlo Algorithms $Prob(A(x)=F(x)) \u0026gt; \\dfrac{1}{2}$.\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/","tags":null,"title":"随机算法"}]