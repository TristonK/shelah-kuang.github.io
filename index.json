[{"categories":null,"contents":"他们都把家庭看作是实现个人幸福的地方，而且家庭成员之间的情感是维系家庭的主要途径。同时，他们还相信理想的家庭幸福可以通过家庭成员之间努力增进的理解和感情来实现。 包含的意义有两重，一个是家庭生活中个人幸福的重要性，一个是每个个体本身的重要性，但是在现有的中国家庭研究中，这两重意义都没有得到应有的重视。\n","permalink":"http://tristonk.com/notes/%E7%A7%81%E4%BA%BA%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8F%98%E9%9D%A9/section1/","tags":null,"title":"导论：中国家庭模式与私人生活的研究"},{"categories":null,"contents":"根据物体导电能力(电阻率)的不同，来划分导体、绝缘体、半导体\n半导体是一种导电能力介于导体和绝缘体之间的物质，他的导电能力和温度，光照或掺杂浓度有关\n典型的半导体：硅Si、锗Ge、砷化镓GaAs\n  本征半导体：化学成分纯净的半导体，在物理结构上呈现单晶体形态(纯度达到9个9)\n  本征激发：半导体受热或者光照激发时，某些电子从外界获得能量而挣脱共价键的束缚，离开原子称为自由电子，同时在共价键中留下相当数量的空穴\n 空穴：共价键中的空位 电子空穴对：由热激发而产生的自由电子和空穴对    本征半导体的缺点：载流子少，导电性差，温度稳定性差\n  载流子：可以自由移动的带电粒子\n  导电率：与材料单位体积中所包含的载流子数有关，载流子浓度越高，电导率越高\n  空穴的运动是靠相邻共价键中的价电子依次填充空穴来实现的。复合\n在温度一定时，本征激发和复合会达到动态平衡\n半导体的重要特性：\n 本征半导体中的自由电子和空穴总成对产生，由自由电子-空穴对随温度增高而显著增加 空穴的导电作用  杂质半导体 杂质半导体：在本征半导体中掺入某些微量元素作为杂质，可使半导体的导电性发生显著变化。掺入的杂质主要是三价或者五价元素，掺入杂质的本征半导体称为杂质半导体\n P型半导体：掺入三价杂质元素(硼、镓、铟等) N型半导体：掺入五价杂质元素(磷等)  N型半导体  因为五价杂质原子中只有四个价电子能和周围四个半导体原子中价电子形成共价键，而多余的价电子因为无共价键束缚而容易形成自由电子 自由电子(n)是多数载流子（所以是Negative），主要由杂质原子提供 空穴(p)是少数载流子，由热激发产生 如果一个半导体性质和多子有关，那他和温度关系不大，如果只和少子有关，那受温度影响很大 五价杂质离子称为施主离子：$n=p+N_D$  P型半导体  因为在形成共价键时缺少价电子在共价键中留下了一个空穴 空穴是多数载流子 自由电子是少数载流子 三价杂质称为受主杂质:$N_A+n=p$  载流子的漂移与扩散  漂移电流：电场作用下，载流子在电场作用下的漂移运动形成的电流 扩散电流：因为浓度差载流子从浓度高处向浓度低处扩散形成的电流  PN结 将一个N型半导体和一个P型半导体联结在一起： 因为浓度差导致了多子的扩散运动，从而产生了由杂质例子形成的空间电荷区，从而产生了内电场，内电场促使少子漂移，阻止多子扩散，最后多子的扩散和少子的漂移达到了动态平衡\n对于在P型半导体和N型半导体结合面，离子薄层所形成的空间电荷区称为PN结，在空间电荷区，由于缺少多子，也称为是耗尽层\nPN结 = 空间电荷区 = 耗尽层 = 势垒区 = 非线性电阻\nPN结的单向导电性   正向电压(正偏)：与内电场方向相反。低电阻，大的正向扩散电流。\n  反向电压(反偏)：与内电场反向相同。高电阻，很小的反向漂移电流。使得PN结越来越大。\n 在一定温度情况下，由本征激发决定的浓度是一定的，故而少子形成的漂移电流恒定，基本与反向电压大小无关，电流称为反向饱和电流    V-I特性： $i = I_s(e^{U/U_T}-1)$ 其中$U_T$是一个温度的电压当量，室温下$U_T=26mV$，U是所加的电压，$I_S$是反向饱和电流，\n导通电压：Ge 0.2-0.3V ； Si: 0.6-0.7V\nPN结的反向击穿 Ge管的反向饱和电流比Si大\n反向电压增加导一定数值，反向电压突然快速增加，称为PN结的反向击穿\n 电击穿(可逆)  雪崩击穿：较大的电场与PN结宽度让载流子获得动能，继而与晶体原子碰撞导致束缚在共价键中的价电子碰撞出来，具有正的温度系数 齐纳击穿：发生在掺杂浓度比较高的PN结中，此时空间电荷层比较薄，此时一个很小的反向电压就可以在空间电荷区内建立一个很强的电场，能够把价电子从共价键中拉出来，具有负的温度系数   热击穿(不可逆)  因为PN结的反向电流在很大的电压范围内电流不变，所以可以做稳压电路\nPN结的扩散电容 扩散电容$C_D$:取决于少子，正向偏置时较大，反向偏置时较小。(非平衡少子的变化)\n势垒电容$C_B$:取决于多子，不是线性变化的\n PN结正向偏置时，结电容较大，主要取决于扩散电容 PN结反向偏置时，结电容较小，主要取决于势垒电容  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86%E5%9F%BA%E7%A1%80/","tags":null,"title":"半导体物理基础"},{"categories":null,"contents":"Twelvfold way    Elements of N Elements of M Any f (unstricted) Injective (1-1) f Surjective (on-to) f     不同的 不同的 $m^n$ $(m)_n$ $m!{{n \\atop m}}$   相同的 不同的 $\\big(\\binom{m}{n}\\big)$ $\\binom{m}{n}$ $\\binom{n-1}{m-1}$   不同的 相同的 $\\sum_{k=1}^m{{n \\atop k}}$ $\\begin{cases} 1\u0026amp;\\text{if } n\\leq m\\0\u0026amp;\\text{if }n\u0026gt;m \\end{cases}$ ${{n \\atop m}}$   相同的 相同的 $\\sum_{k=1}^mp_k(n)$ $\\begin{cases} 1\u0026amp;\\text{if } n\\leq m\\0\u0026amp;\\text{if }n\u0026gt;m \\end{cases}$ $p_m(n)$    Basic Enumeration 三条基本规则：\n the sum rule: 对于不相交集合S,T，有$|S\\cup T| = |S|+|T|$ the product rule: 有限集合：$|S\\cdot T|=|S|\\cdot |T|$ bijiection rule: 如果S,T构成双射，则$|S|=|T|$  1.1 Tuples $[m] = {0,1,2,..m-1}$\n相当于n个不同的球随机放到不同的盒子中，为$[m]^n = m^n$\n1.2 Functions Num of functions from $[n]$ to $[m]$ is $m^n$\n如果是单射的话，则是有$(m)_n = m(m-1)..(m-n+1)=\\frac{m!}{(m-n)!}$种可能性\n1.3 subsets 幂集:$2^{[n]}={S|S\\subseteq [n]}$\n幂集的大小：对应一个n位的数可以去0或1，大小为$2^n$\n1.4 subsets of fixed size $\\binom{n}{k}=\\frac{n!}{k!(n-k)!}$\n1.5 binomial coeffcient Binomial theorem: $(1+x)^{n}=\\sum _{k=0}^{n}{n \\choose k}x^{k}$\n1.6 compositions of an integer 把一个整数分成若干个有序（即区分盒子）的正整数之和。\n $\\binom{n-1}{k-1}$ 隔板法 也可以考虑建立对应关系 如果是分成非负数(Weak k-composition)  先补充成正整数再隔板 $\\binom{n+k-1}{k-1}$    1.7 multisets multiset: 允许元素重复的集合\nk-multiset：\n 等价于n个篮子放k个相同的球 使用m(x)标识x在k-multiset中出现的次数 故而问题转化为$m(x_1)+..+m(x_n)=k$ 相当于一个weak n-compostion of k 记为$\\big(\\binom{n}{k}\\big)=\\binom{n+k-1}{n-1}=\\binom{n+k-1}{k}$  1.8 multinomial coeddicients 将n个不同球放到k个不同的篮子中，第i个篮子中有$m_i$个\n$\\binom{n}{m_1,m_2,..m_k}=\\frac{n!}{m_1!m_2!..m_k!}$\n${n \\choose a_{1},a_{2},\\ldots ,a_{m}}$ is the coefficient of $ x_{1}^{a_{1}}x_{2}^{a_{2}}\\cdots x_{m}^{a_{m}}$ in $(x_{1}+x_{2}+\\cdots +x_{m})^{n}$.\n1.9 partions of a set 类似于把n个人分到k艘不同的船上\n${{n \\atop k}}$: $#$ of k-partition of an n-set（Stirling number of the second kind）\n存在性质${{n\\atop k}} = k{{n-1 \\atop k}}+{{n-1\\atop k-1}}$ （理解：可以考虑最后一个元素{n}如果他是单独的一个子集，则是后一种，否则是式子中前面一种情况，可以考虑把他放到k个子集中的一个）\n令$B(n)=\\sum_{k=1}^n{{n \\atop k}}$,即一个n-set的所有种分法(**bell number**)\n1.10 partitions of a number 令$p_k(n)$表示把整数n分成k个正整数之和的分法（与1.6的区别在于此处不区分顺序类比的即不区分盒子）\n不失一般性的，我们不妨假设$x_1\\geq x_2..\\geq x_k \\geq 1$\n令$p(n)=\\sum_{k=1}^np_k(n)$ 为**partition number**\n存在性质$p_k(n)=p_{k-1}(n-1)+p_{k}(n-k)$（考虑$x_k$是大于1还是等于1，若等于1为前者，若大于1则考虑把每个数都减去1即后者）\n1.11 ferrers diagram 考虑将上面整数的分解看成若干个格子的拼凑，现在将其翻转一下就从可以分成k份变成了可以分成若干份，最大的一份为k\n$p_k(n)=\\sum_{j=1}^kp_j(n-k)$\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/basic-enumeration/","tags":null,"title":"Basic Enumeration"},{"categories":null,"contents":"计算机网络与因特网 1.1 什么是因特网 回答什么是因特网：\n 因特网的具体构成，即因特网的基本硬件与软件组件 根据为分布式应用提供服务的联网基础设施来描述  1.1.1 具体构成描述 主机或者端系统: 与因特网相连的设备\n端系统通过通信链路(不同类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱)与分组交换机(常见类型有路由器和链路层交换机，其中链路层交换机常用于接入网中，而路由器通常用于网络核心中)连接在一起\n链路的传输速度：比特/秒(bit/s或者bps)\n分组：端系统向其他端系统发送信息时，发送端系统将数据分段，并为每段加上首部字节，由此形成的数据包叫做分组\n一个分组经过的一系列通信链路和分组交换机称为通过该网络的路径\n因特网服务提供商：ISP\n每个ISP就是一个多台分组交换机和多段通信链路组成的网络\n端系统、分组交换机和其他因特网部件要运行一系列协议，这些协议控制因特网中信息的接收和发送。TCP(传输控制协议)和IP(网际协议)是最重要的两个协议。因特网的主要协议统称为TCP/IP协议。\n因特网标准由IETF研发，IETF的标准文档被称为请求评论(RFC).但也有其他组织在研发，如IEEE 802 LAN/WLAN提出的以太网和无线WIFI的标准\n1.1.2 服务描述 分布式应用程序：设计多个相互交换数据的端系统\n因特网应用程序运行在端系统上而不在网络核心的分组交换机(加速数据交换)上\n端系统提供了套接字接口，规定了运行在一个端系统上的程序请求基础设施向另一个端系统上的特定目的地程序交付数据的方式。\n1.1.3 什么是协议 协议定义了在两个或多个通信实体之间交换报文的格式与顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。\n1.2 网络边缘 端系统位于网络边缘\n主机有时进一步分为两类：主机与服务器\n1.2.1 接入网 接入网：端系统物理连接到其边缘服务器的网络\n边缘路由器：端系统到任何其他远程端系统路径上的第一台路由器\n家庭接入网  数字用户线(digital subscriber Line,DSL)  从本地电话公司获取，ISP：本地电话公司 DSL调制调解器利用现有的电话线(双绞铜线)与位于电话公司本地中心局(CO)中的数字用户接入复用器(DSLAM)交换数据。DSL调制调解器得到数字数据后转化为高频音，以通过电话线传输给本地中心局。 使用频分复用技术(不同频率编码)使得电话呼叫和因特网连接共享一根线   电缆因特网接入(cable Internet access)  使用有线电视公司的有线电视基础设施，应用光纤和同轴电缆，称为混合光纤同轴系统(HFC) 需要特殊的调制调解器：电缆调制调解器 电缆调制调解器系统(CMTS)将HFC分为上行和下行两个信道 共享广播媒体，故而需要一个分布式多路访问协议来细条传输和避免碰撞   光纤到户(FTTH)  从中心局直接到家庭提供一条光纤路径 直接光纤：从本地中心局到每户设置一根光纤，或者中心局出来的每个光纤多个家庭共享一直到接近家庭的位置光纤猜分成每户一根。分配方案有两种  主动光纤网络(AON)：本质上是交换因特网 被动光纤网络(PON) ：每个家庭有一个光纤网络端接器(ONT),由专门的光纤连接到附近的分配器，分配器把一些家庭集结到一根共享的光纤，这根光纤连接本地电话和公司的中心局中的光纤线路端接器(OLT)，该OLT提供了光信号和电信号之间的转换。     卫星链路  企业(和家庭)接入 局域网:LAN\n以太网是最流行的局域网接入技术\n基于IEEE 802.11技术的无线LAN接入：WiFi\n广域无线接入：3G与LTE 1.2.2 物理媒体 物理媒体包括了导引型媒体(电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆)和非导引型媒体(在空气或者外层空间传播，如无线局域网)\n1.3 网络核心 网络核心：互联网端系统的分组交换机和链路构成的网状网络\n1.3.1 分组交换 端系统彼此交换报文(message)。源将长报文分成较小的数据块，称之分组。每个分组经过通信链路和分组交换机交换，分组以等于该链路最大传输速率的速度通过通信链路。假设传输 L 比特的分组，链路速度为 R bps，那么传输该分组时间为 L/R 秒\n存储转发传输 多数分组交换机在链路的输入端使用存储转发传输机制，即在交换机能够开始向输出链路传输该分组的第一个比特之前须接收到整个分组。\n如果不考虑传播时延，通过N哥速率为R的链路组成的路径，端到端时延为N(L/R)\n排队时延与分组丢失 每个分组交换机有多条链路，对于每条链路分组交换机有一个输出缓存(也叫输出队列)，用于存储路由器准备发完那条链路的分组。如果链路正在传输其他的分组，那么该分组必须在输出缓存中等待。如果到达的分组发现缓存已经充满了，那么会出现丢包现象，到达的分组或者队列中的分组之一将被丢弃。（接近满时概率丢包）\n转发表与路由选择协议 每个端系统有一个IP地址，路由器有一个转发表，将目的地址或目的地址的一部分映射成输出链路。分组到达时，利用目的地址搜索转发表，找到出链路，路由器将这个分组导向该出链路。\n路由选择协议用于自动的设置转发表。\n1.3.2 电路交换 端系统的通信会话期间，预留了端系统间沿路径通信所需要的资源(如缓存、链路传输速率)。\n例子:传统的电话网络\n电路交换网络在能够发送信息之前，必须在发送方和接收方之间建立一条连接，此时沿着发送方和接收方之间路径上的交换机都会为该连接维护连接状态。该连接称为一条电路(circuit)。创建电路时，在连接期间为该网络预留了恒定的传输速率，发送方以确保的恒定速率向接收方传送数据。\n复用现象：\n  频分复用(FDM):频谱由所有连接共享，连接期间每条连接专用一个频段。频段宽度称为带宽\n  时分复用(TDM):时间划分为固定的帧，每个帧划分成固定数量的时隙，创建连接时，网络在每个帧中指定一个时隙提供给这个连接单独使用。电路的传输速率为帧速率乘以一个时隙中的比特数。\n  TDM较FDM的好处在于FDM 需要相应的硬件设施来将信号转化为合适的频段，而TDM 只需要选择帧中合适的时隙就\n可以了。\n  分组电路和交换电路的对比：\n 电路交换电路是确保传输的，而分组交换是尽最大努力以实时方式交付分组但是不做任何保证 分组交换的优点：  1)提供了更好的带宽共享，电路交换预先分配使得已分配而不需要的链路时间未被利用，而分组交换按需分配使用电路 2)比电路交换更简单有效，创建端到端电路和预留带宽是复杂的，需要复杂的信令软件来协调   但是分组时延的端到端时延是可变和不可预测的，而电路交换保证能以确定速率传输  1.3.3 网络的网络 除了第一层ISP之外，任何ISP可以选择多宿,即选择多个提供商ISP连接\n1.4 分组交换网中的时延、丢包与吞吐量 吞吐量：每秒可以传送的数据量\n1.4.1 分组交换网中的时延概述 节点总时延：\n 节点处理时延：检查分组首部和决定分组导向何处，检查比特级别差错，处理后导向路由器B之前的队列 排队时延：在链路上等待传输。微秒到毫秒级。 传输时延：将所有分组的比特推向链路需要的时间，为L/R。毫秒级到微秒级 传播时延：链路起点到路由器B的传播时延  1.4.2 排队时延和丢包 假设a表示分组到达队列的速率(分组/秒)，L表示分组的大小(bit),那么La表示比特到达队列的平均速率(bps). 假设R表示传输速率(即队列中推出比特的速率，bps)。\n定义流量强度：La/R。在流量工程中，流量强度不能大于1.随着流量强度接近1，平均排队时延快速增长。\n1.4.3 端到端时延 如果不考虑排队时延 $$d_{end-end} = N(d_{proc}+d_{trans}+d_{prop})$$\n1.4.4 吞吐量 瞬时吞吐量：接收文件的瞬时速率\n平均吞吐量：F/T（接收F比特用了T秒)\n瓶颈链路：吞吐量是各个子链路的最小值\n1.5 协议层次及其服务类型 1.5.1 分层的结构体系 协议分层 每层向他的上一层提供服务，即所谓一层的服务模型，每层都在该层执行操作或者直接使用下层的服务来提供服务。\n协议栈：各层的所有协议\n 应用层  网络应用层序及他们的应用层协议停留的地方(HTTP,SMTP,FTP) 应用层的信息分组：报文(message)   运输层  在应用程序端点之间传送应用层报文 TCP：面向连接的服务(确保传递与流量控制)，提供拥塞控制 UDP：无连接服务,不提供不必要服务，没有可靠性，没有流量控制与拥塞控制 分组：报文段(segment)   网络层  运输层协议向网络层细一递交运输层报文段与目的地址，网络层负责将**数据报(datagram)**的网络层分组从一台主机移动到另一台主机 网际协议：IP协议 路由选择协议   链路层  网络层将数据报下传给链路层，链路层沿着路径将整个帧传给下一个节点，在下一个节点，链路层将数据报上传给网络层 链路层分组：帧(frame)   物理层  将帧中的比特从一个节点移动到另一个节点，这一层的协议与链路的实际传输媒体相关    OSI模型  应用层 表示层  使得通信的应用程序能够解释交换数据的含义   会话层  数据交换的定界与同步功能，包括了建立检查点和恢复方案的方法   运输层 网络层 链路层 物理层  1.5.2 封装 链路层交换机：实现了1-2层(尽管不能识别IP地址，但是可以识别第二层地址如以太网地址)\n路由器：实现了1-3层\n主机：实现了所有的5个层次\n每一个分组：首部字段+有效载荷字段(上一层的分组)\n运输层首部信息：允许接收端运输层向上向适当的应用程序交付报文的信息；差错位检测信息\n网络层首部信息：源和目的端系统系统地址\n链路层首部信息：-\n1.6 面对攻击的网络 僵尸网络：\n 病毒：需要某种形式的用户交互 蠕虫：不需要明显用户交互就能进入设备  拒绝攻击服务(DOS):使得基础设施部分不能由合法用户使用\n 弱点攻击：向目标主机运行的易受攻击的应用程序或者操作系统发送制作精细的报文 带宽洪泛：向目标主机发送大量分组 连接洪泛：向目标主机创建大量的半开或者全开的TCP连接  分组嗅探：记录每个流经的分组副本\nIP哄骗：将具有虚假源地址的分组注入因特网（解决方式：端点鉴别）\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ji-suan-ji-wang-luo-yu-yin-te-wang/","tags":null,"title":"计算机网络与因特网"},{"categories":null,"contents":"数据库系统概述  复习重点\n1.1基本概念\n 数据库，数据库管理系统，数据库系统，数据库管理员 相互之间的关系  1.2数据库系统的特点\n 数据集成化，数据独立性，数据共享，数据冗余，数据的安全性，完整性和一致性，并发控制和故障恢复  1.3数据库内部结构体系\n 数据模式 三级模式 \u0026amp; 二级映射 三级模式与数据独立性的关系   基本概念 数据库(DB): 是数据集合，具有统一的结构形式并存放在统一的存储介质中，由多种应用数据集成，并可以被应用所共享\n数据库管理系统（DBMS）：一种管理数据库的系统软件，是数据库的应用程序与数据库的接口\n数据子语言：数据定义语言（DDL）,数据操纵语言（DML）,数据控制语言（DCL）\n数据库管理员（DBA）：对数据库进行规划、设计、维护与监视的专职人员\n数据库系统（DBS）：一个以海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统。组成部分：数据库、数据库管理系统、软件平台、硬件平台\n数据库应用程序（DBAS）：利用数据库系统做应用开发所构成的集成化的独立运行系统，包括：数据库系统、应用软件、应用界面、用户\n数据库用户：最终用户（终端查询用户、应用程序的使用者），应用程序开发人员、数据库管理员\n两层C/S架构：数据库和DBMS运行在数据库服务器中，数据库运用程序运行在客户机中\n三层C/S架构：数据库和DBMS运行在数据库服务器中，数据库应用程序运行在应用服务器（Web服务器）中，用户客户端只需要安装浏览器\n数据库的基本特点 集成性：集多种应用数据为一体，表现为采用统一数据结构，建立一个全局统一的数据模式，根据每个应用的数据需要构作局部模式\n数据独立性：指数据库中的数据与使用数据的应用之间互不依赖，包括物理独立性（数据的物理结构的改变不影响数据库的逻辑结构，从而不引起应用程序变化）与逻辑独立性（数据库总体逻辑的改变，如修改数据模式、增加新的数据类型，不需要修改应用程序）\n高共享性与低冗余性：数据共享，避免数据冗余，这使得可以避免数据的不一致性（一致性：同一数据在不同出现保持相同的值）\n数据的安全性：对数据库访问者做检查以防止非法访问\n完整性：对数据库中的数据正确性做检查\n并发控制：多个应用并发访问所产生的互相干扰做控制\n故障恢复：对遭受破坏的数据具有恢复能力\n数据库内部结构体系 三级模式 外模式（也称 子模式、用户模式，对应用户数据库）：关于某个（组）用户所需数据的逻辑结构的描述，它可以由概念模式推导而出，是概念模式的一个子集，一个概念模式可以对应多个外模式。\n概念模式（简称 模式，对应概念数据库）：关于整个数据库中的数据的全局逻辑结构的描述，利用DBMS提供的数据定义语言DDL描述数据的类型、长度、特征，数据间的联系，安全性、完整性等方面的要求\n内模式（也称 物理模式，对应物理数据库）：关于数据库中数据的物理存储结构和物理存储方法的描述\n两种映射： 外模式-概念模式映射：概念模式是全局的，而外模式是用户的局部模式，每个外模式是概念模式的一个基本视图，可实现逻辑独立性\n概念模式-内模式映射：对应了概念模式中全局逻辑结构与数据的物理存储结构之间的关系，可实现物理独立性\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/introduction/","tags":null,"title":"数据库系统概述"},{"categories":null,"contents":"1 Introduction 本文档中的示例代码并不作为规范。即虽然示例代码是遵循 Google 编程风格，但并不意味着这就是是展现这些代码的唯一方式。\n2 Src基础 2.1 文件名 根据最顶层的类名来命名，大小写敏感，使用.java格式\n2.2 文件编码 UTF-8\n2.3 特殊字符 空白字符 除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，即：\n  所有其它字符串中的空白字符都要进行转义。\n  制表符不用于缩进。\n  特殊转义序列 对于具有特殊转义序列的字符(\\b, \\t, \\n, \\f, \\r)，使用其转移序列而不是使用相应的八进制或者Unicode转义\n非ASCII字符 是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。\n在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释\n{% note warning %} Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that should happen, those programs are broken and they must be fixed. {% endnote %}\n3 Src结构 一个源文件应当包括（以下按照顺序包括）：\n 许可证与版权信息（如需要） package语句 import语句 一个顶级类（只有一个）  以上每个部分用一个空行隔开\n3.2 package语句 package 语句不换行，列限制(4.4节)并不适用于 package 语句。(即package 语句写在一行里)\n3.3 import语句 不要使用通配符，即不要使用类似import java.util.*这样的语句\n按照以下顺序与间距将其分为几组，每组之间一个空行，同组import不换行，组内按字典序排序：\n 所有静态导入独立成组 com.google 包下的 第三方的包，每个顶级包为一组，如android,sun等 java import javax import  3.4 类声明 只有一个顶级类 每个文件中只有一个与文件名同名的顶级类\n类成员顺序 应当按照某种逻辑进行排序而不是添加时间\n重载 一个类有多个构造函数或同名方法时们这些函数/方法应当按顺序放在一起\n4 格式 4.1 使用大括号 大括号与 if,else,for,do,while 语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。\n非空块（K\u0026amp;R） 对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):\n 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。  举例：\nreturn () -\u0026gt; { while (condition()) { method(); } }; return new MyClass() { @Override public void method() { if (condition()) { try { something(); } catch (ProblemException e) { recover(); } } else if (otherCondition()) { somethingElse(); } else { lastThing(); } } }; 但也有一些例外，如4.8中的enum类\n空块 一个空的块状结构里什么也不包含，大括号可以简洁地写成 {}，不需要换行。\n但是如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。\n4.2 块缩进 每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。\n4.3 一行一个语句 每个语句后换行\n4.4 列限制 每一列只能由80或100个字符，超过则自动换行\n以下为例外情况：\n  不可能满足列限制的行(例如，Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。\n  package和 import语句(见3.2节和3.3节)。\n  注释中那些可能被剪切并粘贴到shell中的命令行。\n  4.5 自动换行 换行断点 自动换行的基本准则是：更倾向于在更高的语法级别处断开。\n  如果在 非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。\n注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的\u0026amp;（ \u0026lt;TextendsFoo\u0026amp;Bar\u0026gt;)，catch块中的管道符号( catch(FooException|BarExceptione)\n  如果在 赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于 foreach语句中的分号。\n  方法名或构造函数名与左括号留在同一行。\n  逗号(,)与其前面的内容留在同一行。\n  一般而言不会再lambda语句的箭头后断开，除非是箭头后面的是一个没有大括号的表达式\n  缩进后至少+4个空格 自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。\n当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。\n4.6 空白 垂直空白 以下几种情况需要一个空行：\n  类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。\n例外：\n 两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。 在enum类的常量间    要满足本文档中其他节的空行要求(比如section 3 中的文件结构 与 3.3节中的import语句)\n  类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。\n水平空白 除了语言需要与规则，单个空白同样出现在以下地方：\n  分隔任何保留字与紧随其后的左括号( ( )(如 if,for,catch等)。\n  分隔任何保留字与其前面的右大括号( })(如 else, catch)。\n  在任何左大括号前( {)，两个例外：\n @SomeAnnotation({a,b})(不使用空格)。 String[][]x={{\u0026quot;foo\u0026quot;}};(大括号间没有空格)。    任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：\n 类型界限中的 \u0026lt;T extends Foo \u0026amp; Bar\u0026gt;。 catch块中的管道符号catch (FooException | BarException e。 foreach语句中的分号。 lambda语句的箭头后面  但是也有例外：\n 两个冒号后的方法的引用，如Object::toString .之后的，如object.toString()    在 ,:;及右括号( ))后\n  如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。\n  类型和变量之间：List\u0026lt;string\u0026gt;list。\n  数组初始化中，大括号内的空格是可选的，即 new int[] {5, 6}和 new int[] { 5, 6 }都是可以的。\n  水平对齐：不做要求  Tip: Alignment can aid readability, but it creates problems for future maintenance.\n 4.7 Grouping parentheses 除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。\n4.8 几种具体的结构 枚举类 枚举常量间用逗号隔开，换行可选,多余的空行也是允许的（通常一行）\n没有方法和文档的枚举类可写成数组初始化的格式：\nprivate enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } 变量声明 每一个变量声明只声明一个变量，如int a,b 是不可行的 （for循环的初始化条件除外）\n需要时才声明变量，并尽快的初始化，不要在一个代码块的开头将所有局部变量一次性声明\n数组 数组的初始化可以写成块状结构，如写成以下形式都是可行的：\nnew int[] { 0, 1, 2, 3 } new int[] { 0, 1, 2, 3 } new int[] { 0, 1, 2, 3 } new int[] {0, 1, 2, 3} {% note warning %}\n没有使用C语言类型的声明 中括号是类型的一部分，而不是变量，应当使用String[] args, 而不是String args[]\n{% endnote %}\nSwitch语句 与其它块状结构一致，switch 块中的内容缩进为 2 个空格。每个 switch 标签后新起一行，再缩进2个空格，写下一条或多条语句。\n在一个 switch 块内，每个语句组要么通过 break,continue,return 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用 // fall through)。这个特殊的注释并不需要在最后一个语句组(一般是 default)中出现。\n示例：\nswitch (input) { case 1: case 2: prepareOneOrTwo(); // fall through  case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input); } 每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。\n注解（annotations） 注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。\n例外：单个的注解可以和签名的第一行出现在同一行。例如：\n@Override public int hashCode() { ... } 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：\n@Partial @Mock DataLoader loader; 注释 块注释与其周围的代码在同一缩进级别。它们可以是 /* ... */风格，也可以是 // ...风格。\n对于多行的 /* ... */注释，后续行必须从 *开始， 并且与前一行的 *对齐。\n修饰符 若类和成员的 modifiers 如果存在，则按 Java 语言规范中推荐的顺序出现。顺序如下：\n public protected private abstract static\tfinal transient\tvolatile\tsynchronized native strictfp\n 5 命名 5.1 通用规则 标识符使用ASCII字母与数字，使得每个有效的标识符都可以使用\\w+来正则匹配\n在其他规范中使用的特殊前缀或后缀，如 name_, mName, s_name 和 kName，在 Java 编程风格中都不再使用。\n5.2 标识符类型 包名 全部小写，连续的单词简单的连接起来而不使用下划线\n类名 使用UpperCamelCase的格式（关于UpperCamelCase在5.3介绍）\n测试类的命名使用其要测试的类的名字+Test，例如HashTest\n方法名 使用lowerCamelCase风格\n方法名通常使用动词或者动词短语\n下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test\u0026lt;MethodUnderTest\u0026gt;_\u0026lt;state\u0026gt;，例如 testPop_emptyStack。但是并不存在唯一正确的方式来命名测试方法。\n常量名 全部字母大写，用下划线分隔单词\n每个常量都是一个静态的final字段，但是不是所有的静态final字段都是常量\n名字一般为名词或者名词短语\n非常量字段 使用lowerCamelCase风格\n参数名 使用lowerCamelCase风格\n避免使用单个字符命名\n局部变量 使用lowerCamelCase风格，除了临时变量和循环变量之外要避免用单字符进行命名\n即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。\n类型变量 两种方式皆可：\n 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。  5.3 CamelCase 移除所有的单引号\n将所有字母都小写(包括缩写)，然后将单词的第一个字母大写\n UpperCamelCase：每个单词的第一个字母都大写，来得到大驼峰式命名 lowerCamelCase：除了第一个单词，每个单词的第一个字母都大写   Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名 checkNonempty和 checkNonEmpty也都是正确的。\n 6 代码实践 6.1 尽量使用@override 只要是合法的，就把 @Override 注解给用上。\n6.2 不能忽略捕获的异常 对捕获的异常不做响应很少是正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError重新抛出。)\n如果它确实是不需要在catch块中做任何响应，需要做注释加以说明。\n但是，在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。\n6.3 静态成员的调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。\n举例：\nFoo aFoo = ...; Foo.aStaticMethod(); // good aFoo.aStaticMethod(); // bad somethingThatYieldsAFoo().aStaticMethod(); // very bad 6.4 禁用finalizers 一般极少override Object.finalize\n Tip: Don't do it. If you absolutely must, first read and understand \u0026lt;em\u0026gt;Effective Java\u0026lt;/em\u0026gt; Item 7,\u0026quot;Avoid Finalizers,\u0026quot; very carefully, and then don't do it.\n 7 JavaDoc 7.1 格式 Javadoc 块的基本格式如下所示：\n/** * Multiple lines of Javadoc text are written here, * wrapped normally... */ public int method(String p1) { ... } 或者是以下单行形式：\n/** An especially short bit of Javadoc. */ 基本格式总是 OK 的。\n当整个 Javadoc 块能容纳于一行时(且没有 Javadoc 标记，比如@return)，可以使用单行形式。\n空行(即，只包含最左侧星号的行)会出现在段落之间和 Javadoc 标记(@XXX)之前(如果有的话)。除了第一个段落，每个段落第一个单词前都有标签 \u0026lt;p\u0026gt;，并且它和第一个单词间没有空格。\n标准的 Javadoc 标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。当描述无法在一行中容纳，连续行需要至少再缩进4个空格。\n7.2 摘要片段 每个类或成员的 Javadoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下它是唯一出现的文本，比如在类和方法索引中。\n这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 A{@codeFoo}isa...或 This method returns...开头, 它也不会是一个完整的祈使句，如 Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。\n一个常见的错误是把简单的Javadoc写成 /\\*\\* @return the customer ID \\*/，这是不正确的。它应该写成 /\\*\\* Returns the customer ID. \\*/。 7.3 需要书写Javadoc的地方 至少在每个public类及它的每个 public 和 protected 成员处使用 Javadoc\n以下为例外情况：\n  不言自明的方法，对于简单明显的方法单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。\n 如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由    override，如果一个方法重写了超类中的方法，那么 Javadoc 并非必需的。\n  对于包外不可见的类和方法，如有需要，也是要使用 Javadoc 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 Javadoc，这样更统一更友好。\n","permalink":"http://tristonk.com/notes/google%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/style-javaguide/","tags":null,"title":"Java代码规范"},{"categories":null,"contents":"{% note info no-icon %} 社会学的学习是激情之旅，让我们一起努力，接触那些饱受争议的概念与理论，试图打开那些紧闭着的大门，去发现我们非常熟悉的日常世界之幽暗玄冥的一面\t----Peter Berger {% endnote %}\n课程基本目标：\n略（略略略）\n 明白定义背后的争议 世界有很多种表达方式 社会学特点： 超越自身内部的分歧\n {% note primary %}\n本讲阅读文献 C.Wright Mills “The promise of Sociology”\nPeter Berger. Invitation to Sociology\n{% endnote %}\n课程阅读文献： 《社会学教程》，主编王思斌\n接触不同的表述： 吉登斯社会学 邱泽奇《社会学是什么》\n米尔斯《社会学的想象力》 费孝通《乡土中国》 涂尔干《自杀论》（“自杀，往往与时代的病症相关联，并不仅是个人问题”） 马克斯·韦伯《新教伦理与资本主义精神》 彼得·伯格 《与社会学同游：人文主义的视角》（有较强的个人风格）\n从社会学发展的历史看社会学的视角 诞生于社会需求之中\n社会学之父 - 孔德（August Comte） 1838年 其对于 社会学的定义： 对于社会现象所固有的全基本规律的实证研究 一开始想用social physics（社会物理学）来指代\n观察一个社会事件：-偶然性 -事件背后的可理解性\n1838年经历过的背景：\n 启蒙运动，理性的年代，将科学用于社会的研究 双元革命（法国大革命与工业革命）社会学产生从社会意义讲是双元革命之子 法国大革命：追求平等与博爱，用理性改变不合理的旧制度，混乱 工业革命：冲破了惯例与习俗，物质丰富背后的肮脏，素来遵从的观念烟消云散  孔德：用理性找出社会内在规律，恢复社会的美德，解救社会的困境，“人性的宗教”\n社会学的创立有着很强烈的乌托邦色彩，传统的社区邻里关系 “奥古斯特·孔德想象了一个由社会学家领导的家庭式秩序”--麦克布罗维《公共社会学》\n涂尔干设想了一种建立在具有劳动分工的法团主义组织基础上的有机团结-一种行会社会主义的形式\n孔德之后的三位奠基人：卡尔·马克思，埃米尔·涂尔干，马克思·韦伯\n马克思研究社会学角度：阶级分工\n涂尔干：使得社会学学院化，研究社会学的观点：社会是一个整体，社会事实外在于个体（可以参考其《自杀论》）\n韦伯：现代社会学与公共社会学，重要的资本主义研究：资本主义的出现与兴起，从“精神氛围”研究资本主义的兴起，提出科层制，科层化-理性化的来安排生产生活，工具理性与价值理性，社会分层\n 工具理性：通过实践的途径确认工具或手段的有用性，从而追求事物的最大功效，为人的某种功利的实现服务\n价值理性：通过有意识地对一个特定的行为—伦理的、美学的、宗教的或作任何其他阐释的——无条件的固有价值的纯粹信仰，不管是否取得成就\n “世界无可避免的进入了铁笼之中”\n马克思认为经济基础决定上层建筑，而韦伯将宗教文化放在了一个独立的地位，进行比较宗教研究\n社会学的三大理论视角：\n 冲突理论 --马克思 结构功能主义 --涂尔干 符号互动论 --韦伯（符号互动论成形于米德，但其很大部分的受到了韦伯的影响）  韦伯强调微观的社会行动者，而不是整体去讨论整体的宗教，文化\n","permalink":"http://tristonk.com/notes/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E6%A6%82%E8%AE%BA/shxgl1/","tags":null,"title":"社会学概论-社会学的视角"},{"categories":null,"contents":" 二极管：功能，结构类型，符号， 重点：PN结的结构形成与他的工作原理，伏安特性 二极管的简化模型，如何运用模型分析 齐纳二极管的工作原理\n 二极管 在PN结上加上引线和封装，就成为一个二极管\n二极管的功能  PN结单向导电性：整流、检波、开关 PN结压降：温度传感器、参考电压 非线性电流-电压特性：调节电压、限制电压、无线电调谐、产生射频振荡、发光  二极管的分类  结构：  点接触型：结面积小、结电容小、用于检波和变频 面接触型：结面积大，用于工频大电流整流电路 平面型：往往用于集成电路制造工艺中，面积可大可小    二极管的伏安特性  二极管的伏安特性曲线和PN结的伏安特性曲线接近，但是有所变化  体电阻的存在，电流比PN结较小一点 反向电流大一点 但是在NJU的PPT上给出的伏安特性曲线    死区：指的从正向电压0到正向电流开始快速变化的区域\n  硅Si的死区电压：$V_{th} = 0.5-0.8V$\n  锗Ge二极管的死区电压：$V_th = 0.1-0.3V$\n  温度升高，伏安特性曲线正向左移，反向下移(粒子运动加剧，本征激发加强)\n  室温下，上升一度，正向压降2-2.5mv，上升十度，反向电流增大一倍\n  二极管的主要参数  最大整流电流$I_F$: 二极管连续工作时，允许流过的最大整流电流的平均值 **反向击穿电压$V_{BR}$和最大反向工作电压$V_{RM}$**: 二极管反向电流急剧增加对应的反向电压值为反向击穿电压，为安全，最大反向工作电压为反向击穿电压的一半 反向电流$I_R$: 室温下最大反向工作电压的反向电流值。硅二极管一般时纳安级，锗二极管时微安级 极间电容$C_d=C_B+C_D$ **反向恢复时间$T_{RR}$**:从正向偏置的导通状态转为反向偏置状态，需要一定的时间才能变成截止状态。 主要原因时扩散电容的影响 正向压降$V_F$：规定正向点留下，二极管的正向电压降  Si:0.6-0.8V Ge:0.2-0.3V    二极管基本电路与分析 图解分析 使用欧姆原理得到的直线与二极管V-I特性曲线的交点\n数学上将方程与指数模型联立，使用迭代法求解\n简化模型 理想模型  近似条件：电源电压远大于电压降 正向偏置：管压降为0V 反向偏置：电阻无限大 理想二极管和实际的二极管的符号差别在于没有中间那条线 （但是ppt上原本也没有，用涂色表示  恒压降模型  管的恒压降恒定：  硅管0.7V，锗管0.3V   近似条件：$i_D$近似等于或者大于1mA 相当于理想模型和一个电压串联  折线模型 $v_D=0.5V$（硅管）\n相当于理想二极管、电源、电阻串联\n小信号模型 二极管在正向特性的某一小范围内时，正向特性可以等效为一个微变电阻\n$r_d = \\frac{V_T}{I_D}$，常温下$V_T=26mV$\n模型分析法的应用 整流电路 利用二极管的单向导电性\n静态工作状态分析 限幅电路 开关电路 判断二极管处于导通还是截止状态，然后观察阳、阴两极之间时正向电压还是反向电压，前者则二极管导通，否则二极管截止\n低电压稳压电路 利用二极管的正向压降特性获得较好的稳压性能\n 硅管：0.7V 锗管：0.3V  小信号工作情况 齐纳二极管(稳压管) 图中的$V_Z$表示反向击穿电压，即稳压管的稳定电压\n作用在于：$\\Delta I_Z$ 很大，但是只引起很小的电压变化$\\Delta V_z$, 动态电阻越小，稳压管的稳压性能越好\n$\\alpha$: 温度每变化一度，$U_z$的变化\n$$V_Z=V_{Z0}+r_ZI_Z$$\n限定工作电流$I_Z(min)\u0026lt;I_Z\u0026lt;I\u0026lt;Z(max)$\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E4%BA%8C%E6%9E%81%E7%AE%A1/","tags":null,"title":"二极管"},{"categories":null,"contents":"Generating functions 生成函数的作用：在计数问题中，利用性质构造生成函数，利用生成函数求解系数，系数对应了选择的种数\norinary generating function(OGF): $G(x)=\\sum_{n\\geq 0 }a_nx^n$\nusing \u0026quot;+\u0026quot; to represent \u0026quot;OR\u0026quot;, using the multiplication to denote \u0026quot;AND\u0026quot;\n例如如果有3个红球，4个蓝球，相同颜色球不可区分，那么我们的选择为$(1+x+x^2+x^3)(1+x+x^2+x^3+x^4)$，如果是需要选择k个球，则不同的选择方式种数就是 $x^k$ 的系数\nsloving recurrences 求解生成函数的四步方法：\n 写出 $a_n$ 的递归定义（如 $a_n = a_{n-1} + a_{n-2}$ 两边同时乘以$x^n$, ，左边即为生成函数G(x)，并将右边化为G(x)的形式 求解G(x)，得到关于x的函数 对G(x)进行级数展开，得到$a_n$  algebric operations on generating functions Let $G(x)=\\sum_{n\\geq 0}g_nx^n$, $F(x)=\\sum_{n\\geq 0}f_nx^n$\nshift : $x^kG(x)=\\sum_{n\\geq k}g_{n-k}x^n$\naddition : $F(x)+G(x)=\\sum_{n\\geq 0}(f_n+g_n)x^n$\nconvolution : $F(x)G(x)=\\sum_{n\\geq 0}\\sum_{k=0}^nf_kg_{n-k}x^n$\ndifferentiation : $G'(x) = \\sum_{n\\geq 0}(n+1)g_{n+1}x^n$\nexpanding generating functions 泰勒级数：$G(x)=\\sum_{n\\geq 0}\\frac{G^{(n)}(0)}{n!}x^n$\n几何级数：$\\frac{1}{1-x}=\\sum_{n\\geq 0}x^n$，所以对于$\\frac{a_1}{1-b_1x}+\\frac{a_2}{1-b_2x}+..$对应的$x^k$的系数就是$a_1(b_1)^k+a_2(b_2)^k+..$\nNewton's formular：若$|x|\u0026lt;1$,则$(1+x)^{\\alpha}=\\sum_{n\\geq 0}\\binom{\\alpha}{n}x^n$\nCatalan Number $C_n$等价情况\n 括号匹配 有(n+1)个叶子的完全二叉树 不越过对角线的大小为n的正方形格子的两个对点之间的路径数 n个+1，n个-1数的排列顺序使得前缀和永远为非负数  可以考虑完全二叉树的情况，假设对于根节点，左边有$k+1$个叶子,右边有$n+1-(k+1)$个叶子，那么也就对应着$$C_n=\\sum_{k=0}^{n-1}C_kC_{n-1-k}$$\n可以利用生成函数解得： $$C_n=\\frac{1}{n+1}\\binom{2n}{n}$$\nQuicksort 略\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/generating-functions/","tags":null,"title":"Generating Functions"},{"categories":null,"contents":"应用层 不考\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ying-yong-ceng/","tags":null,"title":"应用层"},{"categories":null,"contents":"数据模型  第二章 数据模型\n2.1 数据模型的基本概念\n 数据模型及其组成成分：数据结构，数据操作，数据约束 数据模型的核心，不同类型数据模型的区分依据 三个抽象层次上的数据模型概念：概念数据模型，逻辑数据模型，物理数据模型  2.2 数据模型的四个世界\n 现实世界，概念世界，信息世界，计算机世界  2.3 概念世界与概念模型\n E-R模型与E-R图（包括扩充E-R模型） 实体，属性，联系 多值属性（multi-valued attribute） \u0026amp; 组合属性（composite attribute） 联系上的函数对应关系 \u0026amp; 参与方式（Cardinality of Entity Participation in a Relationship） IS-A联系，弱实体 面向对象模型：对象，对象标识符，类，方法，超类和子类，聚合和分解，继承和合成  2.4 信息世界和逻辑模型\n 关系模型：关系，属性，值域（域），元组，关系数据库，关键字  2.5 计算机世界与物理模型\n 逻辑模型的物理存储：项，记录，文件，索引，集簇 提高文件访问效率的常用方法：索引，集簇，HASH   数据模型的基本概念 数据模型： 描述数据的结构，定义在该数据结构上可执行的操作以及数据之间必须满足的约束条件\n组成：数据结构、数据操作、数据约束\n数据结构 描述数据的类型、内容、性质以及数据间的联系\n是一个数据模型的基础，也被称为数据模式，数据模式是划分不同数据模型的依据，是数据模型的核心\n数据操作 不同数据结构上不同的操作方式与操作类型\n数据约束 描述数据结构之间数据的相互联系，包括语法/语义关系，数据间的制约与依存关系、动态变化规则\n不同层次的数据模型 概念数据模型：按照用户的观点实现世界中的数据和信息进行建模，刻画内在结构与关系，但是不涉及具体的描述细节与实现，如实体-联系(E-R)模型、面向对象模型\n逻辑数据模型（对应了外模式与概念模式）：DBMS实现，按数据库系统观点对数据建模，现在一半分为结构化与非结构化，常见的有关系模型、对象关系模型\n物理数据模型（对应了内模式）：DBMS实现，按照计算机系统观点对数据进行建模\n数据模型的四个世界 使用数据模型概念可以将现实中的反映到计算机中数据库的实现，是一个逐步反映的过程，包括现实世界、概念世界、信息世界、计算机世界\n现实世界：根据用户需求（数据需求与处理要求）而划定边界的一个应用环境\n概念世界：E-R模型，OO模型，这些与具体的DBMS和计算机无关\n信息世界：以概念世界为基础，选定特定的DBMS构造而成的逻辑数据模型\n计算机世界：在计算机中物理实现，侧重于数据库物理存储结构的描述，包括存储结构的设计、存取路径的设计(文件结构：堆/直接/索引)、存储空间的分配\n概念世界与概念模型 是一个较为抽象、概念化的世界\nE-R模型（实体-联系模型） 核心概念：实体、属性、联系\nER图：实体：矩形； 属性：椭圆形； 联系：菱形；连接实体集与属性，联系与属性，实体集与联系\n实体：客观存在且能相互区别的事物，概念世界中的基本单位，每个实体都有一个实体名用于区分\n属性：实体所具有的某种特性或者特征，属性可以有值，一个属性可以取的值的集合称作该属性的域，每个属性有一个属性名，所有属性的属性名构成了这个实体的实体型，具有共性的实体指的是有相同的实体型\n联系：一个实体集中的实体与另一个实体集中的实体存在的对应关系，包括二元联系，多元联系，单个实体集内部的联系\n函数对应关系：\n 1:1 1:m m:n  联系也可以具有属性\n属性的描述：属性名\n实体的描述：实体+实体型\n实体集（具有相同实体型的实体的集合）的描述：实体名+实体型+关键字\n扩充E-R模型 IS-A联系：若实体集B是实体集A的一个子集，且具有比实体集A更多的属性，称两者存在IS-A联系，其中实体集A称为超实体集，实体集B称为子实体集，实体集B可以继承A中所有属性\n在EE-R图中，用子实体集指向超实体集的单项箭头表示该联系\nIS-A具有继承性与传递性\n要求子实体集的并集等于超实体集(覆盖约束)与任意两个子实体集不相交（不相交约束）\n弱实体：实体A的存在需要依赖其他某个实体（如职工vs家属），在EE-R图中表示为从弱实体到联系的有向箭头\n属性的划分：标识符(关键字)、描述符、组合属性（多个简单的属性用来描述一个属性，如fname,lname用来描述name这个属性）、多值属性（多值的，如hobbies，双线段表示）\n属性基数：二元组(x,y)描述属性上的取值数量特征\n (0,?) 可以取空值 (1,?) 不允许取空值 (?,1) 每一个实体在该属性上最多只有一个值，即单值属性 (?,N) 每个实体在该属性上可以取多值，即多值属性  参与基数：（实体,联系）\n 最大参与基数：max-card(E,R)，为1表示最多与F中实体一个有联系(单值参与)，为N是可能多个实体有联系(多值参与) min-card(E,R)：为0可能与另一个实体集中的无联系(可选参与)，为1至少与一个有联系(强制参与) 参与基数：Card(E,R)=(min-card(),max-card())  面向对象模型 对象：能相互区分的事物,由对象标识符、静态特性（对象中的属性）、动态特性（可以施加在对象上的方法/操作）组成\n对象标识符：每个对象均具有的一个能相互区别的名字\n类：具有相同属性、方法的对象集合\n方法\n超类和子类（IS-A关系）\n聚合和分解（IS-PART-OF关系）\n继承和合成：单继承/多继承（子类有1/多个超类）\n谓词模型 P(x,y,z):为true当且仅当存在一个元组(x,y,z)满足谓词P\n信息世界和逻辑模型 E-R模型可以对应的逻辑模型：层次模型、网状模型、关系模型\nEE-R模型可以对应的逻辑模型：对象关系模型\n面向对象模型对应的逻辑模型：面向对象模型\n关系模型 基本数据结构：二维表\n数据操纵：对一张表/多张表间的查询，对一张表的删除、插入与修改\n关系模式：关系的关系名及其属性名的集合\n关系数据库模式：关系数据库中所有关系的关系模式的集合\n元组：关系中的每一行\n关键字：属性集中唯一标识关系中的一个元组\n主关键字：候选关键字中选一个\n外关键字：关系R中的属性集F取值来自于关系S中的主关键字K，称属性集F是关系R的外关键字\n计算机世界与物理模型 项：文件系统中最小基本单位，项内符号不能继续分割\n记录：若干项组成，记录内的各项间有内在语义联系\n文件：记录的集合\n提高读写操作效率 索引：文件的记录与物理地址间建立一张对应关系表(可以有多级索引)\n集簇：查找记录时按照某项的项值查找，将具有相同或者相邻的项值的记录聚集在相同磁盘块内\nHASH：通过hash间查找的记录转换成物理地址\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/data-model/","tags":null,"title":"数据模型"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 2\n 这个读书笔记建立在已经看完了西瓜书第16章的基础上，略过了很多东西\n 部分该章节西瓜书笔记可点击, 因为太懒了，后面一部分的笔记还没抄\n nonsassociative problem: one that does not involve learning to act in more than one situation associative problem: when actions are taken in more than one situation\n本章主要围绕Multi-armed Bandits（多臂老虎机问题）展开讨论，以此为例介绍几种算法\n2.1 A k-armed Bandit Problem Problem definition You are faced repeatedly with a choice among k different options, or actions. After each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. Your objective is to maximize the expected total reward over some time period\n记号 第t步的动作：$A_t$, 对应奖赏$R_t$ 对于一个动作，预期奖赏为$q_*(a) = E[R_t | A_t = a]$ 第t步选择动作a的估计奖赏为$Q_t(a)$\n选择最优：exploiting 选择非最优：exploring\n然后就是探索与利用的关系，看西瓜书就行\n2.2 Action-value Methods 计算Q：取平均值\n有多种方式求解：\n greedy（全利用） $\\epsilon - greedy$  2.3 The 10-armed Testbed 比较了一下$\\epsilon - greedy$与$greedy$的差异，优缺点以及优化看西瓜书即可\n2.4 Incremental Implementation 如何快速更新Q估计值： $Q_{n+1} = Q_n + 1/n(R_n-Q_n)$\n上为以下公式的一种形式\n$$NewEstimate\\leftarrow OldEstimate + StepSize [Target − OldEstimate]$$\n$[Target − OldEstimate] $被称为是估计中的$error$ 将$StepSize$表示为$\\alpha$, 更一般的，表示为$\\alpha_t(a)$\n2.5 Tracking a Nonstationary Problem stationary: the reward probabilities do not change over time\n对于Nonstationary的问题，我们要给更多的权重给最近得到的rewards。 一种常见的方式是给$\\alpha$设置一个常数值（展开可知$Q_{n+1} = (1-\\alpha)^nQ_1+\\sum_{i=1}^n\\alpha(1-\\alpha)^{n-i}R_i$），我们称其为weighted average，因为其权重和为1.有时候也称其为exponential recency-weighted average.\n有时候让$\\alpha$随时间变化而变化，用$\\alpha_n(a)$第n次选择动作a时的stepsize。 要保证在数量足够大的情况下能够让估计值趋向于真实值，根据随机近似理论(stochastic approximation),要满足以下条件：\n$$\\sum_{n=1}^\\infin a_n(a) = \\infin ,,\\sum_{n=1}^\\infin a_n^2(a) \u0026lt; \\infin $$\nThe first condition is required to guarantee that the steps are large enough to eventually overcome any initial conditions or random fluctuations. The second condition guarantees that eventually the steps become small enough to assure convergence.\n可以看出我们之前让$\\alpha$为一个常数时是满足第一个条件而不满足第二个条件的，这导致其会一直变化，这也正是我们希望在Nonstationary的情况下做到的\n值得说明的是，满足两个条件的参数一般都收敛的比较慢，需要仔细的调参。故而虽然在理论分析时考虑这个，但是实际应用时很少考虑这个\n2.6 Optimistic Initial Values 之前提到的所有的方式都某种程度上依赖于初始值的估计$Q_1(a)$, 可以说这些方式都有初始值的偏差（biased by their initial estimates.）对于sample-average methods而言，只需要每个动作试一遍就可以消除这种误差了，但是对于step size为常数的方式而言，这种误差是一直存在的（虽然会不断缩小，理由可见表达式）。\n初始值有时也可以被用于促进exploration，如将其初始值设定的比估计值都大，那么就可以使得会优先把所有的动作都尝试一遍，我们称呼这种为Optimistic Initial Values\n但这种方式不适用于nonstationary的情况，因为任务一旦变化，所有的初始值都不可能始终适用\n2.7 Upper-Confidence-Bound Action Selection 探索是必要的， 但是$\\epsilon - greedy$并没有给出一个偏向性，使得尽可能去探索接近greedy的或者是探索次数还不够多导致并不确定的动作。所以有了upper confidence bound (UCB) action selection\n$$A_t = arg,max[Q_t(a)+c\\sqrt{\\frac{\\ln t }{N_t(a)}}]$$\n其中$N_t(a)$表示动作a在第t次前被执行的次数，the number c \u0026gt; 0 controls the degree of exploration，c可以看作是对于估计的信任程度\n UCB often performs well, as shown here, but is more difficult than \u0026quot;-greedy to extend beyond bandits to the more general reinforcement learning settings considered in the rest of this book. One difficulty is in dealing with nonstationary problems; methods more complex than those presented in Section 2.5 would be needed. Another difficulty is dealing with large state spaces, particularly when using function approximation as developed in Part II of this book. In these more advanced settings the idea of UCB action selection is usually not practical.\n 2.8 Gradient Bandit Algorithms 构建一个数值类型的函数$H_t(a)$使得对于每一个动作a有一定的偏向性\nsoft-max distribution:\n$$Pr{A_t = a} = \\frac{e^{H_t(a)}}{\\sum_{b=1}^k e^{H_t(b)}} = \\pi_t(a)$$\n对于第t步选择了$A_t$之后，更新各个概率为\n$H_{t+1}(A_t) = H_t(A_t) + \\alpha (R_t - \\overline{R_t})(1-\\pi_t(A_t))$ and\n$H_{t+1}(a) = H_t(a) - \\alpha (R_t - \\overline{R_t})\\pi_t(a)$\n其中$ \\overline{R_t}$ 表示除去第t步之外的所有奖赏的平均值，其相当于一个baseline，如果奖赏高于这个baseline，那么对应动作$A_t$的在未来被选择的概率将增加，否则将减少\n2.9 Associative Search (Contextual Bandits)  However, in a general reinforcement learning task there is more than one situation, and the goal is to learn a policy: a mapping from situations to the actions that are best in those situations.\n  associative search task, so called because it involves both trial-and-error learning to search for the best actions, and association of these actions with the situations in which they are best. Associative search tasks are often now called contextual bandits in the literature.\n  Associative search tasks are intermediate between the k-armed bandit problem and the full reinforcement learning problem.If actions are allowed to affect the next situation as well as the reward, then we have the full reinforcement learning problem.\n ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl2/","tags":null,"title":"Multi-armed Bandits"},{"categories":null,"contents":"{% note primary %}\n阅读文献 金耀基：“中国人对私隐权的-中国人文鼎细等线的公私观念”\n林语堂：《中国人》第四章 “人生的理想”\nHorace Miner. Body Ritual among the Nacirema\n{% endnote %}\n汉语中的社会 社：土地之主也。“左祖右庙”。后社由最初的土地之主发展为一种乡村基层组织：里社、乡社。后又发展成志趣相同的人的一个团体，如茶社\n会：集会\n 汉语中一开始社与会是分开的，不怎么连用(就算连用也是表示一个小团体，和社字意思类似)，后日本在翻译society的时候使用了社会一词，之后引入时中国也开始使用社会这个词语\n 社会学中的社会 马克思定义的社会：社会是人们交互作用的产物，生产关系的总合起来就构成了社会关系\n马克思定义的社会是一个实体概念，但不是一个具体的实体概念，是那种通过观察、体会其效用才能证明存在的实体\n社会的“发现”\n村庄社会，民族国家，世界社会、全球社会\n在几百多年前，我国其实并没有民族主义形成，经过战争后才逐渐形成\n社会模型  系统模型，最典型的是结构功能主义，代表人物：帕雷托、斯宾塞、涂尔干、帕森斯 。社会形象：有秩序的整体，共识，一套功能机构 冲突模型，人与人之间相互冲突，争夺资源，最典型的是马克思，意识形态(在系统模型中称为共识，意识形态某种形式上也是一种共识)，“在每一个时代，统治阶级的思想就是这个时代的思想”，意识形态也被叫做“虚假意识”，原因如之前引用的话，只是部分人的共识。 互动模型，最典型的是符号互动论，社会是一种谈判，互动模型与系统模型和冲突模型都不同，他不从宏观角度理解社会，而是从微观角度去理解社会，从人的活动来理解，把社会看作是相互作用、沟通和谈判  文化 \u0026quot;有文化\u0026quot;，“没文化”的语境相关：教育\n社会学意义上的文化 社会学意义上的定义：一个社会或群体共同承认的价值观，遵从的规范，连同他们所创造的物质产品\n“没有文化的人类，事实上根本不存在” --克里福德·格尔兹\n人是“意义”型的动物, 人是“文化型”动物\n文化意义的演变：从泰勒到格尔兹 泰勒:\n 文化或文明是一个复杂的整体，它包括知识、信仰、艺术、法律、伦理道德、风俗和作为社会成员的人通过学习而获得的任何其他能力和习惯 ---E.B.Taylor\n 马林诺夫斯基：在泰勒的基础上增加了物质文化\n格尔兹抛弃了大而全的文化的定义，方便于研究\n 文化是人类用来解释他们的经验，指导他们行动的意义结构 ——格尔兹《文化的解释》\n“我与马克思·韦伯一样，认为人是悬挂在由他们自己编织的意义之网上的动物，我把文化看作这些网。”\n 当代社会学与人类学研究中，主要采用的是格尔兹改造过的文化的定义\n格尔兹将文化看作可以为大众获得的象征(符号)形态，人们通过这些象征形态来体验和表达意义。这一界定将文化的定义从泰勒无所不包的定义缩小，集中到了意义系统\n意义系统——共享的，分享的\n研究文化的其他方向 一些人探索文化的遗传密码，探索人类的大脑结构\n亚文化 当在社会的某一群体中，形成一种既包括一些主流文化特征，也包括某些独特的文化要素时，这一群体的文化，就叫做亚文化\n\u0026quot;亚文化举例\u0026quot;：DISCO，黑人文化\n亚文化应当包括主流文化特征的核心价值观，亚文化与主流文化是相对的，亚文化可能被主流文化所吸收\n反文化 从根本上与社会主流文化相对立的文化，它有意识的对抗社会上的某些最重要的价值和规范，并为此感到自豪\n举例：嬉皮士，披头士\n文化的构成 价值观：社会成员关于好坏、对错、符合或违背人们愿望等的共同看法。是文化中最为核心的部分\n规范：人们共同遵守的对特定环境中人的正当行为方式所作出规定的准则\n主要规范类型：社会习俗，道德，法律\n规范是具体的准则，价值观是抽象的一般观念，价值观是判断规范的尺度，规范是价值观的体现\n物质文化：社会已有的物质形式\n奥格本：文化堕距\n文化是一个整体，牵一发而动全身\n","permalink":"http://tristonk.com/notes/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E6%A6%82%E8%AE%BA/shxgl2/","tags":null,"title":"社会学概论-社会与文化"},{"categories":null,"contents":" 三极管的结构，工作原理，三种组态起码要认识（如何工作与分析不做太高要求），放大作用如何实现，伏安特性曲线（尤其输出，各种区与每种线的含义），各种基本参数\n 半导体三极管 三极管：双极结型三极管(BJT，又叫双极晶体管)\n发射结上的箭头的方向指向发射结导通的方向(P指向N)，由此可以区分NPN型和PNP型\n发射区：发射载流子，既然要发射，那载流子浓度必然很高 集电区：收集载流子，面积大但是载流子浓度不高 基区：控制区域\n结构特点：\n 发射区的掺杂浓度最高 集电区的掺杂浓度低于发射区，且面积大 基区很薄，一般在几个微米，且掺杂浓度最低  电流放大 放大实际上是通过核心元件三极管控制能量的新的变化来实现放大\n实现放大的外部条件：发射结正偏，集电结反偏\n载流子内部传播过程-以NPN型为例  发射结正偏，发射区的自由电子扩散到基区  $I_{EN}$：自由电子的扩散 $I_{EP}$:空穴的扩散,由于浓度原因，显然远不如$I_{EN}$ $I_{E} = I_{EP}+I_{EN} \\approx I_{EN}$   基区：自由电子此时进入基区后，基区中现在扩散过来的非平衡少子比他的多子还多，所以会继续往前扩散，所以自由电子会经过基区继续向集电极扩散，在扩散过程中，必然会发生复合。（如果基区足够宽，就可以让绝大多数电子在基区中复合，这也就是为什么基区要做的足够薄）。但是复合之后，又可以在基极$I_B$的影响下重新产生。所以可以认为其中的浓度不变。扩散速度和浓度梯度有关，所以必须让集电结这里的电子必须被快速抽走保证扩散速度基本不变（刚好此处就集电结反偏了）  在$I_B$做一个KCL，可以看到$I_B=I_{EP}+I_{BN}-I_{CBO}=I_E-I_C$   集电区收集自由电子，反偏会加速漂移运动，产生了$I_{CBO}$  $I_C=I_{CN}+I_{CBO}$    BJT电流分配关系 共基极直流放大系数 $\\hat{\\alpha}$ $$\\hat{\\alpha}=\\frac{传输到集电极电流}{发射极注入电流}=\\frac{I_C-I_{CBO}}{I_E}\\approx \\frac{I_C}{I_E}$$\n他通常只与管子的结构尺寸和掺杂浓度有关，与外加电压无关，一般为0.9-0.99\n共射极直流放大系数 $\\hat{\\beta}$ $$\\hat{\\beta} = \\frac{I_{CN}}{I_{BN}} = \\frac{I_C-I_{CBO}}{I_B+I_{CBO}}\\approx \\frac{I_C}{I_B}$$\n反向饱和电流（穿透电流）：当$I_B$为0时，仍然有一个从C到E的电流,$I_{CEO}=(1+\\hat{\\beta})I_{CBO}$\n三极管的放大作用主要是依靠它的发射极电流能够通过基区传输，然后到达集电极而实现的。\n 内部条件：发射区杂质浓度远大于基区浓度，并且基区很薄 外部条件：发射结正向偏置，集电结反向偏置  三种组态 看除去用于输入和输出之外共用的是哪个极\n可以发现输入要么在基极就是在发射极\nBJT的I-V特性曲线 现在考虑共射极连接的BJT曲线\n输入特性 $$i_B=f(v_{BE})|_{V_{CE}=const}$$\n当$V_{CE}=0$时，就相当于发射结的正向伏安特性曲线，当其大于1V时，$V_{CB}=V_{CE}-V_{BE}\u0026gt;0$,集电结反偏，收集载流子能力增强，基区复合减少，这使得同样的$V_{BE}$下的$I_B$减少，也就是曲线右移\n有三个区：\n 死区 非线性区 近似线性区  非线性区和近似线性区的分界：（工作压降）  硅：0.6-0.7V 锗：0.2-0.3V      输出特性 $$i_c=f(V_{CE})|_{i_B=const}$$\n 放大区  放大区域内输出曲线基本与横坐标平行，随着$v_{CE}$的增加略微向上倾斜(受基带宽度调制效应产生)。但是主要受到$i_B$的影响，此时发射结正偏，集电结反偏 基带宽度调制效应：在$V_{BE}$不变的情况下，$V_{CE}$的上升会导致$V_{CB}$反压上升，导致集电结内的空间电荷区的宽度上升，从而使得基带区的有效宽度下降，基区内的载流子复合机会下降，从而使得 $\\beta$ 增大   饱和区  发射结和集电结均处于正偏。此时$V_{CE}\u0026lt;V_{BE}$,集电结内电场被削弱，收集载流子能力下降，此时$i_c$不再服从$\\hat{\\beta}i_{B}$的关系，而是随着$V_{CE}$的增长而增长。虚线可以认为是饱和区和放大区的分界线。对于小功率管，可以认为$V_{CE}=V_{BE}$时处于临界饱和状态   截止区  发射结和集电结全部反向偏置，此时$i_B=-I_{CBO}$,$i_C=I_{CEO}$(但是对于小功率管很小，可以忽略)    BJT的主要参数 基本参数  电流放大系数  共发射极直流放大系数 $\\hat{\\beta}\\approx \\frac{I_C}{I_B}$（$V_{CE}$为常数） 共发射极交流电流放大系数 $\\beta = \\frac{\\Delta I_C}{\\Delta I_B}$ 共基极直流电流放大系数 $\\hat{\\alpha} = \\frac{I_C-I_{CBO}}{I_E} \\approx \\frac{I_C}{I_E}$ 共基极交流放大系数 $\\alpha = \\frac{I_C}{I_E}$   极间反向电流  集电极基极反向饱和电流$I_{CBO}$：即发射极开路时，集电极的反向饱和电流 集电极发射极间的反向饱和电流$I_{CEO} = (1+\\hat{\\beta})I_{CBO}$,即输出特性曲线$I_B=0$ 那里对应的Y坐标的值，也称作集电极发射极间穿透电流   极限参数  集电极允许最大电流$I_{CM}$ 集电极允许最大功率损耗$P_{CM}=I_CV_{CE}$ 反向击穿电压  $V_{(BR)CBO}$——发射极开路时的集电结反向击穿电压。 $V_{(BR)EBO}$——集电极开路时发射结的反向击穿电压。 $V_{(BR)CEO}$——基极开路时集电极和发射极间的击穿电压。      温度对BJT参数及其特性的影响 温度每升高10度，$I_{CBO}$约增加一倍\n温度每升高1度，$\\beta$值增大$0.5%-1%$\n温度对反向击穿电压中的$V_{(BR)CBO}$和$V_{(BR)CEO}$都有影响，温度升高，两者增大\n故而：\n 温度升高，输入特性曲线左移 温度升高，输出特性曲线上移，曲线族间距增大  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%B8%89%E6%9E%81%E7%AE%A1/","tags":null,"title":"半导体三极管"},{"categories":null,"contents":"Sieve methods Principle of Inclusion-Exclusion PIE用于计算n个有限集合的并的大小 : $$ {\\begin{aligned}\\left|\\bigcup {i=1}^{n}A{i}\\right|\u0026amp;=\\sum _{I\\subseteq {1,\\ldots ,n}}(-1)^{|I|-1}\\left|\\bigcap {i\\in I}A{i}\\right|.\\end{aligned}}$$\n我们在组合中，通常将我们不希望看到的坏事件定义为$A_i$,这样的话我们所希望得到的就是$$ {\\begin{aligned}\\left|{\\bar {A_{1}}}\\cap {\\bar {A_{2}}}\\cap \\cdots \\cap {\\bar {A_{n}}}\\right|=\\left|U-\\bigcup _{i=1}^{n}A_{i}\\right|\u0026amp;=|U|+\\sum _{I\\subseteq {1,\\ldots ,n}}(-1)^{|I|}\\left|\\bigcap _{i\\in I}A_{i}\\right|.\\end{aligned}}$$\n同时，我们可以用一个$ A_{I}=\\bigcap _{i\\in I}A_{i}$来表示，这样的话我们可以令 $ S_{k}=\\sum _{|I|=k}|A_{I}|,$. Conventionally, $ S_{0}=|A_{\\emptyset }|=|U|$,那么 $$\\left|{\\bar {A_{1}}}\\cap {\\bar {A_{2}}}\\cap \\cdots \\cap {\\bar {A_{n}}}\\right|=S_{0}-S_{1}+S_{2}+\\cdots +(-1)^{n}S_{n}.$$\nsurjections 考虑求解$[n]\\rightarrow [m]$ 的满射的数量。\n那么我们可以定义坏事件为$A[i]=[n]\\overset{on-to}{\\to}([m]-{i})$\n则$A_I$可以看成是$[n]$到$([m]/I)$的一个映射，这种映射有$(m-|I|)^n$种方式\n故而结果为 $$\\sum {I\\subseteq [m]}(-1)^{|I|}\\left|A{I}\\right|=\\sum _{I\\subseteq [m]}(-1)^{|I|}(m-|I|)^{n}=\\sum _{j=0}^{m}(-1)^{j}{m \\choose j}(m-j)^{n}$$\nderangements 错排：任意的一个$i\\in [n]$,有 $\\pi(i)\\neq i$\n那我们就定义坏事件就是$A_i={\\pi|\\pi(i)=i}$\n那么就有$|A_I|=(n-|I|)!$\ntips: 最后的求解过程中还应用了泰勒公式$e^x=1+\\frac{1}{1!}x+\\frac{1}{2!}x^2+\\frac{1}{3}x^3+\\cdots$\npermutations with restricted positions 在一个$n\\times n$ 的棋盘中，保证选择的n点中的每两个点不会再同一行或者同一列。\n即$G_\\pi = {(i,\\pi(i))|i\\in{1,2,..n}}$\n将排列转换为一组二维坐标,假设B是一个不符合条件的位置的集合, $r_k$ 表示在B中选k个不同的位置的方法. 则满足条件的n排列的个数为$N_0 = \\sum\\limits_{k=0}^n (-1)^k r_k (n-k)!$\nInversion posets the mobius function computing mobius functions principle of mobius inversion sieve method in Number theory ","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/sieve-methods/","tags":null,"title":"Sieve Methods"},{"categories":null,"contents":"运输层 该层位运行在不同主机上的应用经称提供直接的通信服务\n3.1 概述与运输层服务 运输层协议位不同主机上的应用进程提供了逻辑通信的功能\n网络路由器不实现运输层协议，网络路由器只检查网络层字段，不检查运输层报文段的字段，在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。\n3.1.1 运输层和网络层的关系  运输层：提供运行在不同主机上的进程之间的逻辑通信 网络层：提供主机之间的逻辑通信  运输层协议只运行在端系统中\n运输协议能够提供的服务常常会受制于底层网络层协议的服务模型\n3.1.2 因特网运输层概述 UDP(用户数据报协议)：为调用它的应用程序提供一种不可靠(不能保证一个进程发送的数据能完整到达)、无连接(无握手)的服务。提供数据交付与差错检测\nTCP(传输控制协议)：提供一种可靠的、面向连接的服务，通过流量控制、序号、确认和定时器确保按序交付\n虽然RFC中将UDP分组称为datagram数据报，但是本书中运输层分组统称报文段\nTCP有拥塞控制，防止一条TCP连接用过多的流量淹没通信主机之间的链路和交换设备，但是UDP传输的应用程序可以按照其需要以任意的速率发送数据\n3.2 多路复用与多路分解 多路复用与多路分解：将由网络层提供的主机到主机交付服务延申到为运行在主机上的应用程序提供进程到进程的交付服务。\n 多路分解：将运输层报文段的数据交付正确的套接字 多路复用：从源主机的不同套接字收集数据块，并为每个数据块封装上首部信息生成报文段，并将报文段传送给网络层  一个进程由一个或者多个套接字，运输层不是直接将数据交付给进程而是交给了一个中间的套接字。每个套接字都有一个唯一的标识符。\n每个报文段的首部信息的前32个比特都是源端口号字段和目的端口号字段，每个字段16比特，端口号从1-65535之间，其中0-1023范围内的端口号是周知端口号，是受限制保留给一些周知应用层协议来使用的\n 一个UDP套接字由一个二元组(目的IP地址,目的端口号)定义 TCP套接字由一个四元组(源IP地址,源端口号,目的IP地址,目的端口号)标识。 所以不同主机发送相同目的IP地址和目的端口号的报文，在UDP中会给同一个套接字，而TCP中不会  如果使用非持续HTTP服务，那么每一对请求/响应都创建一个新的TCP连接并关闭\n3.3 无连接运输：UDP UDP：做运输协议能做的最少的工作，只在IP上增加了复用/分解功能和差错检测功能\n使用UDP时，发送报文段之前，发送方和接收方的运输层没有握手，故而被称为是无连接的\nDNS是一个使用UDP的典型例子\n部分应用更适合使用UDP的原因：\n 关于发送什么数据以及何时发送的应用层控制更加精细：因为TCP有拥塞控制并且需要可靠有序交付，而一些实时应用通常要求最小发送速率且不希望过分延迟报文段的发送，并且能够容忍一些数据丢失 无需建立连接：UDP没有建立连接的时延(这是DNS采用UDP的主要原因) 无连接状态：TCP需要在端系统中维护连接状态(接收和发送缓存，拥塞控制参数及序号和确认好的参数)，采用UDP可以支持更多的活跃用户 分组首部开销小。TCP报文首部20字节，UDP8字节  还有一些如网络管理数据的(SNMP)这些在网络重压状态下运行，这时候可靠的拥塞受控的数据传输难以实现\n多媒体开发人员通常将应用运行在UDP上而不是TCP上\n3.3.1 UDP报文结构 首部只有四个字段(8字节)，每个字段16比特(2字节)。\n 源端口号 目的端口号 长度：UDP报文段的字节数(首部+数据) 检验和  3.3.2 UDP校验和 对报文段中所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷(最高位进位的数加到最低位去)。接收方收到后，把所有比特字和校验和相加，将会得到全1.\n提供差错检测的原因在于无法保证所有的链路都提供差错检测，同时存储在某台路由器的内存中的时候也可能引入比特差错，故而要在端到端基础上在运输层提供差错检测\n但是，UDP的差错检测没有恢复能力，只能对报文段进行丢弃或者交给应用程序并给出警告\n3.4 可靠数据传输原理 3.5 面向连接的传输：TCP 3.5.1 TCP连接 TCP是面向连接的，因为在一个应用进程可以开始向另一个应用进程发送数据前，两个进程必须先握手，即呼想发送某些预备报文段，以建立确保数据传输的参数。\n连接状态只在两个通信端系统的TCP程序中保留\nTCP连接提供全双工服务：应用数据可以从B流向A，也可以从A流向B\nTCP连接是点对点的，即多播是不可能的\n客户进程通过套接字传输数据流，数据通过套接字后，被TCP导入发送缓存中，发送缓存时发起三次握手期间设置的缓存之一。接下来TCP不时的从发送缓存中取出一块数据并将数据传入网络层。\n取出数据的长度受限于最大报文段长度(MSS),而MSS根据本地发送主机的最大链路层帧长度(即最大传输单元MTU)来设置。MSS要保证一个TCP报文段加上TCP/IP首部长度(通常40字节)适合单个链路层帧。注意MSS指的是报文段中应用层数据的长度\nTCP接收端收到报文段后放入接收缓存中，应用程序从缓存中读取数据流。\n3.5.2 TCP报文段结构 | 源端口号 | 目的端口号 | | 序号 | | 确认号 | |首部长度|保留未用|SWR|ECE|URG|ACK|PSH|RST|SYN|FIN| 接收窗口 | | 因特网校验和 | 紧急数据指针 | | 选项 | | 数据 |  序号(seq):32 bits 确认号(ACK)：32 bits 接收窗口字段：16 bits，用于流量控制 首部长度字段: 4 bits 选项字段：可选、变长 标志字段：6 bits  ACK：指示确认字段的值有效 RST,SYN,FIN: 连接建立与拆除 SWR,ECE: 明确拥塞通告 PSH：置位时标识接收方应当立即将数据交给上层 URG：指示报文段里存在着发送端上层实体置为紧急的数据，紧急数据的最后一个字节由紧急数据指针字段指出    序号与确认号 TCP把数据看成一个无结构、有序的字节流，序号是建立在传送的字节流之上，而不是报文段序列上，主机A填充到报文段的确认号是希望从主机B收到的下一字节的序号\nTCP：累计确认\n收到失序的报文段的处理方式取决于编程人员：\n 立刻丢弃失序报文段 保留失序字节，并等待确少的字节以填补间隔  一条TCP连接的双方均可随机的选择初始序号\n3.5.3 往返事件的估计与超时 采用超时/重传机制来处理报文段的丢失问题\nRTT：往返时间\n报文段的样本RTT就是从某报文段被发出到对该报文段的确认被收到之间的时间量。大多数的实现是某个时刻做一次测量而不是每个发送的报文段测量一个。TCP绝不为已经重传的报文段计算SampleRTT。\nSampleRTT的平均值(加权移动平均)EstimatedRTT：$$EstimatedRTT=(1-\\alpha)EstimatedRTT + \\alpha SampleRTT$$\n在RFC6298中给出的推荐值是$\\alpha = 0.125$\nRTT偏差：$$DevRTT=(1-\\beta)DevRTT+\\beta |SampleRTT-EstimateRTT|$$$\\beta$的推荐值是0.25\n设置重传时间间隔不能太小，否则会造成不必要重传，也不能太大，否则不能很快的重传报文段造成数据传输时延较大。一般设置为$$TimeoutInterval = EstimatedRTT+4*DevRTT$$只要超时了就将其加倍，但是再次收到报文段后就仍然按照上面的公式对其进行更新\n3.5.4 可靠数据传输 可靠数据传输保证一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。\n推荐的定时器管理过程是使用单一的重传定时器，即使有多个已发送但是仍未被确认的报文。\n/*假设发送方不受TCP流量控制和拥塞控制，每一个数据小于MSS.*/ NextSeqNum = InitialSeqNum SendBase = InitialSeqNum loop(永远){ switch(event): case 从上层应用接收数据： 生成序号为NextSeqNum的报文; if(定时器没有启动){ 启动定时器; } 向IP传递报文; NextSeqNum += 数据字节数; break; case 超时： 重传SendBase对应的TCP报文; /*和GBN不同之处*/ TimeoutInterval *= 2; 重启定时器; /*每次重传一个报文后都会重新启动定时器*/ break; case 接收ACK, AN = y: if(y \u0026gt; SendBase){ SendBase = y; /*采取累计确认*/ 重新计算TimeoutInterval; if(仍有发送且未确认报文){ 重启定时器; } } else{/*实际上此时y == SendBase*/ y的冗余数量 += 1; if(y的冗余数量 == 3){ /*快速重传*/ 立即重传序号为y对应的报文; } } break; } 对于接收端而言：\n   事件 动作     具有所期望序号的按序报文段到达且在此之前的报文段都已经被确认，即本报文段是当前状态下第一个接收但未被确认的报文 Delayed ACK，延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK。   具有所期望序号的按需报文段到达且当前有一个报文段等待ACK传输，即此时处于事件一的状态 立马发送单个累计ACK，确认这两个报文   比所期望序号大的失序报文段到达，即接收产生了间隔 立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号）   能部分或完全填充接收数据间隔的报文段到达 如果该报文段序号起始于间隔的低端，则立即发送ACK    一些有趣的情况   主机A发送的报文在主机B上收到，但从主机B发往主机A的确认报文丢失了。超时事件发生，主机A会重传相\n同的报文段。\n  主机A发送了两个报文段，都被主机B接收，但是在超时之前B发送的两个确认报文没有一个到达A。A重传第\n一个报文，在超时间隔内B发送的第二个确认到达了A。第二个报文段不会被重传。\n  同2，但是在超时之前，A收到了第二个确认报文，第一个确认报文丢失，A不会重传任何报文。\n  超时间隔加倍 每次重传将下一次的超时间隔设为之前的两倍(指数级增长)，收到后再恢复公式计算\n快速重传 为了避免一个超时周期过长，当一个报文段丢失的时候，长超时周期使得发送方延迟重传丢失的分组增加了端到端时延。\n认为如果收到了三个冗余的ACK，那么就执行快速重传，即在该报文段的定时器过期前重传丢失的报文段\n一个修改建议是选择重传：即允许TCP接收方有选择的确认而不是累计确认\n3.5.5 流量控制 流量控制是一个速度匹配服务，使发送方的发送速率和接收方的应用程序读取速率匹配，消除接收方缓存溢出的可能性\nTCP让发送方维护一个**接收窗口(rwnd)**的变量来提供流量控制，接收方给发送方一个指示：接收方还有多少可用的缓存空间\n RcvBuffer: 接收缓存大小 LastByteRead：主机B上的应用进程从缓存中读出的数据流的最后一个字节的编号。 LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。 由于TCP不允许已分配的缓存溢出，下式必须成立：LastByteRcvd-LastByteRead\u0026lt;= RcvBuffer  设置$rwnd=RcvBuffer-(LastByteRcvd-LastByteRead)$\n 以下假设A向B发送报文段 初始时B将rwnd设置为RcvBuffer大小 主机B会见rwnd的大小放在报文段首部中的接收窗口字段中 如果通报了rwnd为0之后B不向A发送报文(不发送确认报文且无向A传输的数据)，可能导致后续B缓存清空后A仍然无法发送报文，故而规定B的接收窗口为0后，A将向B发送只有一个字节数据的报文段。但缓存开始清空后，确认报文中将含有一个非0的rwnd值  3.5.6 TCP连接管理 三次握手：\n 第一步：(SYN报文段)客户端发送报文段,报文段中应用数据为空，报文段首部的标志位SYN置为1,客户随机生成序号，并将其放在序号字段中。 第二步:（SYNACK报文段）服务器为TCP连接分配TCP缓存与变量，并向客户发送允许连接报文段，此报文段应用数据为空，SYN位置1，确认号为客户随机生成的序号+1，并随机选择自己的序号 第三步：收到SYNACK报文段后，客户给连接分配TCP缓存与变量，这个报文段SYN置0.且可以含有应用数据  客户关闭连接：\n 向服务器发送特殊报文段，FIN置1 服务器收到后发送一个确认报文段 服务器在发送一个FIN置1的他的终止报文段 客户进行确认，连接资源释放(客户发送ACK后定时等待后关闭)  3.6 拥塞控制原理 分组重传可以作为网络拥塞的征兆，我们需要一定的机制在网络拥塞时抑制发送方\n3.6.1 拥塞原因与代价 分组的到达速率接近链路容量时，分组经历巨大的排队时延\n发送方必须执行重传以补偿因为缓存溢出而丢弃的分组\n发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本\n当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输流量最终被浪费了\n3.6.2 拥塞控制办法  端到端拥塞控制：网络层没有对运输层控制提供显式支持，即使网络中存在拥塞端系统也必须通过对网络行为的观察来推断。TCP报文段的丢失被认为是网络拥塞的一个征兆 网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显式反馈信息。例如在ATM可用比特率拥塞控制中，路由器显式的通知发送方路由器能够在输出链路上支持的最大主机发送速率  一种是采用阻塞分组(choke packet)的形式 \\ 一种是路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生    3.7 TCP拥塞控制 TCP：让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率\n运行在发送方的TCP用户拥塞控制机制额外跟踪一个变量，也就是拥塞窗口(cwnd).在一个发送方中未确定的数据量不能够超过cwnd和rwnd的最小值\n如何控制速率：每个RTT的起始点，允许发送cwnd个字节的数据，该RTT结束的时候收到确认报文，因此该发送方的发送速率是cwnd/RTT字节/秒\n将丢包事件定义为：要么出现超时，要么收到了来自接收方的三个冗余ACK\n因为TCP使用确认来出发增大他的拥塞窗口长度，故而可以说TCP是自计时的\nTCP的指导性原则：\n 一个丢失的报文段意味着拥塞，因此丢失报文段时应当降低TCP发送方的速率 一个确认报文段表示该网络正在向接收方交付发送方的报文段，因此对向前未确认报文段的确认到达时，能够增加发送方的速率 带宽探测，增加速率以响应到达的ACK，除非出现丢包事件才减小速率  TCP拥塞控制算法：慢启动，拥塞避免，快速恢复\n慢启动 cwnd的初始值通常设置一个MSS的比较小的值，使得初始速率大概只有MSS/RTT，在慢启动状态，cwnd以一个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。之后每过一个RTT，发送速率就翻番。\n如果存在一个丢包事件就把cwnd设置为1并重新启动慢启动过程，并且把慢启动阈值ssthresh置为拥塞窗口值的一半·\n当cwnd上升到ssthresh时，将结束慢启动并且将TCP转移到拥塞避免模式。另一种结束方式是如果是三个冗余ACK，TCP将执行一种快速重传并进入快速恢复状态\n拥塞避免 cwnd在每个RTT线性增加\n超时后，cwnd设置为一个MSS，丢包后ssthresh被设置为原来cwnd的一半。\n如果是三个冗余ACK导致的超时，则将cwnd减半后加三，并且当收到三个冗余ACK，将ssthresh设置为cwnd的一半，然后进入快速恢复状态\n快速恢复 对每个冗余的ACK增加一个MSS，当对丢失报文段的一个ACK到达后，TCP降低cwnd后进入拥塞避免状态。如果在快速恢复种遇到了超时事件，将迁移到慢启动状态并将cwnd设置为1，ssthresh设置为一半\n早期的TCP Tahoe版本是没有快速恢复的，3个冗余ACK也进入慢启动，TCP Reno版本有\n回顾 加性增，乘性减\nTCP Vegas算法：\n 分组丢失之前在源和目的地之间检测路由器种的拥塞 检测出快要发生的分组丢失时，线性的降低发送速率，快要发生的分组丢失通过观察RTT来预测  吞吐量的宏观描述 TCP的传输速率在$W/(2*RTT)$和$W/RTT$之间变化（W：当前窗口长度）\n平均吞吐量：$$\\frac{0.75*W}{RTT}$$\n经高带宽路径的TCP $$平均吞吐量 = \\frac{1.22MSS}{RTT\\sqrt{L}}$$ 其中，L为丢包率，MSS为最大报文段长度\n3.7.1 公平性 如果K条连接都经过一个传输速率为R bps的瓶颈链路，如果每个传输的平均传输速率都接近R/K，那么认为这个拥塞机制是公平的\n实际上那些具有更小的RTT的传输能够更快的抢到可用带宽，因而比那些具有较大RTT的连接先用更高的吞吐量\n由于UDP没有拥塞控制，将挤压TCP资源\n如今许多Web应用使用多个并行TCP连接来抢占链路传输中的带宽\n3.7.2 明确拥塞警告:网络辅助拥塞控制 允许网络明确向TCP发送方和接收方发出拥塞信号，这种形式的网络辅助拥塞控制称为明确拥塞通告(ECN)\n在IP数据报的首部服务类型字段中2个比特用于ECN(4种状态)\n路由器判断拥塞后使用ECN比特设置指示该路由器正在历经拥塞，接受主机收到报文后在TCP ACK中设置ECE发送到主机，通知发送方TCP收到拥塞指示，接下来TCPP发送方通过减半cwnd来对一个具有ECE拥塞指示的ACK作出反应。并在下一个发送给接收方的报文首部中设置CWR比特\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/yun-shu-ceng/","tags":null,"title":"运输层"},{"categories":null,"contents":"关系数据库系统  关系数据库系统\n3.1 关系数据库系统概述\n3.2 关系数据库系统的衡量准则\n 完全关系型的十二条衡量准则 空值（NULL）的定义  3.3 关系模型数学理论—关系代数\n3.3.0 关系模型（概念）\n 关系数据结构 表结构（表头）：表框架，表的元数与基数 关系：关系的性质 关键字：候选关键字，主关键字，外关键字 关系数据库：关系子模式-视图（view） 关系操纵 数据查询：两个关系的合并，单个关系内的元组选择，单个关系内的属性指定 元组的删除、插入、修改 空值的处理 关系中的数据约束 实体完整性约束，参照完整性约束，用户定义的完整性  3.3.1 关系的表示\n 关系的表示，迪卡尔乘积  3.3.2 关系操纵的表示\n 关系代数中的五种基本运算：选择，投影，笛卡儿积，并，差（请注意每个运算符的执行条件和结果关系的关系模式） 基本运算的应用  3.3.3 关系模型与关系代数\n3.3.4 关系代数中的扩充运算\n 交，除法，联接与自然联接，θ-联接 扩充运算与基本运算之间的关系 扩充运算的应用实例  3.3.5 关系代数的应用\n 综合的关系代数应用表示，复杂查询的关系代数表达式 关系代数的应用 单个关系上的选择与投影 两个关系的并、交、差 两个关系的迪卡尔乘积、自然联接、θ-联接 两个关系的除法  难点\n 查询条件带有‘否定’语义：‘不等’比较 \u0026amp; 减法运算 使用表联接查询，还是使用除法? 正确使用自然连接运算 和 除法运算 表的自联接  3.3.6 关系演算\n 原子公式，公式的定义 基于关系演算的数据查询表示：单表查询，多表连接查询，复杂查询的表示（逻辑非、蕴涵操作符）   关系数据库系统衡量准则 十二条标准：\n 信息准则（关系数据库中的所有信息都能在逻辑一级唯一的用表中的值显示表示，结构描述信息在逻辑上组织成关系形式） 确保访问准则（能够用逻辑方式依靠表名、关键字值与列名的组合来访问数据库中每一个原子数据） 空值的关系处理准则（系统应当具有处理空值的能力，空值：无意义或当前未知的值） 基于资源管理的动态联机目录（数据库的描述信息数据字典与用户数据有着相应的形式与操作方式） 统一易用的数据子语言（数据定义、视图定义、数据操纵、完整性约束能力、授权机制、事务处理能力） 视图更新准则 高级的插入、删除及修改操作 物理数据独立性 逻辑数据独立性 数据完整性准则 分布独立性 无损害准则  关系代数 关系模型 二维表的组成：\n 表框架（n个命名的属性，n被称为表的元数） 元组(一个表框架存放了m个元组，m称为表的基数)  满足以下7个性质的二维表称为关系：\n 元组个数有限 元组唯一 元组次序无关 元组分量的原子性 属性名唯一性 属性名次序无关性 分量值域同一性  Relational Rules：\n Rule 1. First Normal Form Rule：Can't have multi-valued fields. Rule 2. Access Rows by Content Only Rule  No order to the rows No order to the columns   Rule 3. The Unique Row Rule  Two rows can't be same in all attributes at once. So that a relation is an unordered SET of tuples. But many products allow this for efficiency of load.    每个关系都有一个名称关系名，关系中的每一个属性有一个名称属性名，关系名和所有的属性名构成了关系框架\n超键：set of colunms that has the uniqueness property\n键：minimal superkey\n候选关键字，主关键字，外关键字\n待补充：关系数据库：关系子模式-视图（view）\n关系操纵 查询：单表查询可以有纵向定位（行选择）和横向定位（选择列），多表查询先将多张表合并再用单表查询操作。可以被分解为三个基本操作：两个关系的合并，单个关系内元组指定，单个关系内属性指定\n插入：一条数据插入操作只能向一个关系中增加元组\n删除：删除的基本单位是元组，一次操作只能删除一个关系内的元组\n修改：不是一个基本操作，可以通过先删再插的操作实现\n操纵对象是关系\n空值处理 关系的主键中不允许出现空值（完整性约束）\n算数表达式中出现空值，结果为空值\n逻辑表达式中出现空值，为逻辑假\n如果是出现了集合中的空值元素，那么仍可使用SUM,AVG,MAX,MIN,COUNT等统计运算，空值不被计算\n如果是对空集进行统计运算，则SUM,AVG,MAX,MIN为空值,COUNT为0\n注意：COUNT(*)是统计元组个数，不存在空值元素问题\n三类数据完整性约束 实体完整性约束：主键中的属性不为空\n参照完整性约束：外键要么取空值，要么是被引用表中当前存在的某元组上的主键值\n用户定义的完整性：用户自己定义的属性取值约束\n关系操纵的表示 n元关系R是一个n元有序组的集合，关系R是n个属性的属性域的笛卡尔乘积的子集\n关系上的基本操作与关系代数中的五种基本运算：\n 元组选择-选择运算 属性指定-投影运算 关系的合并-笛卡尔乘积 元组的插入-并运算 元组的删除-差运算  相容表(compatible tables):Head(R)=Head(S),属性值域相同(不代表一个表中这个属性的所有值要在另一个表中出现)且有相同的意思\n并运算：\n 条件：参与运算的两个关系为同类关系(具有相同属性个数且值域相同) 结果：关系模式不变  差运算（R-S）：\n 条件：参与运算的为同类关系 结果：关系模式不变，由所有属于关系R但是不属于关系S的元组所构成的集合  差运算不满足结合律\n投影运算：略去关系中某些列而重新安排剩余列的排列次序的运算 $\\pi_{B_1,B_2,..B_m}$\n 运算结果：一个由 $B_1,B_2,..B_m$ 组成的m元关系，注意消除结果中可能出现的重复元组  选择运算：根据给定条件F从关系R中选出符合条件的元组, $\\sigma_F(R)$\n 结果：关系模式不变，由属于R且满足F的元组组成  可以解和投影与选择来实现单张表中的数据查询，在没有括号的情况下，运算顺序从右到左\n笛卡尔乘积：两个关系的合并运算，$R\\times S$,若R，S分别有n,m个属性，p,q个元组，则笛卡尔乘积有$n+m$ 个属性，$pq$ 个元组\n如果笛卡尔乘积中存在相同的属性名，必须在结果中选择一个进行换名\n关系模型与关系代数 关系：n元有序组的集合\n关系操纵：关系上的集合运算\n关系代数：$(A,\\pi,\\sigma,\\times,\\cup,-)$\n注意最大最小的比较的时候用$\u0026lt; \\text{or},\\leq$.\n关系代数中的扩充运算 交运算：\n 条件：同类关系 结果：关系模式不变，既属于R也属于S的元组 可以用差运算实现 $ R-(R-S) $  除运算（$R\\div S$）：\n 运算条件：$Head(S)\\subset Head(R)$ 运算结果：$ Head(T)=Head(R)-Head(S) $ ,结果元组T中的元组在S和R中对应同一个值 $$R\\div S = \\pi_{A_1,..A_n}(R)-\\pi_{A_1,..,A_n}((\\pi_{A_1,..,A_n}(R)\\times S)-R)$$  注意的是用商和除数进行笛卡尔乘积，得到的是原被除数的一个子集\n连接运算（$\\theta-连接$，$R {\\bowtie}_{F}S$）:对满足条件F的R中和S中的元组合并为一个关系\n 结果：$Head(T)=Head(R)\\cup Head(S)$，不必消除同名属性但是要换名 推导：$\\sigma_F(R\\times S)$  自然连接：( $R\\bowtie S$ ):自动根据两个关系中的同名属性进行等值连接(即把R和S中同名属性相同的连接在一起)\n关系代数的应用 在订单类的题目中，如果需要使用减法，注意从订单中减还是顾客/供应商减\n关系演算  原子公式，公式的定义\n 在关系演算中，关系用谓词来表示，关系上的操作可以用**关系演算公式(简称公式)**来表示\n元组关系演算：公式中的每个变元都是一个元组\n域关系演算：每个变元的取值都是单个的属性值\n关系演算就是对于所有在关系中的元组对这个谓词是成真指派，其余全是成假指派\n原子公式：\n 谓词R(t)是原子公式 $ u(i)\\theta v(j)$是原子公式，其中u,v为元组变量，u(i)表示元组u上的第i个属性 $u(i)\\theta a$是原子公式，其中a为常量  所有的目标属性以自由变元的形式出现，其他属性以约束变元的形式出现，如检索学生的学号姓名，可以$\\exist sd,sa(S(sno,sn,sd,sa))$.\n当变元与常量进行相等比较的时候，可以直接用常量值代替变元出现在谓词中，如$\\exist cn,pno(C(cno,cn,pno)\\wedge pno='C2')$和$\\exist cn(C(cno,cn,'C2'))$是等价的\n关系的联结：\n 可以通过相关谓词的逻辑与运算实现两个关系的笛卡儿乘积：R(p) ∧ S(q) 在1)的基础上再通过选择条件 F 实现两个关系的θ-联结：$R(p) ∧ S(q) ∧ F$ 可以通过两个谓词中的公共变元（同名变元）实现两个关系的自然联结：$R(x,y,z) ∧ S(y,u,v)$  自联结：谓词名不变，对部分变元进行重命名，从而实现关系的自联结（同名变元取值相等）\n关系演算与关系代数：假设公式$\\phi1$代表关系R1,$\\phi2$对应R2\n $\\phi1 \\wedge \\phi2$:  有公共变元表示R1,R2的自然连接 无公共变元表示笛卡尔积   $\\phi1 \\rightarrow \\phi2$: $R2 \\div R1$  ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/relational-database-system/","tags":null,"title":"关系数据库系统"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 3\n 感觉这一章就给了一些基础概念，看西瓜书也成啊\n3.1 The Agent–Environment Interface The learner and decision maker is called the agent. The thing it interacts with, comprising everything outside the agent, is called the environment.\nOne time step later, in part as a consequence of its action, the agent receives a numerical reward, $R_{t+1}\\in \\textbf{R}$, and finds itself in a new state, $S_{t+1}$.\n定义：$p(s', r|s, a)= Pr{S_t=s',R_t=r | S_{t−1}=s,A_{t−1}=a}$ The function p defines the **dynamics** of the **MDP**\n可以看出在马尔可夫决策过程中，每一个的概率只依靠于前一次的状态于动作\n类似的，可以定义以下函数：\nThe general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment.\n然后举了几个简单的例子，有兴趣可以去看\n3.2 Goals and Rewards 在强化学习中，agent的目标是获取最大化的奖励和。这意味着不能单单只看立即得到的眼前的奖励，而要看长远过程下的奖励之和\n奖励信号更应该告诉agent最终目标，而不是其实现过程，如同下棋时，应当是当你赢时给与奖励而不是局部最优时给予，如果那样设定的话可能导致agent追求局部最优而忽略全局\n3.3 Returns and Episodes In general, we seek to maximize the expected return, where the return, denoted $G_t$, is defined as some specific function of the reward sequence. In the simplest case the return is the sum of the rewards:$G_t=R_{t+1} + R_{t+2} + R_{t+3} + · · · + R_T$ , where T is a final time step.\nThis approach makes sense in applications in which there is a natural notion of final time step, that is, when the agent–environment interaction breaks naturally into subsequences, which we call episodes(有时也用trials)\n每一个episode都有一个终止状态，终止状态后将被重置为初始状态\nTasks with episodes of this kind are called episodic tasks（举例：下棋，走迷宫）. In episodic tasks we sometimes need to distinguish the set of all nonterminal states, denoted $S$, from the set of all states plus the terminal state, denoted $S^+$. The time of termination, $T$, is a random variable that normally varies from episode to episode\n但也有些任务是一直不会终止的，我们称为continuing tasks, 这样的话我们的$G_t$将会是无限大，故而我们采取一种概念上复杂但是数学上简单的discount定义\n$$G_t=R_{t+1} +\\gamma R_{t+2} +\\gamma^2 R_{t+3} + · · · =R_{t+1} + \\gamma G_{t+1}$$\n即discounting rate $0 \\leq \\gamma\\leq 1$，决定了未来奖励的当前价值。\n3.4 Unified Notation for Episodic and Continuing Tasks 在之后的介绍中，我们两种任务都会探讨，所以我们希望寻求一种能够通用的表示两种任务的记法\n我们可以考虑让episode tasks 在进入终止状态后进入一个特殊的 absorbing state，在这个状态下永远只转移到自身状态并且reward永为0，如下图深色方框： 故而可定义$$Gt=\\sum_{k=t+1}^T\\gamma^{k−t−1}R_k$$，这个公式包含了$T = \\infin$ or $\\gamma = 1$ (but not both)的可能性.\n3.5 Policies and Value Functions value functions—functions of states (or of state–action pairs) that estimate how good it is for the agent to be in a given state (or how good it is to perform a given action in a given state).\npolicy is a mapping from states to probabilities of selecting each possible action.\n定义：\nstate-value function for policy : $v_\\pi(s) = E_\\pi(G_t | S_t = s) = E_\\pi( \\sum_{k=0}^{\\infty} \\gamma^k R_{t+k+1} | S_t =s)$\naction-value function for policy: $q_\\pi(s, a) = E_\\pi(G_t | S_t = s, A_t = a) = E_\\pi( \\sum_{k=0}^{\\infty} \\gamma^k R_{t+k+1} | S_t =s, A_t = a)$\n我们一般可以通过经验（大量随机实验样本的均值）来获取其估计值，（如Monte Carlo methods），但是当状态空间很大的时候，这是不现实的，那时可以将其当作参数方程，通过调参的方式来得到返回值，其精确度取决于近似方式\n满足递归关系, 称为是Bellman equation for $v_\\pi$, It expresses a relationship between the value of a state and the values of its successor states. 如果已知参数（p(s′,r|s,a),π等), 则可以视为线性方程组，对于小规模的状态集，可以直接求解，其解就是值函数\n对应的backup diagram：\n3.6 Optimal Policies and Optimal Value Functions optimal policy：$\\pi_*$\noptimal state-value function, denoted $v_*$ and defined as $v_*(s) = \\max_\\pi v_\\pi(s)$\noptimal action-value function, denoted $q_*$, and defined as $q_*(s,a) = max_\\pi q_\\pi(s,a)$\n有关系： $q_*(s, a) = E[R_{t+1} + \\gamma v_*(S_{t+1}) | S_t=s,A_t=a]$ .\n因为$v_*$也是policy的value-function，故而其也满足贝尔曼方程的条件，称为**Bellman optimality equation**.\n可以写作： 最后两行（3.18，3.19）是两种常见的不同的表达形式\n对应的有： 对应的backup diagram为： For finite MDPs, the Bellman optimality equation for $v_{*}$ has a unique solution。如果有n个状态，那么就得到一个n个变量的n个等式，如果知道必要的参数，可以通过解非线性方程组的方式对其进行求解\n解出来后： If you have the optimal value function, $v_{*}$, then the actions that appear best after a one-step search will be optimal actions. Another way of saying this is that any policy that is greedy with respect to the optimal evaluation function $v_{*}$ is an optimal policy.\nWith $q_{*}$, the agent does not even have to do a one-step-ahead search: for any state s, it can simply find any action that maximizes $q_{*}(s, a)$.\n但是这种方式的缺点在于：我们需要精确的知道环境的动态性质且有足够的计算资源去完成所有运算，同时环境需满足马尔科夫性质\n Many different decision-making methods can be viewed as ways of approximately solving the Bellman optimality equation. For example, heuristic search methods can be viewed as expanding the right-hand side of (3.19) several times, up to some depth, forming a “tree” of possibilities, and then using a heuristic evaluation function to approximate $v_{*}$ at the “leaf” nodes. (Heuristic search methods such as $A^*$ are almost always based on the episodic case.) The methods of dynamic programming can be related even more closely to the Bellman optimality equation. Many reinforcement learning methods can be clearly understood as approximately solving the Bellman optimality equation, using actual experienced transitions in place of knowledge of the expected transitions. We consider a variety of such methods in the following chapters.\n ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl3/","tags":null,"title":"Finite Markov Decision Processes"},{"categories":null,"contents":" 基本的共射级，工作原理，如何估算静态工作点， 重要：负载线怎么来的，怎么画 失真与静态工作点的关系 温度的影响（定性的把握） 基极分压式要认识，稳定工作的原理\n 三极管放大电路 在输入为交流信号时，常常在输入输出处都加入一个电容用来阻隔直流信号，防止影响外部电路。\n工作原理 静态 输入信号$v_i=0$,放大电路的工作状态称为静态或直流工作状态\n$I_{BQ}=\\frac{V_{BB}−V_{BEQ}}{R_b}$\n$I_{CQ}=\\beta I_{BQ}+I_{CBO} \\approx \\beta I_{BQ}$\n$V_{CEQ}=V_{CC}−R_c∗I_{CQ}$\n一般硅管的$V_{BE}=0.7V$,锗管的$V_{BE}=0.2V$\n求Q点时，一般先假设电路中BJT满足放大电路条件，求出相应的参数，然后观察是否满足放大条件。\n动态 输入正弦信号$V_s$后，电路处在动态工作状态，此时各极电流电压都会在静态值的基础上随输入信号变化\n 先确定静态工作点$Q(I_{BQ},I_{CQ},V_{CEQ})$ 再动态确定性能指标$(A_V,R_i,R_o)$  图解分析法 静态工作点的图解分析 采用此方法的前提时必须已知三极管的输入输出特性曲线\n利用输入回路方程$V_{BE}=V_{BB}-i_BR_b$做出直线与输入特性曲线的交点得到$I_{BQ}$\n再利用输出回路方程$V_{CE}=V_{CC}-i_CR_C$,在输出特性曲线上与$I_{BQ}$曲线对应的就是Q点。得到$V_{CEQ}$和$I_{CQ}$\n动态工作的分析图解 根据$V_s$的波形，在BJT的输入特性曲线上画出$V_{BE}$和$i_B$的波形\n图中参数: $V_s=V_{sm}sin(wt)$ $V_{BE}=V_{BB}+v_S-i_BR_b$\n然后根据上图得到的$i_B$的变化范围在输出特性曲线上画出$i_c$和$V_{CE}$的波形(利用$V_{CE}=V_{CC}-i_CR_c$)\n静态工作点对波形失真的影响 静态工作点过高 静态工作点过高会导致饱和失真\n静态工作点太低 静态工作点太低会出现截止失真\n所以工作点要设置在输出特性曲线放大区的中间部位，要有合适的交流负载线\ntbd:ppt上思考题\n温度对工作点的影响   温度每升高10度，$I_{CBO}$约增加一倍\n 温度上升，输出特性曲线上移    温度每升高1度，$\\beta$值增大$0.5%-1%$\n 温度上升，输入特性曲线族间距加大    $V_{BE}=V_{BE(T_0=25C)}-(T-T_0)*2.2*10^{-3}V$\n 温度上升,输入特性曲线左移    基极分压式射极偏置电路 目标是：温度变化时使得$I_{CQ}$保持恒定。即我们需要**b点的电位能基本不变**，即可实现静态工作点的稳定\n稳定工作点的原理:\n 保证b点电位基本不变：使$I_1\u0026gt;\u0026gt;I_{BQ}$，$V_B\u0026gt;\u0026gt;V_{BEQ}$,此时$V_{B}=\\frac{R_{b2}}{R_{b1}+R_{b2}}V_{CC}$, 与温度无关 通过反馈控制：温度上升 -\u0026gt; $I_{CQ}$上升 -\u0026gt; $I_{EQ}$上升 -\u0026gt; $V_E$上升，$V_B$不变 -\u0026gt; $V_{BEQ}$下降 -\u0026gt; $I_{BQ}$下降 -\u0026gt; $I_{CQ}$下降 Re取值越大，反馈控制作用越强 一般取 $I_1 =(5-10)I_{BQ}$， VB =3~5V  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E4%B8%89%E6%9E%81%E7%AE%A1%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/","tags":null,"title":"三极管放大电路"},{"categories":null,"contents":"网络层：数据平面  重点：4.2、4.3 网络传输中ipv4报文首部哪些不会改变\n 网络层：实现主机到主机之间的通信服务，与运输层和应用层不同的是，网络中的每一台主机和路由器之间都有一个网络层部分。\n网络层能够分解成两个相互作用的部分，即数据平面和控制平面。数据平面指网络层中每台路由器的功能，决定路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。控制平面即网络逻辑的范围，控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。**软件定义网络(Software-defined Networking ,SDN)**通过将控制平面功能作为一种单独服务，明确分离数据平面与控制平面。\n4.1 网络层概述 转发：分组从一个输入链路接口转移到适当的输出链路接口的路由器的本地动作\n路由选择：确定分组从源到目的地所采取的端到端路径的网络范围处理过程\n控制平面的路由选择算法决定了数据平面的本地转发表\nSDN：把原本实现在路由器中的路由选择算法转移到远程控制器上\n因特网的网络层是尽力而为服务，既不能保证最终交付，也不能保证按序被接收，不能保证端到端时延，也能保证有最小的带宽。\n分组交换机中链路层交换机是基于链路层中帧的字值段做决定，而路由器是网络层设备\n4.2 路由器工作原理 路由器的体系结构：\n 输入端口  终结入物理链路的物理层功能 与入链路远端的数据链路层交互来执行数据链路层功能 执行查询功能， 决定路由器的输出端口 控制分组(携带路由选择协议的分组)从输入端口转发到路由选择处理器   交换结构：将路由器中的输入端口连接到输出端口 输出端口：存储从交换结构接收的分组并通过执行必要的链路层和物理层功能在输出链路上传输这些分组 路由选择处理器：执行控制平面功能，传统的路由器中执行必要的路由选择协议，维护路由选择表和关联链路状态信息，并计算转发表，在SDN中，路由u谢娜则处理器负责与远程控制器通信  4.2.1 输入端口处理与基于目的地转发 输入端口处理：线路端接-\u0026gt; 数据链路处理 -\u0026gt; 查找、转发、排队\n路由器使用分组目的地址的前缀进行最长前缀匹配\n在某些设计中，如果来自其他输出端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时暂时被阻塞，被阻塞分组在输入端口处排队等待被及时调度\n输出端口的其他动作:\n 出现物理层和链路层处理 检查分组版本号、检验和寿命字段，并重写后两个字段 更新用于网络管理的计数器  4.2.2 交换  经内存交换：所有输入共享内存 经总线交换：输入端口为分组计划一个内部标签，与首部匹配的输出端口存分组并去除表情啊 经互联网络交换：可以并行，纵横式的，到不同输出端的分组不会相互阻塞  4.2.3 输出端口处理 排队-\u0026gt;数据链路处理(协议、封装)-\u0026gt;线路端接\n4.2.4 何处出现排队 路由器缓存空间耗尽并无内存可用时会出现丢包\n 输入排队  交换结构不足以使所有到达分组无时延传输 HOL阻塞：被线路前部的一个分组阻塞，如两个分组发送一个目的地   输出排队  4.2.5 分组调度 先进先出(FIFO)：维护队列\n优先权排队：每个优先权有自己的队列，队列内部FIFO。必须高优先级的列空了才处理低优先级，是非抢占的即已经开始的传输不会被打断\n循环和加权公平排队：\n 循环排队规则：将组分成多个队列，轮流提供服务，不允许链路空闲，如果有空则立即检查序列中下一个类 加权公平排队(WFQ):每个类被分配一个权值，保证该类发送的分组中确保接收到的服务部分比例与权重比例一致  4.3 网际协议:IPv4、寻址和IPv6 4.3.1 IPv4数据报格式 |版本4|首部长度4| 服务类型8 | 数据报长度16 | | 16比特标识 |标志3| 13比特片偏移 | | 寿命8 | 上层协议8 | 首部校验和8 | | 32比特源IP地址 | | 32比特目的IP地址 | | 选项(可选) | | 数据 |  版本（号）：规定了数据报的IP协议版本 首部长度：因为可包含一些可变数量的选项 服务类型：(TOS) 使不同类型的IP数据报能够区分开来 数据报长度: IP数据报的总长度(首部+数据) 标识、标志、位偏移：与IP分片有关 寿命(TTL): 确保数据报不会永远在网络中循环，每当一台路由器处理数据报时，这个字段的值就减去1 协议：通常仅当一个IP数据报到达期最终目的地时才有用，字段指示了IP数据报应该交给哪个特定的运输层协议，为6则TCP，为17则UDP 首部校验和：首部校验和用于帮助路由器检测收到的IP数据报中的比特错误。计算方式：每两个字节当成一个数，用反码算数进行求和 源和目的IP地址 选项：允许IP首部被扩展 数据(有效载荷)  一般而言，IPv4的首部长20字节\n4.3.2 IPv4数据分片 链路层帧能够承载的最大数据量：MTU(最大传送单元)\n为了限制最大传输单元MTU，将数据报分片，并设置标识：\n 发送主机对每个他发送的数据报的标识号+1，一个数据报的各个分片的标识相同 最后一个片的标志比特设为1，其余设为0. 偏移字段指定片在初始数据报的哪个位置(每个片也是一个IP数据报)  数据报的重新组装在端系统中而不是网络路由器中\n4.3.3 IPv4编址 IP要求每台主机和路由器接口拥有自己的IP地址，从技术上讲，一个IP地址与一个接口相关而不是接口对应的主机或者路由器相关\n每个IP地址为32比特四字节，采用点分十进制记法书写，每个字节用十进制书写，各个字节之间以句点断开。\n一个IP地址的一部分需要其连接的子网决定，a.b.c.d/x中的/x记法称为子网掩码，而这子网的前x个比特称为这个地址的前缀\n为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，用接口端接这些隔离的网络的端点，这些隔离的网络中的每一个都叫做一个子网\n因特网的地址分配策略被称为是无类别域间路由选择(CIDR)\nIP广播地址：255.255.255.255，交付给同一网络中的所有主机\n获得一块地址 获取一块IP地址用于一个组织的子网内，某网络管理员可能首先与他的ISP联系，该ISP可能从已分给他的更大地址中提供一些地址\n获取主机地址：动态主机配置协议 DHCP允许主机自动获取一个IP地址，可能是固定的，也可能是一个临时的IP地址\n同时，DHCP允许主机得知他的子网掩码，第一跳路由器地址(默认网关)、本地DNS服务器的地址\nDHCP：即插即用协议，也称零配置协议\n DHCP服务器发现：使用DHCP发现报文完成，在UDP分组中向端口67发送该报文，UDP分组封装在一个IP数据报中。使用广播目的地址255.255.255.255使用源地址0.0.0.0。传递给链路层，链路层广播该子网连接的节点 DHCP服务器提供：收到一个发现报文后，用DHCP提供报文做出响应，该报文向子网的所有节点广播，仍然使用IP广播地址255.255.255.255. DHCP请求：从一个或者多个服务器提供的IP选择一个，并提供DHCP请求报文进行响应，回显配置参数 DHCP ACK：服务器使用DHCP ACK报文对DHCP请求报文进行响应证实需要的参数  4.3.4 网络地址转换 网络地址转换：NAT\n他和他背后的网络对外界是一台单一的设备\nNAT路由器将重写IP地址和端口号字段\nNAT转换表：内部地址：端口 - 外部地址：端口\n4.3.5 IPv6 数据报格式 |版本4| 流量类型8 | 流量标签20 | | 有效载荷长度16 |下一个首部8| 寿命8 | | 源地址128 | | 目的地址128 | | 数据 |  一共40字节 版本：IP版本号 流量类型：(类似IPv4的服务类型TOS) 流标签：标识一条数据报的流，能够对一条流中的某些数据给出优先权 有效载荷长度 下一个首部：(类似IPv4中的协议字段)需要交付给哪一个协议，如TCP和UDP 跳限制：(类似IPv4中的寿命限制) 跳限制技术达到0，数据报被丢弃 源地址和目的地址：128比特，引入了任播地址：可以将数据报交付给一组主机中的任意一个 数据：有效载荷  在IPv6中不存在分片/重新组装，首部校验和，选项字段(但是可能出现在下一个首部指向的字段中)\n从IPv4向IPv6迁移 建隧道：将两台IPv6路由器中间IPv4路由器合称隧道，将IPv6的整个数据报放到一个IPv4的数据报的有效载荷中去，通过观察IPv4的协议号是41可以指示器有效载荷是IPv6数据报\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wang-luo-ceng-shu-ju-ping-mian/","tags":null,"title":"网络层-数据平面"},{"categories":null,"contents":"SQL语言  3.4 关系数据库语言SQL’92\n3.4.1 SQL概貌\n SQL的基本概念与使用方式：表（基表/虚表），行，列  3.4.2 SQL数据定义功能\n3.4.3 SQL数据操纵功能\n SQL语言与关系代数的关系 映像语句（select statement）的结构 select/from/where/group by/having/order by 两个必须的子句: select/from having子句的前面必须有group by子句 基本查询功能：distinct谓词；LIKE，IS NULL谓词；多表联接查询；表的自联接查询； 嵌套查询：IN，SOME/ANY/ALL，EXISTS等谓词；相关子查询与独立子查询； 子查询的合并：UNION/INTERSECT/EXCEPT/ALL运算 UNION / INTERSECT / EXCEPT UNION ALL / INTERSECT ALL / EXCEPT ALL 统计查询（GROUP BY和HAVING）：统计与分组统计查询；空值与空集在统计函数中的处理方法 复杂数据查询： 统计查询 分组统计查询（… GROUP BY） 分组选择统计查询（… GROUP BY … HAVING …） 关系代数中的除法运算功能在SQL中的表示方法 多层嵌套的NOT EXISTS查询 在FROM子句中嵌入子查询 查询结果输出 结果元组去重：distinct 结果元组排序：order by  3.4.4 SQL的更新功能\n 元组删除 元组插入：常量元组的插入，带子查询的元组插入 元组修改  3.4.5 视图\n 视图概念，视图与基表的区别 视图的创建（CREATE VIEW）与删除（DROP VIEW） 视图的嵌套定义 视图删除中的连锁反应 可更新视图的判断准则 视图的作用   SQL概貌 关系模型和SQL对应：\n 关系：基表 关系子模式：视图(虚表) 属性：列 元组：行  SQL不区分大小写\n一条命令以分号作为结束\nSQL 数据定义功能    符号 数据类型     INT 整数(2147483647)   SMALLINT 短整数(32767)   DEC(m,n) 十进制数(精度为m,小数位为n的小数)   FLOAT 浮点数   CHAR(n) 定长字符串   VARCHAR(n) 变长字符串   BIT(n) 定长位串   BIT VARYING(n) 变长位串   DATE 日期(年月日)   TIME 时间(小时、分、秒)   TIMESTAMP 时间戳(年月日小时分钟秒微秒)    时间戳的格式：yyyy-mm-dd-hh.mm.ss.nnnnnn\n创建表格：\nCREATE TABLE tablename ( colname datatype [ NOT NULL ] { , colname datatype [ NOT NULL ] } ) ; 对基表的属性进行增加/删除：\nALTER TABLE \u0026lt;基表名\u0026gt; ADD \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;; ALTER TABLE \u0026lt;基表名\u0026gt; DROP \u0026lt;列名\u0026gt; ; 删除表格\nDROP TABLE \u0026lt;基表名\u0026gt;; SQL数据操纵功能 映像语句（select statement）的结构：\n 目标子句 范围子句 条件子句 分组子句 分组查询语句 排序输出语句  SELECT * | colname { , colname ... } FROM tablename { , tablename ... } [ WHERE search_condition ] [ GROUP BY colname { , colname ... } [ HAVING group_condition ] ] [ ORDER BY colname [ ASC | DESC ] { , colname [ ASC | DESC ] ... } ]; having子句的前面必须有group by子句\n目标子句可以用'表名.属性名'来表明是哪一个表中的属性\n可以用AS对目标子句的结果重命名\n可以用distinct来消除结果中的重复元组\n可以在FROM子句中对一个关系重命名：\u0026lt;name\u0026gt; \u0026lt;newname\u0026gt;\nFROM子句中的部分是进行笛卡尔乘积进行合并\nBETWEEN..AND.. 谓词：包括了两端（对应的有NOT BETWEEN AND）\nLIKE谓词： column [NOT] LIKE val1 [ ESCAPE val2 ]\n模版（pattern）：val1\n 下划线（_）：可以匹配任意一个字符 百分号（%）：可以匹配任意一个字符串（包括长度为0的空字符串） 其它字符：只能匹配其自身  例如以A开头的学生姓名：WHERE sn LIKE 'A%'\n转义指示字符：val2\n 紧跟在转义指示字符val2之后的‘_’或‘%’（包括转义字符自身）不再是通配符，而是其自身  例如课程名中带有_ 的：WHERE cn LIKE '%A_%' ESCAPE 'A'\nIS NULL 与 IS NOT NULL；\n在查询语句中可以使用NOT、AND、OR构造复杂的逻辑式\n嵌套查询：\n [NOT] IN () $\\theta$ SOME/ANY/ALL () [NOT] EXISTS ()  相关子查询:子查询中调用了外层查询，每次外层元组变量变化后都重新执行一次子查询，执行顺序从外到内\n独立子查询: 子查询只执行一次，执行顺序从内到外\n子查询之间的运算：\n 并：UNION[ALL] 交：INTERSECT[ALL] 差：EXCEPT[ALL]  统计查询：\n COUNT  COUNT(*):集合中的元组个数 COUNT(colname)：在colname属性上取值非空的元组个数 COUNT(distinct colname)：在colname属性上非空且互不相同的元组个数   SUM AVG MAX MIN  统计查询一般运用在SELECT语句中，如果需要使用条件可以利用子查询，举例如下\n\\\\ 查询有两个或两个以上的客户订购过的商品的编号（pid） SELECT p.pid FROM products p WHERE 2 \u0026lt;= ALL (SELECT count(distinct cid) FROM orders o WHERE o.pid = p.pid ) 不等于的表示：\u0026lt;\u0026gt;;\n使用了GROUP BY 语句之后，SELECT语句对每个分组进行查询，每个分组返回一条结果语句\ntip：在成绩类的判断中，常见的对于一个学生可以利用sno进行分组\n分组统计查询中，目标属性必须包括所有的分组属性\n在一些DBMS中，允许在FROM子句中嵌入子查询，举例如下：\n\\\\每个供应商单笔销售最高金额的平均值 SELECT avg ( t.x ) FROM ( select aid, max(dollars) as x from orders group by aid ) t ; 关系代数中的除法运算功能在SQL中的表示方法\n多层嵌套的NOT EXISTS查询\n在FROM子句中嵌入子查询\n查询结果输出\n结果元组去重：distinct\n结果元组排序：order by\n映像语句的处理顺序:\n 合并FROM子句中的表（笛卡儿乘积） 利用WHERE子句中的条件进行元组选择，抛弃不满足WHERE条件的那些元组 根据GROUP BY子句对保留下来的元组进行分组 利用HAVING子句中的条件对分组后的元组集合（group）进行选择，抛弃不满足HAVING条件的那些元 组集合 根据SELECT子句进行统计计算，生成结果关系中的元组 根据ORDER BY子句对查询结果进行排序  SQL数据更新功能 元组删除 DELETE FROM table_name [ WHERE search_condition ] ; 元组插入 INSERT INTO tabname [ ( colname { , colname … } ) ] VALUES ( expr | NULL { , expr | NULL … } ) | subquery; 可以插入常量元组（VALUES(...)），也可以将子查询结果插入(subquery)\n元组修改 UPDATE table_name SET colname = expr | NULL | subquery, ...... [ WHERE search_condition ] ; 视图 视图的定义：\nCREATE VIEW \u0026lt;视图名\u0026gt; [ ( \u0026lt;列名\u0026gt; { , \u0026lt;列名\u0026gt; … } ) ] AS \u0026lt;映像语句\u0026gt; [ WITH CHECK OPTION ] 视图:由若干张表经过映像语句构筑成的表，又称导出表\n视图与基表的区别：被称为视图的二维表本身（结构与数据）并不实际存在于数据库内，而仅仅保留了其构造信息（有关视图的定义信息）。因此视图又被称为‘虚表’（virtual table）。当用户执行视图上的访问操作时，数据库管理系统将根据视图的定义命令将用户对于视图的访问操作转换成相应基表上的访问操作\n视图的创建 (CREATE VIEW) CREATE VIEW \u0026lt;视图名\u0026gt; [ ( \u0026lt;列名\u0026gt; { , \u0026lt;列名\u0026gt; … } ) ] AS \u0026lt;映像语句\u0026gt; [ WITH CHECK OPTION ] 如上创建一个以\u0026lt;视图名\u0026gt; 为表名的视图，对应的数据查询语句是\u0026lt;映像语句\u0026gt;。以\u0026lt;映像语句\u0026gt;作查询所得到的查询结果即是该视图中的元组。\n如果没有给视图中的属性命名，则用\u0026lt;映像语句\u0026gt;的SELECT子句中的属性名作为视图属性的属性名。否则视图中的属性必需与\u0026lt;映像语句\u0026gt;的SELECT子句中的结果属性一一对应\nWITH CHECK OPTION用于约束视图上的修改操作：如果允许在该视图上执行更新操作，则其更新后的结果元组仍然必需满足视图的定义条件。即通过该视图插入或修改后的新元组能够通过该视图上的查询操作查出来\n可以嵌套的创建视图（即映像语句中FROM一个已经存在的视图）\n视图的删除（DROP VIEW） DROP VIEW \u0026lt;视图名\u0026gt; 删除一个视图后，那些嵌套定义在该视图上的视图也会随之删除\n视图上可以进行查询操作(实际上是先改写成基表上的查询操作)\n允许进行视图上的更新需要满足：视图的每一行必须对应基表的惟一一行，视图的每一列必须对应基表的惟一一列\n 1、没有指定DISTINCT，即重复元组未从查询结果中消除； 2、定义查询的SELECT列表中的每个元素均为列名（而不是常量，表达式或聚合函数），且列名出现不能多于一次； 3、FROM子句只能指定一个表，即视图必须有一个源表且用户有请求该表的权限。如果源表本身就是一个视图，那么视图必须满足这些条件。因此，排除了基于连接、并（UNION）、交（INTERSECT）或差（EXCEPT）操作的所有视图 4、where子句不能包含任何引用了FROM子句的表的嵌套SELECT操作。 5、定义查询不能有GROUP BY或HAVING子句。  视图的作用：提高了数据独立性，简化了用户观点，提供了自动的安全保护功能\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/sql/","tags":null,"title":"SQL语言"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 4\n The key idea of DP, and of reinforcement learning generally, is the use of value functions to organize and structure the search for good policies.\n 如果看完了西瓜书，感觉这一章略读就好\n 4.1 Policy Evaluation (Prediction) 已知$\\pi$, 估计value-function：\n4.2 Policy Improvement 通过上面的算法，我们可以计算出一个policy的value函数，那么为了更好的提升policy，我们可以在当前状态s下选择另一个动作a，之后的行为仍然按照原policy执行，如果$q_\\pi(s,a) \u0026gt; v_\\pi(s)$的话，可以说明替换后的策略更好。\n证明如下： 那么我们可以得到一种greedy的策略：\n4.3 Policy Iteration 利用之前的evaluation与improvement来得到最优的策略：\nPolicy iteration often converges in surprisingly few iterations\n4.4 Value Iteration 由于每进行一次improvement都要进行一次评估，可能导致比较慢，所以可以考虑每进行一步就直接improvement\n这些西瓜书都讲了，再看一遍太浪费时间了\n4.5 Asynchronous Dynamic Programming 以上的DP算法 的一个缺点是需要遍历整个状态集多次，但是当状态集比较大的时候就耗时比较大了(比如举了无数次的例子的backgammon有$10^{20}$个状态)\nAsynchronous DP algorithms are in-place iterative DP algorithms that are not organized in terms of systematic sweeps of the state set. These algorithms update the values of states in any order whatsoever, using whatever values of other states happen to be available. The values of some states may be updated several times before the values of others are updated once. To converge correctly, however, an asynchronous algorithm must continue to update the values of all the states: it can’t ignore any state after some point in the computation. Asynchronous DP algorithms allow great flexibility in selecting states to update.\n第八章有更详细的讨论，不多写了\n4.6 Generalized Policy Iteration  Policy iteration consists of two simultaneous, interacting processes, one making the value function consistent with the current policy (policy evaluation), and the other making the policy greedy with respect to the current value function (policy improvement). In policy iteration, these two processes alternate, each completing before the other begins, but this is not really necessary. In value iteration, for example, only a single iteration of policy evaluation is performed in between each policy improvement. In asynchronous DP methods, the evaluation and improvement processes are interleaved at an even finer grain. In some cases a single state is updated in one process before returning to the other. As long as both processes continue to update all states, the ultimate result is typically the same—convergence to the optimal value function and an optimal policy.\n 我们用generalized policy iteration (GPI）来表示上述两个子过程不断接触修改\n 竞争中有合作，合作中有竞争\nThe evaluation and improvement processes in GPI can be viewed as both competing and cooperating. They compete in the sense that they pull in opposing directions. Making the policy greedy with respect to the value function typically makes the value function incorrect for the changed policy, and making the value function consistent with the policy typically causes that policy no longer to be greedy. In the long run, however, these two processes interact to find a single joint solution: the optimal value function and an optimal policy.\n如下图：\n 4.7 Efficiency of Dynamic Programming 如果用n和k表示状态数与动作数的话，忽略一些实现细节的情况下，复杂度为$k^n$\nIn practice, DP methods can be used with today’s computers to solve MDPs with millions of states\n4.8 Summary 总结了一下前面的内容，然后引出了新概念：\nAll of them update estimates of the values of states based on estimates of the values of successor states. That is, they update estimates on the basis of other estimates. We call this general idea bootstrapping\n","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl4/","tags":null,"title":"Dynamic Programming"},{"categories":null,"contents":"场效应管  场效应管的结构，基本的名词，三极管的区别，为什么能实现电压控制电流，特性曲线（输出与转移），曲线上的分区，不同类型的管子有什么区别，参数，包括符号有什么不一样（上面/下面，左边/右边），主要参数什么意思（交流参数不做要求） JFET的结构，工作原理，特性曲线 特别清晰：场效应管与三极管的同/异\n 场效应晶体管(FET)是一种电压控制的单极性半导体器件，利用电场效应改变内部导电沟道，实现控制输出电流的目的\n场效应管的分类：\n MOSFET绝缘栅型  增强型  N沟道 P沟道   耗尽型  N沟道 P沟道     JEFT结型  N沟道（耗尽型） P沟道（耗尽型）    耗尽型：场效应管没有加偏置电压时，就有导电沟道存在 增强型：场效应管没有加偏置电压时，没有导电沟道\nMOSFET: 金属-氧化物-半导体场效应管 是利用半导体表面电场效应进行工作，故而又称为表面场效应器件\nN沟道增强型MOSFET 结构 工作原理 $V_{GS}$对沟道的控制作用  $V_{GS}\\leq 0$时，没有导电沟道的产生，d、s间加电压也无电流产生 $0\u0026lt;V_{GS}\u0026lt;V_{TN}$时，产生了电场但是未形成导电沟道(反型层)，此时ds间仍无电流 $V_{GS}\u0026gt;V_{TN}$时，电场作用下产生了导电沟道，ds间加电压后有电流的产生。($V_{GS}$越大，那么导电沟道就越厚) 其中$V_{TN}$代表的是N沟道增强型MOSFET的开启电压 产生沟道过程：使栅极接正，源极接负，形成了从栅极到P型硅片的以二氧化硅为截止的平板电容器，产生了一个垂直于半导体表面的电场，使得P极衬底中的空穴被排斥留下不能移动的受主离子(负离子)，形成耗尽层，同时P型衬底中的少子(电子)被吸引到栅极下的衬底表面，栅源电压达到一定值后，在栅极附近的P型硅表面形成了一个N形薄层,称为反型层，实际上也就形成了感生沟道  $V_{DS}$对沟道的控制作用 当$V_{GS}$一定时(即大于开启电压)，$V_{DS}$电压上升将会导致$I_{D}$增大，从而使得沟道电位梯度上升，靠近漏极d处的电位升高，使电场强度减小，从而使沟道变薄。\n当$V_{DS}$增长到使得$V_{GD}=V_{TN}$的时候，在紧靠漏极处会出现预夹断。\n预夹断之后，若$V_{DS}$继续上升，那么夹断区延长，导致沟道电阻上升，使得$I_D$基本不变\n同时作用 给定一个$V_{GS}$,就有一个不同的$i_D-V_{DS}$曲线\n 沟道中只有一种类型的载流子参与导电，所以场效应管也被称为单极型三极管 MOSFET的栅极绝缘，故而$i_G\\approx 0$,输入电阻很高 MOSFET是电压控制器件，$i_D$受$v_{GS}$控制 只有当$v_{GS}\u0026gt;V_{TN}$时，增强型MOSFET的ds端才能导通 预夹断前$i_D$和$V_{DS}$接近线性关系，预夹断后，趋近饱和  I-V特性曲线  输出特性曲线 $i_D=f(v_{DS})|_{v_{GS}=const}$  截止区 $v_{GS}\u0026lt;V_{T}$  导电沟道未形成,$i_D=0$，为截止工作状态   可变电阻区 $v_{DS}\u0026lt;(v_{GS}-V_{TN})$  $i_D=K_n[2(v_{GS}-V_{TN})v_{DS}-v_{DS}^2]\\approx 2K_n(v_{GS}-V_{TN})v_{DS}$   饱和区(也称放大区) $V_{GS}\u0026gt;V_{TN}$且$v_{DS}\\geq (v_{GS}-V_{TN})$  $i_{D}=K_n(v_{GS}-V_{TN})^2$   必须要让FET工作在饱和区才有放大作用    转移特性 $i_D=f(v_{GS})|_{v_{DS}=const}$\nN沟道耗尽型MOSFET 结构与工作原理 在二氧化硅绝缘层中掺有大量的正离子，已存在导电沟道可以在正或负的栅极电压下工作，而且基本无栅流\n 当$V_{GS}\u0026gt;0$时，沟道中感生出更多的负电荷，使得沟道变宽，在$v_{DS}$作用下，$i_D$有着更大的数值 当其小于0时，沟道中负电荷减少，沟道变窄，从而使得漏极电流减小。当负电压到达某值时，耗尽区扩展到这个沟道，沟道被完全夹断，此时$i_D$不存在，这是的栅源电压称为夹断电压(截止电压)$V_P$  I-V特性曲线 P沟道MOSFET 电路符号和N型的区别在于代表衬底的B的箭头方向\n为能正常工作，PMOS管的$v_{DS}$必须为负值，开启电压$V_T$也是负值，**实际电流方向为流出漏极，但是我们假定流入漏极的电流方向为正**\n沟道调制效应等几种效应  沟道长度调制效应  考虑到$V_{DS}$对于沟道长度L的调制效应，实际上饱和区的曲线并不是平坦的   衬底调制效应(体效应)  衬底没有和源极并联时，衬底与源极之间的偏压$v_{BS}$会影响实际的开启(夹断)电压和转移特性(如对于N沟道增强型而言，$V_{BS}$负的越多，转移曲线右移) 为保证导电沟道和衬底之间的PN结反偏，通常会要求N沟道$V_{BS}\\leq 0$,P沟道$v_{BS}\\geq 0$.通常会让N沟道器件衬底接电路最低电位，P沟道器件衬底接电路最高电位   击穿效应  漏衬击穿  外加的漏源电压过高，将漏极到衬底的PN结击穿   栅极击穿  栅极电压过大 通常在栅源间加入双向稳压管，限制栅极电压保护器件      主要参数  直流参数  增强型参数：开启电压$V_T$ 耗尽型参数：夹断电压$V_p$ 耗尽型参数：饱和漏电流$I_{DSS}$ 直流输入电阻$R_{GS}$   交流参数  输出电压$r_{ds}$,不考虑沟道调制效应时为无限大，实际中一般为几十千欧到几百千欧 低频互导$g_m$   极限参数  最大漏极电流$I_{DM}$ 最大耗散功率$P_{DM}$ 最大漏源电压$V_{(BR)DS}$ 最大栅源电压$V_{(BR)GS}$    JEFT 结构 箭头的方向表示栅极正向偏置时，栅极电流方向从P到N，由此可以区分N沟道和P沟道\n工作原理分析-以N沟道为例 $v_{GS}$对沟道的控制作用 其小于0时，PN结反偏，耗尽层加厚，使得沟道变窄\n但他减小到一定值时，沟道夹断，对应的栅源电压$v_{GS}$称为夹断电压$V_{P}$\nN沟道的JEFT夹断电压小于0\n上述分析表明，改变$v_{GS}$大小，可以有效控制沟道电阻的大小。$|v_{GS}|$增大，沟道电阻增大，$i_D$减小\n$v_{DS}$对沟道的控制作用 考虑$v_{GS}$为0的情况，随着$v_{DS}$的增加，一方面沟道电场强度增加，漏极电流增加，另一方面gd间的PN结方向电压增加，在经过源极到沟道的N型半导体区域中形成了沿沟道的电位梯度，靠近漏层的耗尽层加宽，沟道变窄，从上到下呈楔形分布\n$v_{GD}=V_p$时出现预夹断，此时虽然$v_{GD}$上升，但是夹断区延长导致电阻上升，使得$i_D$基本不变\n共同作用 当$V_p\u0026lt;V_{GS}\u0026lt;0$，导电沟道更容易被夹断，对于同样的$v_{DS}$，$i_D$更小\n预夹断处$v_{GD}=v_{GS}-v_{DS}=V_P$\n综上可知\n JFET栅极与沟道间的PN结是反向偏置的，因此$i_G\\approx 0$，输入电阻很高。 JFET是电压控制电流器件，$i_D$受$v_{GS}$控制。 预夹断前$i_D$与$v_{DS}$呈近似线性关系；预夹断后，$i_D$趋于饱和  为什么JFET的输入电阻比BJT高得多？\n特性曲线与参数 FET和BJT的比较  FET和BJT内部都含有两个PN结，外部都有3个电极。它们有如下的对应关系：  FET BJT 栅极g -- 基极b 源极s -- 发射极e 漏极d -- 集电极c 虽然这两类器件的工作原理不相同，但它们都可以利用两个电极之间的电压控制流过第三个电极的电流来实现输入对输出的控制。  MOS管：栅-源电压$v_{GS}$控制漏极$i_D$ BJT：基-射极间电压$v_{BE}$控制集电极电流$i_C$ 在放大区域内，MOS管的$i_D$与$v_{GS}$之间是平方律关系，而BJT的$i_C$与$v_{BE}$之间是指数关系。显然，指数关系更加敏感，所以通常BJT管的跨导要大于MOS管的跨导。 因MOS管的栅极电流$i_G=0$，而BJT管的基极电流$i_B\\neq 0$，且电压$v_{BE}$首先影响$i_B$（或$i_E$），然后通过$i_B$（或$i_E$）实现对$i_E$的控制，故常将BJT称为电流控制器件，MOS管称为电压控制器件， 以示两者之差别。   MOS管的跨导$g_m$不仅与$V_{GSQ}$和开启（夹断）电压的差值（或$I_{DQ}$）有关，而且还与其沟道的宽长比W/L 有关。而BJT的$g_m$ 仅与$I_{CQ}$有关。 这两类器件的输出电阻$r_o$都等于Early电压$V_A$与静态电流（$I_{DQ}$或$I_{CQ}$）的比值。通常BJT的$V_A$比MOS管的$V_A$大。意味着 BJT的输出电阻$r_o$ 比MOS管的大。 MOS管的$K_n$与BJT的$\\beta$ 或$\\alpha$具有类似的性质，即它们主要取决于管子的固有参数（如，尺寸、参杂浓度、载流子迁移率等），而与它们所在的电路无关。  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1/","tags":null,"title":"场效应管"},{"categories":null,"contents":"Existence problems Existence by counting shannon's circuit lower bound double counting 对同样的东西以不同的方式计数两次，得到的结果相同\nhandshaking lemma Handshaking Lemma: At a party, the number of guests who shake hands an odd number of times is even.\n等价于以下的计数方式：构建一个图，如果两人握手则存在一条连接这两个顶点的边，只需要说明所有的所有的奇数度数的点的度数和是偶数\n只需要说明$\\sum_{v \\in V}d(v)=2|E|$即可(偶-偶=偶)\nsperner's lemma 定义一个proper coloring为顶点a,b,c三点颜色不同，ab,ac,bc边上每边只有两种颜色\nSperner's Lemma (1928)： For any properly colored triangulation, there exists a cell receiving all three colors.\n我们再构建一张图，让每个小三角形对应一个顶点，让大三角形外部对应一个顶点，如果存在相邻顶点之间在原图中存在红-蓝边，那么就连接这两点。这样的话，如果是一个三种颜色都有的三角形对应的顶点度数为1，其余的情况就是2或0，而大三角形的红蓝边与外界的点相连的度数也为奇数，根据握手引理，则必然存在一个三角形三种颜色都有\nThe pigeonhole principle 将超过mn个物品分到n个类中，则必然有一个类中物品大于m\ninevitable divisors 对于一个${1,2,..2n}$的子集S，如果$|S|\u0026gt;n$, 那么S中必然存在两个数可以相互整除\n定义$C_m={2^km|k\\geq 0,, 2^km\\leq 2n}$，这样的话S中的每个数都可以分到一个$C_m$中，而同一个$C_m$中的数可以互相整除，必然有一个$C_m$中存在S中的两个及以上的数\nmonotonic sebsequences (Erdos-Szekeres 1935)A sequence of more than mn different real numbers must contain either an increasing subsequence of length m+1, or a decreasing subsequence of length n+1.\n注意的是：子序列是可以被间隔开的，不同于子串\n假设长度为$N\u0026gt;mn$, 那么可以对原序列中的每个点都可以对应一个二维平面上的点$(x_i,y_i)$,其中前者表示以$a_i$为结束点的最长递增子序列的长度，后者对应递减子序列长度，我们可以证明序列中的两个数必然对应的点不同(把后面的那个点加到前面的点对应的子序列中都会让x或y变化)。故而必然有一个点在${1,2,..m}\\times{1,2,..n}$之外，也就得证\ndirichlet's approximation Let $x$ be an irrational number. For any natural number $n$, there is a rational number ${\\frac {p}{q}}$ such that $1\\leq q\\leq n$ and $\\left|x-{\\frac {p}{q}}\\right|\u0026lt;{\\frac {1}{nq}}$\n将$[0, 1]$划分为n个区间，填入$n+1$个数(${kx},k=1,2,..n+1$)，其中${x}=x-\\lfloor x \\rfloor$对应一个数的小数部分\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/existence-problemms/","tags":null,"title":"Existence Problemms"},{"categories":null,"contents":"网络层：控制平面 5.2 路由选择算法 BGP协议报文使用TCP报文封装，RIP使用UDP，OSPF使用IP报文封装\n路由选择算法的目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径\n路由选择算法的分类：\n 集中式路由选择算法：用完整的全局的网络知识来计算，具有全局状态信息的算法叫做链路状态算法(LS) 分散式路由选择算法：路由器使用迭代、分布式的算法计算出最低开销。如距离向量(DV)算法 静态路由选择算法：路由随时间变化缓慢，通常人工配置 动态路由选择算法 负载敏感算法 负载迟钝算法：目前使用的(RIP,OSPF,BGP)都是负载迟钝的  5.2.1 链路状态路由选择算法 如OSPF算法，这通常由**链路状态广播(link state broadcast)**算法完成，节点广播的结果就是所有节点都有该网络的统一、完整的视图\n一种链路状态路由选择算法是Dijkstra算法\n/* * D(v) 到本次迭代，从源节点到目的节点v的最小距离 * p(v) 源节点到点v的最短路径的前一节点 * N‘ 节点子集，包含了源到其点最短路径已知的所有点 */ Initialization: N’ = {u} for all nodes v if v is a neighbor of u then D(v) = c(u, v) else D(v) = ∞ Loop: find w not in N’ such that D(w) is a minimum add w to N’ update D(v) for each neighbor v of w and not in N’: D(v) = min(D(v), D(w)+ c(w, v) ) /* new cost to v is either old cost to v or known least path cost to w plus cost from w to v */ until N’= N 5.2.2 距离向量路由选择算法 迭代的（一直要持续到邻居之间无更多信息交换为止）、异步的、分布式(每个节点要从一个或者多个直接邻居接收某些信息，执行计算，然后把结果分发给邻居)的算法\n使用的协议有BGP,RIP\nBellman-Ford算法：$d_x(y)=min_v{c(x,v)+d_v(y)}$\n算法思路：每个节点从邻居节点处得到一个距离向量，他保存v的距离向量，然后使用Bellman-Ford方程更新自己的距离向量\n 可能遇到的问题：当DV算法稳定后某条链路开销突然改变，可能出现路由选择环路问题，节点间的最短路径相互依赖，导致结果在节点间不断的来回变换直到最后稳定，称为无穷计数问题 一种尝试解决的方式：增加毒性逆转：如果z通过y路由到达目的地x，那么z告诉y，z到x的距离无穷大。但是涉及三个或以上节点的环路毒性逆转无效  5.3 自治系统内部的路由选择：OSPF 为了解决1)互联网规模大，所有路由器之间更新链路开销的负担是巨大的2)ISP希望按照自己的意愿运行路由器或者对外部隐藏其网络的内部组织面貌，这两个问题可以通过将路由器组织进**自治系统(AS)**解决\n自治系统AS由一组通常处在相同管理控制下的路由器组成，通常在一个ISP中的路由器以及互联他们的链路构成一个AS。一个自治系统由其全局唯一的AS号(ASN)所标识,AS号由ICANN区域注册机构分配\n运行在一个自治系统内的路由选择算法叫做自治系统内部路由选择协议\nOSPF:开放最短路优先，是一种链路状态协议，使用洪泛链路状态信息和Dijkstra最低开销路径算法。\n使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，每当一条链路的状态发生变化后，路由器就广播链路状态信息，即使不改变也要周期性(至少30min一次)的广播一次。\nOSPF的优点：\n 安全：所有的OSPF消息经过身份验证，能够配置简单的和MD5(基于配置在所有路由器上共享秘密密钥，路由器对附加了秘密密钥的OSPF分组计算MD5散列值并包括在OSPF分组中，接收路由器根据预配置的秘密密钥计算MD5散列值与OSPF中携带的比较)的鉴别 存在多条相同开销的路径时，允许使用多条路径 对单播和多播综合支持 支持在单个AS内的层次结构：允许AS内划分区域，有一个主干区域，每个区域运行自己的OSPF，如果要跨区域：区域1-\u0026gt;主干区域-\u0026gt;区域2  5.4 ISP之间的路由选择:BGP 因特网中，所有的AS运行相同的AS间路由选择协议，称为边界网关协议(BGP)\n5.4.1 BGP的作用 在BGP中，分组时路由到CIDR化的前缀，每个前缀表示一个子网或者一个子网的集合，因此一台路由器的转发表将具有(x,I)的表项，其中x为前缀，I时路由器的接口之一的接口号\n BGP提供的手段  从邻居AS获得前缀可达信息。BGP允许每个子网向因特网的其余全部部分通告他的存在 确定到该前缀的最好的路由    5.4.2 通告BGP路由信息 对于每个AS，每台路由器要么是网关路由器，要么就是内部路由器，网关路由器直接连接到其他AS中一台或者多台路由器，内部路由器只连接AS内部路由器或者主机\n每队路由器使用179端口的半永久TCP连接来交换路由选择信息\n 跨越两个AS的BGP连接：外部BGP连接(eBGP) AS内部的BGP连接：内部BGP连接(iBGP)  传递可达信息：不断重复AS内部广播，网关传递到其他AS的过程\n5.4.3 确定最好的路由 路由器通过BGP连接通告前缀时，会在前缀中引入一些BGP属性。前缀及其属性称为路由。两个比较重要的属性是AS-PATH和NEXT-HOP。其中AS-PATH包含了通告已经通过的AS列表，NEXT-HOP是AS-PATH起始的路由器接口的IP地址。\n热土豆路由选择 转发表中增加AS外部目的地的步骤：\n 从AS间协议学到经多个网关可到达子网x 使用AS内部的路由选择信息，决定到达每个网关的最低开销路径的开销 热土豆路由选择：选择具有最低最小开销的网关 从转发表确定通往最低开销的网关接口I，在转发表中加入表项(x,I)  热土豆选择：尽可能快的将分组送出其AS，使得他在AS内部的开销最小\n路由选择算法 如果有多条路径，顺序的按照以下规则消除直到只剩下一条：\n 路由被指派一个本地偏好作为属性值之一，具有最高本地偏好的路由被选择 如果多个具有相同的最高本地偏好，则从这些里面选择具有最短AS-PATH的路由(其中距离测量是AS的跳数) 剩下路由中使用热土豆路由选择方式，即最靠近NEXT-HOP路由器的路由 如果仍然剩下多条路由，则使用BGP标识符来选择路由  5.4.4 IP任播 多台服务器使用相同IP地址进行通告，路由器对于这多个通告，将会认为是到达同一个服务器的不同路径，在用户请求时选择较近的那个服务器\n利用BGP实现，可用于DNS和CDN服务\n5.4.5 路由选择策略 所有进入一个接入ISP网络的流量必然时以该网络为目的地，所有离开一个接入ISP的流量必然源于该网络\n5.6 ICMP:因特网控制报文协议 ICMP：被主机和路由器用来彼此沟通网络层的信息，最典型用途时差错检测\nICMP会被作为IP有效载荷承载的，主机收到指明了上层协议为ICMP的数据报后会分解出内容给ICMP\nICMP报文有一个类型字段和一个编码字段，并且包含了引起该ICMP报文首次生成的IP数据报的首部和前8个字节(方便确定引发差错的数据报)\nping的实现 ping程序发送一个ICMP类型8编码0(对此的表述是回显请求)的报文到指定主机，看到回显(echo)请求，目的主机发回一个类型0编码0的ICMP回显回答\nTraceroute的实现 traceroute：允许跟踪一台主机到另外一台主机之间的路由\n源主机的traceroute向目的地主机发送一系列普通的IP数据报，这些数据报每个携带了一个具有不可达UDP端口号的UDP报文段，第一个数据报的TTL(寿命)为1，第二个为2，以此类推。该源主机为每个数据报启动定时器，第n个数据报到达第n个路由器的时候，第n台路由器观察到这个数据报的TTL刚好过期，按照IP协议规则，路由器丢弃这个数据报并发送一个ICMP警告给源主机(类型11编码0).该警告包含了路由器的名字与他的IP，当该ICMP报文返回源主机的时候，源主机从定时器得到往返时延，从ICMP报文得到第n台路由器的名字和IP地址\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wang-luo-ceng-kong-zhi-ping-mian/","tags":null,"title":"网络层-控制平面"},{"categories":null,"contents":"数据库安全性与完整性  4.1 数据库的安全性保护\n 数据库安全的基本概念与内容：主体，客体，身份标识与鉴别，自主访问控制，审计 SQL对数据库安全的支持  SQL中的存取权限 SQL中的授权命令GRANT和权限的回收命令REVOKE    4.2 数据库的完整性保护\n 数据库完整性保护的功能：目的与常用实现措施 实体完整性，参照完整性，用户定义完整性 完整的CREATE TABLE命令 基表的创建 完整性约束的定义：主关键字，外关键字，CHECK约束，UNIQUE，NOT NULL, DEFAULT 触发器及其创建命令   数据库的保护：在数据库的管理系统内部设置一些必要的软件以达到数据保护的目的\n数据库的安全性保护 数据库的安全要求用户：通过规定的访问途径，按照规定的访问规则\n可信计算基TCB：为实现数据库安全所采用的所有实施策略与机制的集合\n主体：数据库中数据的访问者\n客体：数据库中的数据及其载体\n身份标识与鉴别：每个主题有一个标识符与一个用于验证身份的访问口令，主体访问客体时，TCB将对主体所提交的身份标识符与口令进行鉴别，以防止非法访问\n自主访问控制(DAC)：一种基于存取矩阵的安全控制模型，基于用户的鉴别与存取访问规则的确定。每个用户要给以对系统中每个存取对象的存取权限，一个主体访问客体时，系统检查该主体在该客体上是否拥有所需要的权限。\n对于存取权限，只有两种获取方式，一种是客体所有者自动拥有全部权限，另一种是拥有权限的用户自主的将他的权限传授给其他用户\nDAC将在登录和访问数据库时检查权限\n强制访问控制：主体无权将任何权限授予他人\n审计：跟踪用户对数据的访问操作，如访问时间/访问内容/用户名/终端名/操作类型/操作结果，并可以根据审计结果给出报警信息\n这个安全策略需要一个网络中的实体完成，即访问监控器，在TCB中实现\n安全标准 用户自主保护级：自主访问控制、身份鉴别、数据完整性\n系统审计保护级：自主访问控制、身份鉴别、客体重用、审计、数据完整性\n安全标记保护级：自主访问控制、强制访问控制、标记、身份鉴别、客体重用、审计、数据完整性\n结构化保护级：自主访问控制、强制访问控制、标记、身份鉴别、客体重用、审计、数据完整性、隐蔽信道分析、可信路径\n访问验证保护级：自主访问控制、强制访问控制、标记、身份鉴别、客体重用、审计、数据完整性、隐蔽信道分析、可信路径、可信恢复\nSQL对安全的支持 自主访问控制通过(用户，操作对象，操作权限)这样的三元组来定义用户对数据的访问权限\n授权范围：SELECT权、INSERT权、DELETE权、UPDATE权、REFERENCE权、EXECUTE权、USAGE权\n授权：\nGrant \u0026lt;权限\u0026gt; on 表名[(列名)] to 用户 With grant option GRANT \u0026lt;权限\u0026gt; ON \u0026lt;数据对象\u0026gt; FROM \u0026lt;数据库用户\u0026gt; 回收语句：\nREVOKE \u0026lt;操作权限列表\u0026gt; ON \u0026lt;操作对象\u0026gt; FROM \u0026lt;用户名列表\u0026gt; [RESTRICT | CASCADE] CASCADE：连锁回收\nRESTRICT：在不存在连锁回收问题时才能回收权限，否则拒绝回收\n数据库的完整性保护 完整性包括了正确性(数据有效有意义)与一致性（多用户访问时保证对数据的更新与访问保持一致）\n数据库完整性保护：\n 执行更新操作时，检查是否违反完整性约束条件，防止又存取权的合法用户的误操作 目的：  及时发现错误 采取措施防之错误进一步蔓延 最终将数据库恢复正确状态   常用实现措施  完整性约束条件的定义与检查 触发器 并发控制技术    保护基本功能：设置功能、检查功能、处理功能\n完整性规则的三个内容：\n 实体完整性：基表主关键字不为空 参照完整性：关系R中的每个元组在外键F上的值要么为被引用的关系中存在的值，要么为空值 用户定义完整性：用户定义的数据完整性要求  一条完整性约束规则由三个部分组成：\n 完整性约束条件的设置：  属性级的约束（域约束）：数据类型、非空值约束、取值范围约束 元组级别的约束（表约束）：主键、候选键定义(UNIQUE)、外键定义、基于元组的CHECK子句 全局约束（断言assertion）：单个关系中设计统计操作的约束条件、多个关系之间复杂的约束条件   条件的检查（DBMS内部设置） 条件的处理：如破坏完整性，可能拒绝执行并报警，也可能调用相应的函数处理如外键定义子句中的方法或者触发器中给出的方法  约束的命名：CONSTRAINT \u0026lt;约束名\u0026gt; \u0026lt;完整性约束定义子句\u0026gt;\n完整的CREATE TABLE命令需要定义：\n 模式名\u0026amp;表名 属性的定义  属性名\u0026amp;数据类型 缺省值定义 DEFAULT{default_constant | NULL} 属性的数据约束定义(见下)   表级（元组级）的数据约束定义(见下)  属性的约束定义：\n{ NOT NULL | [ CONSTRAINT constraint_name ] UNIQUE | PRIMARY KEY | CHECK ( search_condition ) | REFERENCES table_name [ ( column_name ) ] [ ON DELETE CASCADE | RESTRICT | SET NULL ] [ ON UPDATE CASCADE | RESTRICT | SET NULL ] } 多个属性取值约束定义（表级约束定义），需要另起一行\n[ CONSTRAINT constraint_name ] { UNIQUE ( colname { , colname ... } ) | PRIMARY KEY ( colname { , colname ... } ) | CHECK ( search_condition ) | FOREIGN KEY ( colname { , colname ... } ) REFERENCES table_name [ ( colname { ,colname... } ) ] [ ON DELETE CASCADE | RESTRICT | SET NULL ] [ ON UPDATE CASCADE|RESTRICT|SET NULL ] } UNIQUE可以取空值\n候选键：UNIQUE + NOT NULL\n对于外键REFERENCES KEY后面会加上取值约束与保证一致性的保证措施\nForengen Key约束：\nFOREIGN KEY ( colname { , colname ... } ) REFERENCES table_name [ ( colname { ,colname... } ) ] [ ON DELETE CASCADE | RESTRICT | SET NULL ] [ ON UPDATE CASCADE | RESTRICT | SET NULL ] } Foreign key ...... References ......:定义主外键的引用关系。当对引用表中的外键进行赋值时，需要检查外键值的正确性。\non delete ...... / on update ......: 当在被引用表中删除元组或修改主键值时，需要维护引用表中外键值的正确性，具体方式如下：\n Cascade：同步做连带删除/更新 Restrict：如果在引用表中存在与被删除或修改的主键相关的元组，则拒绝本次对被引用表的delete/update操作 (缺省的维护模式) Set Null：如果在引用表中存在与被删除或修改的主键相关的元组，则自动地将相关元组上的外键值置为空(NULL)  CHECK:其他任意的属性取值约束\n定义断言 CREATE ASSERTION \u0026lt;name\u0026gt; CHECK( \u0026lt;condition\u0026gt; )\n撤消断言 DROP ASSERTION \u0026lt;assertion-name-list\u0026gt;\n触发器:某个事件的发生导致另外一些事情的发生，以消除前一个事件对数据完整性的影响\n触发器的组成：\n 触发事件(用户定义)：为某个完整性约束条件的否定或者某种数据操纵事件 结果事件(用户定义)：触发发生后，消除影响的程序，通常是一组SQL命令 触发过程：DBMS自动调用并执行  创建命令：\nCREATE TRIGGER trigger_name { BEFORE | AFTER } { INSERT | DELETE | UPDATE [ OF colname { , colname ... } ] } ON table_name [ REFERENCING corr_name_def { , ...... } ] /*给新/之前的命名*/ /*执行事件*/ [ FOR EACH ROW | FOR EACH STATEMENT ] [ WHEN ( search_condition ) ] { statement | BEGIN ATOMIC statement; { statement; ... } END 命名方式：\n{ OLD [ ROW ] [ AS ] old_row_corr_name | NEW [ ROW ] [ AS ] new_row_corr_name | OLD TABLE [ AS ] old_table_corr_name | NEW TABLE [ AS ] new_table_corr_name } 删除触发器： DROP TRIGGER trigger_name\n举例：\n/*删除一个客户元组时，需要将该客户所有订单上的cid置为空值(set null)*/ create trigger foreign_cid after delete on customers referencing old as old_custom for each row begin update orders set cid = null where cid = :old_custom.cid ; end; ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/security-and-integrity/","tags":null,"title":"数据库安全性与完整性"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 5\n 蒙特卡洛方法不需要环境的信息，只需要经验（experience—sample sequences of states, actions, and rewards from actual or simulated interaction with an environment.）\nMonte Carlo methods are ways of solving the reinforcement learning problem based on averaging sample returns. To ensure that well-defined returns are available, here we define Monte Carlo methods only for episodic tasks.\n5.1 Monte Carlo Prediction 有两种方法，一种是“first-visit“,把整个片段集所有第一次访问到状态时的returns做平均化处理，来估计$v_\\pi(s)$的值另一种是”**every visit**”，把整个片段集中所有访问到s状态时的returns取平均，来估计$v_\\pi(s)$的值。两种方法都有应用，下给出first-visit，在9和12章介绍every-visit\n每一次返回平均值都是其本身的无偏估计，标准偏差在$\\sqrt{\\frac{1}{n}}$内\n蒙特卡洛算法每一次运行都是独立的，也就是说他不是\u0026quot;bootstrap\u0026quot;的\n5.2 Monte Carlo Estimation of Action Values 如何估计$q_\\pi(s,a)$, 同上一小节一样也是first-visit与every-visit两种方式\n不过有一个问题在于如何保证所有的action都被考虑到，这就是之前第二章提到的如何保持exploit和explore的关系的问题，称为“maintaining exloration“问题，一种解决方式是对于每一个state–action pair，都给予其一定的概率作为一个episode的起点，这样当取样次数趋于无限的时候，每一个pair的取样次数也趋于无限了，这种方式的假设称为exploring starts. 但是这样有一个问题就是\u0026quot;it cannot be relied upon in general, particularly when learning directly from actual interaction with an environment.\u0026quot;, 此时一种常见的策略是调整policy，使得对于一个状态，所有的action都有一定的概率发生\n5.3 Monte Carlo Control 蒙特卡洛方法估计最优policies的方法和DP差不多：先迭代value function使之逼近当前policy的真实value function，然后基于更新后的value function进行policy improvement，直到最终policy基本不再变化\n由于我们在此处估计的是$q_\\pi(s,a)$，就不需要额外的model来确定最优的action了，可以直接根据$\\pi(s)=\\arg \\max_a q(s, a)$来确定\n为了更具备实际意义，我们要考虑如何去掉infinte number of episodes 的假设 ，一种方式是设立一个极小值，当两次policy evaluation的差别小于这个值的时候，认为此次policy evaluation结束，这种方式在小规模情况下很好，但是数据规模较大时仍然会需要比较多次。另一种方式就是放弃完整的policy evaluation，类似于4.6中的value iteration\n以下算法仍然基于了exploring starts 假设\n5.4 Monte Carlo Control without Exploring Starts on-policy: 直接优化或评价目标策略\n对于on-policy策略而言，对于所有的pair有$\\pi(a|s) \\ge \\frac{\\varepsilon}{|\\mathcal A(s)|}$\n采取第二章中提到的类似的方法，以$p= 1- \\varepsilon + \\frac{\\varepsilon}{|\\mathcal A(s)|}$的概率选取原先确定的action\n此处省略一大段，如果有兴趣看相关证明的可以自己看书\n5.5 Off-policy Prediction via Importance Sampling 在on-policy中，由于我们需要explore所有的action，这也就导致我们在一些时候会选择非最优的情况，故而我们有了off-policy的想法\noff-policy: 有两个策略，一个叫行为策略 $b$（behavior policy），另一个叫做目标策略$\\pi$（target policy），从behavior policy生成的episodes中学习target policy的过程，叫做off-policy learning。\n 关于off-policy与on-policy的应用比较\nThroughout the rest of this book we consider both on-policy and off-policy methods. On-policy methods are generally simpler and are considered first. Off-policy methods require additional concepts and notation, and because the data is due to a di↵erent policy, off-policy methods are often of greater variance and are slower to converge. On the other hand, off-policy methods are more powerful and general.They include on-policy methods as the special case in which the target and behavior policies are the same. Off-policy methods also have a variety of additional uses in applications. For example, they can often be applied to learn from data generated by a conventional non-learning controller, or from a human expert. Off-policy learning is also seen by some as key to learning multi-step predictive models of the world’s dynamics\n 下面又是一大波我不想看的数学知识\nTODO()以后一定补\n因此有两种方式，可以取：\n一种是取平均（ordinary importance sampling）\n$$V(s) = \\frac{\\sum_{t \\in \\mathcal T(s)} \\rho_t G_t}{|\\mathcal T(s)|}$$\n另一种是加权平均（weighted average）\n$$V(s) = \\frac{\\sum_{t \\in \\mathcal T(s)} \\rho_t G_t}{\\sum_{t \\in \\mathcal T(s)} \\rho_t}$$\n5.6 Incremental Implementation 5.7 Off-policy Monte Carlo Control ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl5/","tags":null,"title":"Monte Carlo Methods"},{"categories":null,"contents":" 认识基本的共源极，知道工作原理就行了，公式不会要求记忆 图解法求静态工作点，工作的时候是怎么移动的，失真对于图像的影响\n 场效应管放大电路 基本共源极电路的组成 如何让MOS管工作在饱和区：\n $V_{GG}$提供栅源电压使得$V_{GS}\u0026gt;V_{TN}$ $V_{DD}$和$R_{D}$提供合适的漏源电压使得$V_{DS}\u0026gt;v_{GS}-V_{TN}$ 同时$R_d$还有将电流转化为电压的作用 通常称$V_{GG}、V_{DD}$为工作电源，$v_I$为信号  信号的传递：\n $v_i\\to \\Delta v_{GS} \\to \\Delta i_{D} \\to \\Delta v_{DS}(=v_O)$ 因为在饱和区的$i_D=K_n(v_{GS}-V_{TN})^2$,所以可以根据MOS的控制关系得到上面的式子 信号由栅源回路输入，漏源回路输出，所以源极时公共端，，所以称为共源回路  基本共源极放大电路工作原理 放大电路的静态和动态 静态：输入信号为0时的工作状态，也叫直流工作状态\n静态工作点$Q(I_{DQ},V_{GSQ},V_{DSQ})$\n输入信号不为0时，放大电路的工作状态称为交流工作状态\n放大电路的直流通路和交流通路 仅有直流电流流经的叫做直流通路\n直流电流电压源的内阻为0，交流电流流经直流电压源时不产生任何交流压降，所以直流电压源对于交流相当于短路\n放大电路的静态工作点估算 先假设工作在饱和区，利用FET特性方程求解后，需要检验是否满足$V_{DSQ}\u0026gt;V_{GSQ}-V_{TN}\u0026gt;0$，不满足则说明工作在可变电阻区或者截止区\n这是增强型NMOS管的计算方法，其他管型的静态工作点方法需要归纳\n放大电路的动态工作情况 放大电路的习惯画法 省略工作电源的直流电压符号，仅保留电压源非接地端子，并标注电压源名称\n图解法确定静态工作点 利用直线方程$V_{DS}=V_{DD}-i_DR_d$,$v_{GS}=V_{GG}$\n动态工作情况的图解分析 正常工作情况 由于$v_{GS}=V_{GSQ}+v_i$\n我们可以得到以下结论：\n $v_i$上升，则$v_{GS}$增加，则$i_D$增加，故而导致$V_{DS}$下降，故而当$v_i$正半周时$|v_{ds}(v_o)|$上升 $v_{ds}$和$v_i$的相位相反 可以测量出放大电路的电压放大倍数 可以确定最大不失真输出幅度  静态工作点对于波形失真的影响 截止失真(NMOS)\n饱和失真(NMOS)\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF/","tags":null,"title":"场效应管放大电路"},{"categories":null,"contents":"The probabilistic method The probabilistic method  性质1：需要证明某种东西存在，我们可以证明如果一个东西随机的选择出来的概率是正数，那么这个东西必然存在 性质2：任何一个随机变量都必然存在一个值不小于他的期望，必然存在一个值不大于他的期望  求解方式：\n 设计事件  边的方向以 $1/2$ 的概率随机点/边 以$p$为概率被选入集合中（此后求解使期望最小/大的p值）   求解概率  直接计算概率，可能会用到$(1-p)^x = e^{-px}$ 利用$E \\left[ \\sum\\limits_{i=1}^n a_i X_i \\right] = \\sum\\limits_{i=1}^n a_i \\cdot E[X_i]$求随机变量的期望(利用性质2求解至少有的问题)    Ramsey number $K_n$: n个顶点的完全图\nmonochromatic graph: 所有边的颜色相同\nRamsey number $R(k,\\ell )$ is the smallest integer $n$ such that in any two-coloring of the edges of a complete graph on $n$ vertices $K_n$ by red and blue, either there is a red $K_k$ or there is a blue $ K_{\\ell }$.\n对$R(k,k)$给出下界：如果${n \\choose k}\\cdot 2^{1-{k \\choose 2}}\u0026lt;1$，那么则不存在一个单色的$K_k$: 采用抛硬币的方式对边随机染色，那么可以求出存在一个选择使得$K_k$单色的概率小于1，那么可以证明存在一个概率大于0的选择使得任意的$K_k$都不单色\n证明过程中使用了union-bound（至少一个事件发生的概率小于等于所有事件概率和）： $$\\mathbb{P}\\left(\\bigcup_i A_i\\right)\\leq \\sum_i\\mathbb P(A_i)$$\nTournament Linearity of expectation Independent sets Coloring large-grith graphs Lovasz Local Lemma Lovász Local Lemma (symmetric case)： Let $ A_{1},A_{2},\\ldots ,A_{n}$ be a set of events, and assume that the following hold:\n for all $ 1\\leq i\\leq n$, $ \\Pr[A_{i}]\\leq p $; the maximum degree of the dependency graph for the events $ A_{1},A_{2},\\ldots ,A_{n} $ is $ d $, and $ ep(d+1)\\leq 1 $.  Then $ \\Pr \\left[\\bigwedge {i=1}^{n}{\\overline {A{i}}}\\right]\u0026gt;0 $\nrevisit:Ramsey number 可以利用 Lovasz Local Lemma 证明$R(k,k)\\geq Ck2^{k/2}$对于一些常数$C\u0026gt;0$\n定义$A_S$ 为坏事件：一个点集S构成了一个单色的$K_k$,这个坏事件和其他的坏事件的不独立当且仅当他们相交的点超过了两个。所以最大度为$\\binom{k}{2}\\binom{n}{k-2}$\n然后说明所有坏事件都不成立的情况，即在n取到某值的时候，概率大于0，所以存在不存在单色$K_k$的情况，所以$R(k,k)$必然大于这个n\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/probablistic-methods/","tags":null,"title":"Probablistic Methods"},{"categories":null,"contents":"链路层与局域网 两种链路层信道：\n 广播信道：连接有线局域网、卫星网和混合光纤同轴电缆(HFC)接入网中的多台主机，因为许多主机与相同广播信道连接，所以需要媒体访问协议来协调帧传输 点对点通信链路：长距离链路连接的两台路由器、办公室计算机与他们连接到邻近的以太网交换机之间。点到点协议(Point-to-Point Protocol,PPP)  6.1概述 为方便讨论，本章将所有运行链路层协议的任何设备均称为节点(node)(包括主机、路由器、交换机和WIFI接入点)\n将沿着通信路径连接相邻节点的通信信道称为链路(link)\n6.1.1链路层提供的服务 可能包括：\n 成帧：帧由一个数据字段和若干首部字段组成 链路接入：**媒体访问控制(Medium Access Control, MAC)**协议规定了帧在链路上的接入规则，对于点对点；链路，MAC协议比较简单(或者不存在)，当多个节点共享单个广播链路时，即多路访问问题，在这里MAC协议用于协调多个节点的帧传输。 可靠交付：保证无差错的经链路层移动每个网络层数据报，目的在于纠正一个差错而不是通过运输层或应用层协议来迫使重传。但是对于一些低比特差错的链路，如光纤、同轴电缆和很多双绞铜线链路，链路层的可靠交付有时被视为不必要的，所以很多有限的链路层协议不提供可靠交付服务 差错检测和纠正：由于信号衰减和电磁噪声导致差错。许多链路层协议会让发送节点在帧中包括差错检测比特，让接收节点进行差错检查。  6.1.2链路层实现位置 链路层主体部分是在网络适配器(network adapter)中实现的，也被称为网络接口卡(Network Interface Card,NIC), 网络适配器的核心是链路层控制器，控制器通常是一个实现了许多链路层服务的专用芯片。\n之前很多网络适配器是物理上分离的卡，但现在越来越多的网络适配器被综合进入主机的主板，即所谓的局域网在主板配置\n尽管大部分链路层是在硬件中实现的，但部分链路层是在运行于主机CPU上的软件中实现的。链路层中的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。接收端的链路层软件响应控制器中断、处理差错条件和将数据报向上传递给网络层。\n链路层是协议栈上硬件与软件交接的地方\n6.2 差错检测和纠正技术 我们使用**差错检测和纠正比特(Error-Detection and-Correction, EDC)**来增强数据D.(D包括了链路层首部信息和数据报)。我们发送D和EDC，根据接收到的D'和EDC'来判断D'是否与D一致\n我们现在研究在传输数据中检测差错的三种方法：\n 奇偶校验（描述差错检测和纠正背后隐藏的基本思想） 检验和方法（通常更多的运用于运输层） 循环冗余检测（更多的应用在适配器中的链路层）  6.2.1奇偶校验 单个奇偶校验位(假设数据有d个比特)：\n 偶校验：附加一个比特使得d+1个比特中1的数量总是偶数 奇校验：附加一个比特使得d+1个比特中1的数量总是奇数  但是测量已经表明了差错经常以突发形势聚集在一起，而不是独立发生。\n考虑更一般的二维奇偶校验(two-dimensional parity):将d个比特划分为$i$ 行$j$ 列，然后对每行每列都计算奇偶值，产生的$i+j+1$ 个奇偶比特构成了链路层帧的差错检测比特。这种方式可以检测和纠正单个比特的差错，可以检测(但不能纠正)两个比特差错的组合。\n接收方检测和纠正差错的能力叫做前向纠错(Forward Error Correction, FEC)\n6.2.2 检验和方法 将d比特数据看成一个k比特整数处理，一个简单的检验和方法就是将这k比特数加起来，将和作为差错检测比特\n因特网检验和方法基于这种方法，将数据的字节作为16比特的整数等待并求和，这个和的反码形成了携带在报文段首部的因特网检验和。接收方对接收到的数据（包括检验和）的和取反码，并检测结果是否为全1，如果有一个比特为0，就可以检验出差错(在书的3.3节讨论)\n为什么运输层使用检验和而链路层采用CRC呢：因为运输层通常在主机中作为用户操作系统的一部分用软件实现，采用简单而快速的方法是必要的，而链路层的差错检测在适配器中用专用的硬件实现，能快速执行更复杂的CRC操作\n6.2.3 循环冗余检测 循环冗余检测(Cyclic Redundancy Check, CRC)编码 也被称为多项式编码(polynomial code),\n在这种方法中，考虑d比特的数据$D$，发送节点要把它发送给接收节点，两者首先要协商好一个$r+1$ 比特模式，称为生成多项式(generator), 我们将其表示为$G$, 我们要求G的最高有效位必须为1。对于一个给定的数据段$D$, 发送方要选择$r$ 个附加比特$R$，并将它附加到D上，使得得到的$d+r$比特模式使用模2算术恰好能被G整除\n对于模2运算，加法不进位，减法不借位，即加法与减法是相同的，都可以用XOR异或操作代替，即\n​ $D\\cdot 2^r$ XOR $R = nG $\n而同时两边用R异或，可以得到 $D\\cdot 2^r = nG$ XOR $R$，即$R = reminder\\frac{D\\cdot 2^r}{G}$\n6.3 多路访问链路和协议 **广播链路(broadcast link)**能够使得多个发送和接收节点到连接到相同的、单一的、共享的广播信道上，使用“广播” 是因为任何一个节点在传输一个帧的时候，信道广播该帧，每个其他一个节点都会收到一个副本。\n节点通过多路访问协议来规范他们在共享的广播信道上的传输行为\n如果多个节点同时传输帧，那么也就是说传输的帧在所有的接收方处碰撞(collide),所有涉及到此次碰撞的帧全部都损失了\n目前的任何多路访问协议都可以划分为三种类型：信道划分协议、随机接入协议和轮流协议\n对于一个速率位R bps的广播信道，理想的多路访问协议应该具备以下特性\n 当只有一个节点时，该节点有R bps的吞吐量 有M个节点发送数据时，每个节点在一些适当定义的时间内有R/M的平均传输速率 协议是分散的，不会因为某主节点故障而使得整个系统崩溃 协议是简单的，实现不昂贵  6.3.1信道划分协议 TDM: 将时间划分为时间帧，并进一步将每个帧划分为N个时隙，通常选择的时隙长度要能使一个时隙内能传输单个分组，能避免碰撞且非常公平，缺陷是节点被限制为R/N bps的平均传输速率，节点必须总是等待他在传输序列中的轮次，即使只有他一个节点\nFDM：将R bps信道划分为不同的频段，每个频段具有R/N的带宽，并将每个频率分配给N个节点中的一个，缺点和TDM一样，限制一个节点只能使用R/N的带宽。\n码分多址(Code Division Multiple Access, CDMA): 对每个节点分配一种编码，然后每个节点用他唯一的编码对他发送的数据进行编码。如果进行选择这些编码，CDMA将可以使得不同节点能够同时传输，并且他们各自的相应的接收方仍能正确接收。(假设接收方能够直到发送方的编码)\n6.3.2 随机接入协议 在随机接入协议中，涉及碰撞的每一个节点重发他的帧（也就是分组），直到帧无障碍的通过为止，但是他在重发该帧之前会等待一个随机时延。每个节点独立选择随机时延。我们在本块描述一些最常用的随机接入协议\n时隙ALOHA 做如下假设：\n 所有帧都是L比特 将时间划分为长度为L/R的时隙(也就是说一个时隙等于传输一帧的时间)， 节点值在时隙起点开始传输帧 时间是同步的，每个节点都知道时隙何时开始。 如果在一个时隙中发生碰撞，则所有节点在该时隙结束前检测到该事件  令$p$是一个概率，操作如下：\n 在每个节点中，当节点有一个新帧要发送时，他等到下一个时隙开始并在该时隙传输整个帧 如果没有碰撞则成功传输（此时如果又新帧，他能够为传输准备一个新帧） 如果有碰撞，节点能够在时隙结束前检测到碰撞，该节点在后续的每一个时隙中都以概率p的可能性去重传这个帧直到其传输成功。  除了发生碰撞的帧之外，还有可能会有某个时隙是空闲的，只有刚好有一个节点传输的时隙叫做成功时隙，时隙多路访问协议的效率 定义为：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额。\n可以分析得到这个协议的最大效率是0.37。\nALOHA 时隙ALOHA要求所有节点同步他们的传输，而单纯的ALOHA是非时隙的\n当第一帧到达时立刻开始传输，如果碰撞，立刻以p的概率重传，否则等待一个帧的传输时间，再次以p的概率重传直到传输成功。\n纯aloha协议只有时隙的效率的一半\n载波侦听多路访问：CSMA 载波侦听(carrier sensing)：一个节点在传输前先听信道，如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间(96比特时间)没有传输，然后开始传输\n之所以侦听了还有可能碰撞的原因是端到端的信道传播时延,如B开始传输后但是还没到达D之前，D认为信道空闲开始传输\n具有碰撞检测的载波侦听多路访问：CSMA/CD 碰撞检测(collision detection)：当一个传输节点在传输时一直监听此信道，如果他检测到另一个节点正在传输干扰帧，就停止运输，在重复“侦听-当空闲时传输”循环前等待一段随机时间。\n检测到碰撞后会发送Jam信号来强化碰撞让其余点也知道\nCSMA/CD工作流程：\n 适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中 如果适配器检测到信道空闲，他开始传输帧。(传输前等待96比特时间，即最小帧间隔)另一方面，如果侦听到信道正在忙，就等待直到侦听到没有信号能量 传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量存在 如果传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了传输，否则就停止传输 中止传输后，等待一个随机时间量  关于等待的随机时间确定，用于以太网和DOCSIS电缆网络多路访问协议中的二进制指数后退算法解决了这个问题，当传输一个帧发生了n次碰撞后，下一次的时间间隔K从${0,1,2,3,\\cdots, 2^n-1}$中等概率选取。此处选取的K代表的延迟时间为发送K*512比特所需要的时间。n最大为10，达到10后6次保持10不变，16次均失败后放弃重传\nCSMA/CD效率：当有大量的活跃节点，且每个节点有大量的帧要发送时，帧在信道中无碰撞地运输那部分时间在长期运行时间中所占的份额。近似式$$\\frac{1}{1+5d_{prop}/d_{trans}}$$\n最小帧长：检测冲突的时长不超过端到端时延的两倍，取这一值为最小帧长\n6.3.3 轮流协议 前面的ALOHA协议和CSMA协议具备了理想协议的第一个特性，但是不具备第二个特性(有M个节点发送数据时，每个节点在一些适当定义的时间内有R/M的平均传输速率). 轮流协议就是为满足这个协议而创造的。\n轮流协议有很多种，此处讨论两种。\n轮询协议(polling protocol)：节点之一被指定为主节点，主节点以循环的方式轮询每个节点，先向节点1发送报文告诉他节点1最多能传输的帧的数量，节点1传输了某些帧后，再告诉节点2。(主节点通过观察信道上是都缺乏信号来决定一个节点何时完成了传送)。 缺点是引入了轮询时延，因为即使只有一个活跃节点也要轮询每一个非活跃的节点，第二个缺点是主节点如果有故障，整个信道都将不可操作\n轮询协议的典型例子是802.15协议和蓝牙协议\n令牌传递协议：用一个称为**令牌(token)**的小的特殊帧再节点之间以某种固定的次序进行交换，一个节点收到令牌时，只有其需要发送一些帧的时候才持有该令牌，否则其立即向下一个节点转发该令牌，如果其有帧要传输，则发送最大数目的帧数，然后向下一个节点转发。其缺点是一个节点的故障可能导致整个信道崩溃或者一个节点偶然忘记了释放令牌，这些必须调用某些恢复步骤使令牌返回到循环中来。\n6.3.4 DOCSIS：用于电缆因特网接入的链路层协议 一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个**电缆调制解调器端接系统(CMTS)**连接，**数据经电缆服务接口（Data-Over-Cable Service Interface, DOCSIS）**规范定义了电缆数据网络体系结构及其协议。\nDOCSIS使用FDM将下行(CMTS到调制解调器)和上行网络段划分为多个频率信道。\n此处略去n字\n6.4 交换局域网 6.4.1 链路层寻址和ARP ARP：从IP地址到链路层地址的地址解析协议\nMAC地址 事实上，并不是主机或者路由器具有链路层地址，而是他们的适配器（网络接口）具有链路层地址。\n但是链路层交换机并不具有与他们接口相关联的链路层地址。因为链路层交换机的任务是在主机和路由器之间承载数据报，交换机透明的执行该任务 。\n链路层地址有各种不同的称呼：LAN地址，物理地址，MAC地址，这三者表示同一个东西\n对于大多数局域网而言，MAC地址长度为6字节，每一块适配器的MAC地址都是不同的，且一个适配器的MAC地址都不会变化。MAC地址使用十六进制表示，每个字节表示为一对十六进制数，如5C-66-AB-90-75-B1这种表示方式\n发送适配器会将目的适配器的MAC地址插入到帧中，并将该帧发送到局域网中，一台交换机偶尔将这个帧广播到所有接口，适配器接收到一个帧的时候，检验该帧中的MAC地址是否与自己的匹配，若匹配则提取出封装的数据并沿着协议栈向上传递，否则就丢弃。\n如果需要使得局域网内所有适配器都接收到一个帧的信息，则插入一个特殊的MAC广播地址，对于使用6字节的局域网(如以太网和802.11)来说，广播地址是48个1组成的字符串(FF-FF-FF-FF)\n地址解析协议 地址解析协议：将网络层地址转化为链路层地址\n每台主机或者路由器的内存中都有一个ARP表中，取在相同局域网内的任意IP地址作为输入，可以返回相应的MAC地址。同时这个表中包含了一个寿命值，指示了表中删除每个映射的时间，一个表项通常的过期时间是20分钟。\nARP只为在同一个子网内的主机和路由器接口解析IP地址\n如果发送主机的ARP表中没有目的主机的表项，则发送方用ARP协议来解析这个地址，构造一个称为**ARP分组(ARP packet)**的特殊分组，包括了发送和接收IP地址以及MAC地址，ARP的查询分组和响应分组有着相同的格式，构造完成后，适配器用广播地址来发送这个分组，并传入子网中，而包含该ARP查询的帧能被子网上所有适配器接收到，每个适配器将该ARP分组向上传递给ARP模块，这些ARP模块检查其IP地址是否与ARP分组中的目的IP地址一致，与之匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组。然后查询主机更新其ARP表并发送其IP数据报。\n发送数据到子网之外 路由器的每个接口都有一个IP和适配器(MAC地址)。\n考虑一个连接了两个子网的路由器，发送主机通过ARP找到路由器的MAC地址并向其转发（转发的帧中包括了其他子网的目标IP）,路由器看到这个是向其寻址后传递给路由器的网络层，网络层通过查询路由器中的转发表得到器通过哪个接口转发，路由器通过ARP获取了另一个子网的目标主机的MAC地址，通过接口向这个适配器传递\n6.4.2 以太网 以太网：有线局域网\n在20世纪90年代后期，大多数公司和大学使用一种基于**集线器(hub)**的星形拓扑以太网安装，集线器是一种物理层设备，他作用于比特而不是帧，当一个比特到达一个接口时，集线器重新生成一个能量更大的相同的比特，并向所有其他接口传输出去。这是可能发生碰撞的。\n在21实际，以太网继续使用星形拓扑，但是将集线器换成了交换机(switch), 交换机是无碰撞的，并且是名副其实的存储转发分组交换机。\n以太网的帧结构  前同步码 目的地址 源地址 类型 数据 CRC\n 数据字段（46-1500字节）：承载了IP数据，以太网的最大传输单位（MTU）是1500字节，这意味着如果IP数据报超过了1500字节则需要分片，数据字段最小为46字节，如果少于46字节则需要填充至46字节，网络层接收到数据报后可以根据IP数据报首部的长度字段来去除填充部分。(最小帧长的确定：端到端时延的两倍)\n目的地址 (6字节)： 包含了目的适配器的MAC地址\n源地址(6字节)： 传输该帧到局域网上的适配器MAC地址\n类型字段(2字节)：类型字段允许以太网复用多种网络层协议，当以太网帧到达适配器B后，B需要知道其将数据字段内容传递给哪个网络层协议。\nCRC（4字节）：循环冗余检测\n前同步码(8字节)： 前7字节为10101010，最后一个字节为10101011，其前七个字节的作用在于唤醒接收适配器，并它们的时钟和发送方的始终同步，前同步码的第八个字节最后两个比特用来警告适配器“重要的内容来了”。\n以太网向网络层提供不可靠技术，即适配器B收到A的帧后，不会告诉A是否通过了CRC校验，如果没有通过校验则直接丢弃该帧，如果应用使用了UDP协议，则可以看到数据中的间隙，如果使用TCP协议，那么TCP将不会确认包含在这个数据帧中的数据，从而引起A中的TCP协议进行重传。\n以太网技术  命名：[速率]BASE[速率或者介质] BASE: 基带以太网 T：双绞铜线  现代的交换机可以协调运输，在任何时刻都不会向相同接口转发超过一个帧，此外现代交换机都是双全工的，即一台交换机可以和一个节点同时向对方发送帧而不会产生干扰，因此基于交换机的以太局域网中，不会有碰撞，已经没有必要使用MAC协议了\n6.4.3 链路层交换机 交换机的任务是接收入链路层帧并把他们转发到出链路。\n交换机转发和过滤 过滤(filtering)：决定一个帧应该转发到某个接口还是应当将其丢弃\n转发(forwarding): 决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。\n交换机的过滤和转发借助于**交换机表(switch table)**完成，交换机表中的一个表项包括：一个MAC地址、通往该MAC地址的交换机接口、表项放置在表中的时间。\n假设目的地址为DD-DD-DD-DD-DD-DD的帧从接口x到达，\n 如果表中没有DD-DD-..的表项，交换机向除了接口x之外的所有接口前面的输出缓存转发该帧的副本，换而言之，如果没有对于目的地址的表项，交换机广播该帧。 如果有DD-DD-..的表项，且接口为x，则直接采用丢弃该帧执行过滤功能即可 如果有DD-DD-..的表项，且接口不是x，则交换机将该帧翻到对应接口前面的输出缓存完成转发功能  自学习 交换机是自学习的，交换机表初始为空，对于在每个接口接收到的每个入帧，该交换机在其表中存储该帧源地址对应的MAC地址以及到达的接口，并记录当前时间。如果在一段时间(老化期 )中，交换机没有接收到以该地址为源地址的帧，就在表中删除该地址。\n交换机是即插即用设备，因为他们不需要网络管理员和用户的干预\n链路层交换机的性质 消除碰撞：交换机缓存帧且绝不会再网段上同时传输超过一个帧，其最大聚合带宽是该交换机所有接口速率之和\n异质的链路：交换机将链路彼此隔离，使其能以不同速率在不同媒体上运行\n管理： 易于进行网络管理\n交换机与路由器的区别 交换机是第二层的，路由器是第三层的\n补充：网桥 功能: 读取A网(总线)的所有帧, 在B(总线)上重发每个帧; B-\u0026gt;A同理\n特点: 不更改帧, 原样转发; 带缓存; 路由寻址能力(基于MAC, 只转发需要转发的帧)\n协议体系层次: 数据链路层 - MAC层\n链接模式：\n 局域网 - 网桥 - 局域网, 原样转发 局域网 - 网桥 - [网络或链路] - 网桥 - 局域网, 需要适当封装, 但原始MAC帧不修改  固定路由选择：每对点均有一条选定的路由, 跳数最少, 仅在拓扑变化时改变(生成树算法)\n帧转发：x收到帧，检查目的地址: 若在某一端口的列表中, 且非阻塞, 发送; 不在任何列表, 则x除以外的端口全部转发\n地址探索: 同交换机，收到帧, 则帧源地址MAC与此端口关联, 加入此端口数据库，数据库项带计时器, 超时删除\n最小生成树算法(Prim): 选取起始点(根网桥), 加入集合S,对于S中所有点(网桥), 在他们所有邻居里面找离S中点最短的距离, 把这个邻居加入S, 这条边(网桥间的最短距离)加入生成树,直到所有点都加入S, 边集合构成生成树\n网桥阻塞规则:\n 选择根网桥: ID最小的网桥 为每个网桥选择root port: 到根网桥最低开销的端口 为每个LAN指定网桥: 拥有到根网桥最低开销路径的, 与这个LAN相连的网桥 Designated port: 这个指定网桥与这个LAN相连的端口 Designated port 和 root port 不阻塞, 别的都阻塞   to be add\n ","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/lian-lu-ceng-yu-ju-yu-wang/","tags":null,"title":"链路层与局域网"},{"categories":null,"contents":"事务管理、并发与故障处理  5.1 事务处理（概念）\n  事务的定义与ACID性质\n  事务活动及其状态转换图\n  事务控制及相关的参数设置语句：事务的提交与回滚，事务的读/写类型与隔离级别\n  事务的语句组成成分\n5.2 并发控制技术（概念）\n  事务\n 事务的并发性，并发控制 调度，串行调度，可串行化调度，冲突与冲突可串行化，视图可串行化 冲突可串行化的判定方法 不正确的事务并发所导致的数据不一致现象：丢失修改lost-update，脏读dirty-read，不可重复读unrepeatable-read    封锁\n 共享锁（S锁），排它锁（X锁），锁相容矩阵，锁申请/锁释放算法 基于封锁技术的并发控制实现方法  三级封锁协议，三级封锁协议与数据不一致现象之间的关系 两阶段封锁协议 两阶段封锁协议与冲突可串行化的关系      多粒度封锁\n 封锁粒度/并发度/并发控制实现开销 之间的关系 多粒度树，多粒度封锁 基于意向锁的多粒度封锁协议  意向锁：IS, IX, SIX 意向锁锁相容矩阵：S，X，IS, IX, SIX 意向锁锁申请算法，意向锁锁释放算法      死锁的检测与预防\n 死锁 \u0026amp; 活锁 死锁的检测及其处理办法   等待图法\n  超时死锁检测法：锁申请等待超时 \u0026amp; 事务执行超时\n  时间戳死锁检测法\n5.3 数据库恢复技术\n      数据库恢复的含义、方法和常用措施\n  数据库故障的分类\n  数据库故障恢复三大技术：数据转储，日志，数据库镜像\n  数据转储：静态转储/动态转储，海量转储/增量转储，\n  日志：\n 日志的内容、组成、作用与记载原则 在日志中设置检查点的作用 事务的撤销（UNDO）与重做（REDO） UNDO日志  UNDO日志的内容，记载规则，作用 基于UNDO日志的故障恢复流程   REDO日志  REDO日志的内容，记载规则，作用 基于REDO日志的故障恢复流程   UNDO/REDO日志  UNDO/REDO日志的内容，记载规则，作用 基于UNDO/REDO日志的故障恢复流程   UNDO日志、REDO日志、UNDO/REDO日志的优点与缺点    恢复策略：小型/中型/大型故障的恢复策略\n   事务处理 事务：访问并可能更新数据库上数据的一个程序执行单元(unit)\n在关系数据库系统中，一个事物是由一条SQL语句或者一组SQL语句所构成的一个执行过程，并具有ACID四个特性\n事务是恢复和并发控制的基本单位\n事务：某个用户执行的一个不能被打断的对数据库的操作序列\n四条ACID性质：\n 原子性Atomicity：一个事务中的操作要么全部执行结束，要么一个都不执行。数据库管理系统会通过事务管理子系统、事务日志自动维护原子性 一致性Consistency：一个事务的成功执行总是将数据库从一个一致的状态转移到另一个一致的状态，包括了数据库中显式定义的各种完整性约束与用户心目中的隐式数据约束，可以通过DBMS的数据完整性保护子系统和编写事务的应用程序员两方面进行保护 隔离性 Isolation：一个事务的执行与并发执行的其他事务独立，互不干扰，由并发控制子系统实现 持久性 Durability：一个事务完成操作后，对数据库的更新永久反映在数据库中，即使以后故障也能通过故障恢复保留结果，由DBMS的恢复管理子系统实现  事务活动的流程 活动状态：事务开始执行后，进入活动状态，事务将执行数据库的访问操作，对于读操作，将数据读入用户的私有工作区间，如果该数据当前不存在DBMS系统缓冲区，那么DBMS首先将该数据从磁盘读入系统缓冲区，再将其拷贝到用户事务的私有工作区。对于写操作，可能并不是立即将数据永久写入磁盘，可能会暂时存放在DBMS系统缓冲区。\n预提交状态：事务最后一个访问语句执行结束后，事务进入预提交状态，此时写操作的结果可能还在缓冲区内，要确保当前事务的所有修改操作都真正被写入数据库的磁盘中，当所有写磁盘操作执行结束后，进入提交状态，否则如果执行过程中发生故障导致执行失败猫就进入失败状态\n失败(abort)状态：事务执行完最后一条语句前中断或者预提交失败都会进入失败状态，原因可能是用户或应用程序主动放弃，因为并发控制被放弃(如封锁申请超时等待、死锁)或者发生系统故障\n异常中止(aborted)状态:对于失败状态事务，可能已经进行了一部分修改，为保证原子性，需要撤销已经进行的修改(回退rollback，由DBMS的恢复子系统实现)，进入异常中止状态，此时系统可以取消事务，也可以作为一个新的事务重新启动。\n提交状态：进入预提交后，并发控制子系统检查是否发生干扰，检查通过后执行提交操作，执行后进入提交状态\n有关事务的语句 主要有三条语句：\n 事务的开始(begin transaction): 事务的启动是隐式的，可以通过三种方式启动一个新的事务：数据定义命令DDL(每一条数据定义命令作为一个单独事务执行，在此之前当前用户事务自动提交)，将系统设置为自动提交方式即打开自动提交标志(每一条数据库访问指令都将作为一个单独的事务执行并根据执行结果自动提交或者回退)，数据操纵命令DML(前一个事务执行结束后，下一个数据访问操作执行之前，自动为用户启动一个新的事务)。 提交事务(commit transaction):提交可能因为系统故障或者数据完整性检查而导致失败，事务提交失败后可以通过回退来取消当前事务，系统自动提交的事务将会自动进行回退操作 回退事务(rollback transaction):取消事务执行过程中的所有操作，回滚至起点，在事务执行过程中，用户可以设置若干保存点(savepoint),用户事务可以使用rollback回滚到某一个保存点并继续执行当前事务，不带保存点的回退将结束并放弃整个事务  设置事务的自动提交： SET AUTOCOMMIT ON|OFF\n设置事务的类型（只读型事务与读/写型事务，缺省定义为读/写型事务）： SET TANSACTION READONLY | READWRITE\n设置事务的隔离级别：\nSET TRANSACTION ISOLATION LEVEL READUNCOMMITTED | READCOMMITTED | READREPEATABLE | SERIALIZABLE 设置了不同的隔离级别，系统所采取的封锁策略也不同\n 未提交读：不申请封锁，可能读到未提交结果，禁止以此方式执行写操作 提交读：读数据A前申请对A的共享性封锁，读结束后立即释放该封锁 可重复读：读数据A前申请对A的共享性封锁并将封锁维持到事务结束 可序列化(可串行化)：以一种可串行化的调度策略实现并并发执行，以避免干扰现象  但是不管设置了何种隔离级别，在写数据对象A的时候，会申请对A的排他性封锁并维持到事务结束\n事务的组成 数据对象：\n 数据对象的大小：可以是一个属性值/元组/表/整个数据库，我们不严格区分只是称为数据对象A 数据对象的地址空间：存在三种有关的地中空间概念(保存数据的磁盘空间、内润缓冲区、事务的局部地址空间即内存变量)  一个事务有关的操作分为两类：\n 事务控制操作（其中T0为事务标识符，每启动一个事务，DBMS自动分配一个唯一的事务标识符）  事务的开始：START T0 提交事务：COMMIT T0 回退(放弃事务)： ABORT T0   数据访问操作：  INPUT(A)：将数据A从磁盘读入内存缓冲区 OUTPUT(A)：将数据A从内存缓冲区写入磁盘 READ(A,t)：将内存缓冲区的数据对象A的值读入内存变量t(可能包含INPUT操作) WRITE(A,t) ：将内存变量的值写入对象A    并发控制技术 事务的并发执行 并发控制技术：实现多个用户事务的并发执行\n并发执行的可串行化: 一组事务并发执行的结果等价于他们之间的某种串行执行的结果，称为可串行化调度\n并发控制的目标就是要实现并发事务的可串行化调度\n各个事务的数据库访问操作在DBMS中的实际执行序列构成了事务之间的一个调度，一组事务的调度必须包括所有操作包括一个事务的结束命令，且保证单个事务内部执行顺序不变\n值得注意的是，不同事务的访问请求在DBMS内部的执行顺序可能与到达顺序不一样，但是同一个事务内部的操作顺序一定与到达顺序一致\n串行调度：首先是一个事务的所有操作，然后是另一个事务的所有操作，依次类推，称调度是串行的\n我们用符号 $T_1,T_2..$ 标识事务，用$r_i(X)$标识事务$T_i$读数据库对象X，类似的有$w_i(x)$\n冲突：调度中的一对相邻操作(op1,op2)如果交换他们的顺序，那么涉及的事务中至少有一个的行为会改变，那么称这对相邻操作为冲突\n冲突包括：同一个事务的任意两个相邻操作，对于不同事务的两个相邻操作中涉及同一对象且至少有一个为写操作\n如果对于初始给定的一个调度，可以通过一组非冲突化操作变成一个串行调度，那么认为最初的调度是一个可串行化调度且称为冲突可串行化调度\n注意：冲突可串行化调度一定是一个可串行化调度，但是可串行化调度不一定是一个冲突可串行化的\n如果两个事务$T_1,T_2$分别存在动作$A_1,A_2$,在调度H中，$A_1$在$A_2$之前执行，如果两个动作涉及同一个数据对象并且至少有一个为写动作，那么称$T_1$优先于$T_2$,记为$T_1 \u0026lt;_S T_2$,上述情况下，A1与A2不能交换，在H的冲突等价串行调度中，T1必在T2之前\n判断是否冲突可串行化：如果$T_i \u0026lt;_S T_j$,那么从i到j引一条有向边，如此寻找所有冲突对(可以根据所有被访问的数据对象来发现冲突对)构造优先图，如果事务优先图中无环，则为冲突可串行化调度，否则不是。\n利用优先图，如果一个点不存在指向该节点的有向边，就先执行这个节点对应的事务，再考虑其他节点的优先图。\n三种可串行化调度：视图可串行化是可串行化调度的子集，冲突可串行化是视图可串行化的子集\n视图可串行化调度指的是视图等价为一个串行调度，S与H视图等价当且仅当满足以下三个条件：对每一个数据项D\n 如果在调度S中事务Tk读到D的初始值，则在调度H中事务Tk也必须读到D的初始值； 如果在调度S中事务Tk执行了$r_k(D)$，并且读到的是由事务Tj写入的D的值，则在调度H中事务Tk的$r_k(D)$读到的也必须是由事务Tj 所写入的D的值； 如果在调度S中是由事务Tk来执行最后一条关于D的写操作$w_k(D)$，则在调度H中也一定是事务Tk执行最后一条关于D的写操作$w_k(D)$。  视图可串行化调度不一定是冲突可串行化调度的原因在于：可能存在盲写现象(一个事务没有读取数据项D的值并直接用write操作修改D的值)\n数据不一致现象：\n 丢失修改(lost-update)：一个事务的修改破坏了另一个事务的修改结果，原因在于对多个并发修改同一个值没有限制 脏读（dirty-read）：一个事务读到了另一个事务未提交的结果 不可重复读(unrepeatable-read):在两次读操作之间差入了另一个事务的写操作  封锁 封锁一段事件内禁止其他事务执行某些操作同时也表明持有该封锁的事务在被封锁的数据对象上执行什么样的操作\n排他锁：X锁：只有在数据A上没有任何封锁的时候能申请，如果一个事务申请了X锁，那么其他事务都不能获得A上的任何类型的封锁，获得X锁后可以进行读、写操作，其他事务禁止访问，降低了并行性，但是保证了正确性与一致性，X锁必须维持到事务结束\n共享锁：S锁： 如果数据A没有被封锁或者是以S锁的形式封锁时，可以申请S锁，事务T可以读，但是不可以写，S锁不一定要维持到事务结束\n合适事务：一个事务访问前按照要求申请封锁，操作结束后释放封锁，这种事务称为合适事务\n合适事务时保证并发事件正确执行的基本条件\n封锁管理器的数据结构：数组LOCK(A)记录数据对象A上的封锁状态，分别是Read_locked(共享锁)、Write_locked(排他锁)、Unlocked(无封锁)，数组no_of_reads(A)记录A上的共享锁的个数。\n基于封锁技术的并发控制实现方法：\n 在DBMS的封锁管理器上维护一张锁表，包括了封锁的持有情况(哪些事务在哪些数据对象上持有什么锁)与封锁的申请等待情况(有哪些事务正在等待哪些数据对象上的什么类型的封锁) DBMS对于请求op(A)，将访问操作发送给并发控制子系统的调度器。调度器根据系统的封锁协议来决定是否需要为该操作申请封锁以及申请何种类型的封锁，并将封锁请求发送给封锁管理器，封锁管理器根据锁表的情况决定能够立即满足，并将结果返回给调度器，如果得不到满足，则调度器将访问操作放入被推迟的访问操作序列，否则将该操作发送给系统的执行引擎去执行。  封锁协议 封锁协议规定了何时申请封锁，申请何种类型封锁，何时释放封锁\n最常见的有三级封锁协议与两阶段封锁协议\n三级封锁协议：以单条数据访问操作为单位，定义了锁的申请和释放要求，根据具体要求不同，可以将其分为一级封锁协议、二级封锁协议、三级封锁协议三种级别不同的封锁协议\n 一级封锁协议(可以预防丢失修改)：写对象A之前必须先申请A上的X锁并维持到事务T的结束才释放 二级封锁协议(可以预防丢失修改、脏读)：满足一级封锁，在读对象A之前必须先申请A上的S锁并在操作完成后即可以释放S锁(此处未规定释放时间) 三级封锁协议(可以预防丢失修改、脏读、不可重复读)：满足一级封锁，事务在读对象A之前，必须先获得A上的S锁，并保持到事务结束后才释放  两阶段封锁协议(2PL协议)：以事务为单位规定封锁的使用规则\n 第一阶段:申请并获得锁，在此阶段可以申请整个执行过程中需要的锁，但是不能释放，锁的数量不断上升，可以称为扩展阶段 第二阶段：释放所有的锁，包括释放被挂起的锁申请请求，称为收缩阶段  在两阶段封锁协议中，如果$T_i$已经持有A上的S锁，当处理$xl_i(A)$请求时，会直接将S锁改为X锁\n2PL事务产生的任意合法调度都是冲突可串行化的\n封锁粒度 封锁粒度：一把锁可以封锁的数据对象的大小，可以时数据库中的逻辑数据单元(属性值、元组、关系、索引、整个数据库)，也可以是物理数据单元(页、块)\n封锁粒度大，则系统并发性低，并发控制开销小。封锁粒度小，则并发性高，对应的并发控制开销大\n如果在一个系统中同时支持多种封锁粒度供事务选择使用，这种方法称为多粒度封锁\n可以根据封锁粒度的大小构造一棵多粒度树，以每个节点作为封锁对象，构成一个多粒度封锁协议(显式封锁是可以对每个节点独立加锁，隐式封锁是该节点的所有后裔也被加以同类型的锁)\n意向锁：如果对一个节点加意向锁，说明该节点的下层节点正在被加锁，对任一节点加锁前必须先对他的上层节点加意向锁\n常见的意向锁：\n 意向共享锁(IS锁)：后裔准备加S锁 意向排他锁(IX锁)：后裔准备加X锁 共享意向排他锁(SIX锁)：后裔准备加X锁且自身加S锁  相容表 |准备申请的\\目前有的|S|X|IS|IX|SIX| |:--|--|--|--|--|--| |S|YES|NO|YES|NO|NO| |X|NO|NO|NO|NO|NO| |IS|YES|NO|YES|YES|YES| |IX|NO|NO|YES|YES|NO| |SIX|NO|NO|YES|NO|NO|\n申请封锁的顺序：从上至下\n释放封锁的顺序：由底而上\n死锁与活锁 死锁：每个事务拥有一部分锁，同时申请其他事务的锁而等待，由此形成的循环\n处理办法：\n 预防法：顺序申请法；一次申请法 解除法：  超时死锁检测法：事务执行时间超时；锁申请等待时间超时 等待图法 时间戳死锁检测法：每个事务有一个用于死锁检测的时间戳，时间戳反映事务的新老程度，如果事务T必须等待另一个事务U持有的锁，有两种策略：  等待-死亡方案：如果T比U老，那么允许T等待U持有的锁；如果U比T老，那么事务T死亡(被回滚)； 伤害-等待方案：如果T比U老，他将伤害U，U必须被回滚；如果U比T老，那么T等待U持有的锁      活锁：有部分事务因为封锁得不到满足长期处于等待状态，而其他事务仍可以继续进行；解决方式：先来先解决\n数据库恢复技术 数据库恢复：在暑假库遭受破坏后及时进行恢复的功能\n方法：利用数据冗余原理，将数据库中的数据在不同存储介质上进行冗余存储，在本身遭到破坏时利用冗余信息进行恢复\n常用措施:数据转储、日志、数据库镜像\n故障分类 小型故障：事务内部故障\n中型故障：系统故障；外部影响(可能导致整个系统停止工作，但是磁盘数据不受影响，系统重启时可以根据日志进行恢复)\n大型故障：磁盘故障；计算机病毒；黑客入侵；(可能导致内存及磁盘数据的严重破坏，需要对数据库做彻底的恢复)\n转储 数据转储：定期的将数据库中的内容复制到其他存储设备中去的过程\n转储可分为：静态转储/动态转储；海量转储/增量转储\n转储过程得到的后备副本并不能保证数据库中数据的一致性，如果使用该副本进行故障恢复，需要解和当时记载的日志信息，日志中应该记载：\n 转储的开始点与结束点 转储执行过程中，事务的更新情况：\u0026amp;lt;事务标识,更新对象，更新前的值，更新后的值\u0026gt; 转储执行过程中完成的事务的结束状态：Commit/Abort  日志 数据库系统创建并维护的，用于自动记载数据库中修改型操作的数据更新情况的文件\n内容包括了每个更新操作的事务标识、更新对象、更新前的值 和/或 更新后的值；每个事务的开始、结束等情况；其他信息\n日志是日志记录的一个序列，每个日志记录记载有关某个事物已执行操作的情况\n作用：\n 保证事务执行的原子性 实现增量转储 实现故障恢复  为了修复故障产生的影响，某些事务操作将会被重做，而另一些事务的操作将会被撤销 为了区分哪些事务重做，哪些事务撤销，日志中需要记载每个事务的结束标志：commit：将被重执，abort将被撤销 日志中没有结束标志的事务在恢复时被当作被放弃的事务    先写日志，再修改数据库\nundo日志 undo日志：用于被放弃事务的撤销工作\n记录格式：\n 开始一个事务：\u0026lt;START T\u0026gt; 提交事务：\u0026lt;COMMIT T\u0026gt; 放弃事务: \u0026lt;ABORT T\u0026gt; 更新记录: \u0026lt;T,X,V\u0026gt;(事务T修改X,X的旧值是V)  记载规则：如果事务T修改了数据库元素X，则更新日志必须在新值写入磁盘前写到磁盘，如果事务T提交，则日志记录必须在事务T改变的所有元素已经写到磁盘后再写到磁盘\n恢复过程：\n 将事务区分为已提交事务与未提交事务(有无Commit) 从日志尾向日志头部扫描，对每一条更新记录，如果已经扫描到\\则继续扫描下一条，否则恢复为V 在日志尾部未每一个未结束的事务T写入一条日志记录\u0026lt;ABORT T\u0026gt;并刷新日志(Flush Log)  检查点：为了降低数据库恢复的开销，定期在日志文件中加入检查点\n加入检查点的处理过程：\n 系统停止接受‘启动新事务的请求’ 等到所有当前活跃的事务被提交或中止，并且在日志中写入了\\或\\记录 将日志记录刷新到磁盘 写入日志记录\\，并再次刷新日志 重新开始接受新的事务  在故障恢复时，只要逆向扫描到第一条\\记录(最后一个被记入的检查点)就可以结束故障恢复工作\n非静止检查点：设置过程中，允许新的事务进入\n 写入日志记录\\，并刷新日志；其中：T1,…,Tk是当前所有活跃事务的标识符 等待T1,…,Tk中的每一个事务的提交或中止，在这个过程中允许启动执行新的事务 当T1,…,Tk都已经完成时，写入日志记录\\并刷新日志  恢复时从日志尾部向前扫描，可能遇到两种情况\n 先遇到\\记录：继续向后扫描，直到出现与之相对应的\\记录就可以结束故障恢复工作，在这之前的日志记录是没有用处的，可以被抛弃 先遇到\\记录，此种情况下的故障恢复工作需要撤消两类事务的操作：在\\记录之后启动的事务(在扫描到\\记录时，这类事务的操作已经被撤消);T1,…,Tk中在系统崩溃前尚未完成的事务(继续向后扫描日志，直至其中未完成事务的访问操作被全部撤消)  undo日志不足：事务改变的所有数据写到磁盘前不能提交事务，导致增加了很多写磁盘操作，增加了事务提交的时间开销\nredo日志 格式与undo差不多，唯一的差别在于更新记录中V记载的时更新后的值\n记载规则：在修改磁盘上的任何数据库元素X之前，要保证所有与X的这一修改有关的日志记录（包括更新记录\\ 和提交记录 \\）都必须出现在磁盘上。(这也就意味着从缓冲区写到磁盘上的数据在commit日志已经被写到了磁盘上之后)\n恢复：\n 确定所有已提交的事务（先扫描一遍日志文件） 从日志文件的头部开始扫描日志，对遇到的每一条更新记录\\：如果T是未提交事务，则继续扫描日志如果T是已提交的事务，则为数据库元素X写入新值V 对每个未完成的事务T，在日志的尾部写入结束标志\\并刷新日志  在redo日志中插入(非静止)检查点的步骤：\n 写入日志记录\\，并刷新日志；其中：T1,…,Tk是当前所有活跃事务的标识符，同时获得当时所有已提交事务的标识符集合S 将集合S中的事务已经写到内存缓冲区但还没有写到数据库磁盘的数据库元素写入磁盘； 写入日志记录\\并刷新日志，不必等待事务T1,…,Tk或新开始事务的结束  恢复：找到最后一个被记入日志的\\(记为记录t)，假设与之相对应的检查点记录是\\(记为记录t’)，并找到最早出现的\\(记为记录ti).故障恢复方法如下：针对事务T1,…,Tk以及在t’之后开始的那些事务，重做其中已经被提交的事务\n不足：增加了平均缓冲区的数量\nundo/redo日志 与之前基本一致，不过更新记录变为了\\，其中v为之前值，w为修改后值\n记载规则：由于某个事务T所作的改变而修改磁盘上的元素X之前，关于X的更新记录(\\)必须先出现在磁盘上。每一条Commit日志记录后面必须紧跟一条Flush Log操作\n此时，commit操作和写磁盘(output)操作顺序是随机的\n恢复： 根据\\是否已经出现在磁盘中来决定事务T是否已经被提交。按照从后往前的顺序，撤消(undo)所有未提交的事务，按照从前往后的顺序，重做(redo)所有已提交的事务\n插入检查点：写入日志记录\\，并刷新日志。其中：T1,…,Tk是当前所有活跃事务的标识符,将所有被修改过的缓冲区写到数据库的磁盘中去,写入日志记录\\并刷新日志\n恢复策略 小型故障：利用未结束事务的undo操作\n中型故障：\n 非正常中止：undo 已完成提交，结果还在缓冲区中：redo  大型故障：先利用后备副本进行恢复，在利用日志进行数据库恢复(逆向搜未完成undo，正向搜完成redo)\n数据库镜像 将整个数据库中数据或者主要数据实时复制到另一个磁盘中\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/transaction/","tags":null,"title":"事务管理、并发控制与故障恢复"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 6\n TD：时序差分方法，是一种综合了蒙特卡洛与DP的特点的方法\n6.1 TD Prediction 对于$\\alpha$-蒙特卡洛来说，其更新规则如下：\n$$V(S_t) \\leftarrow V(S_t)+\\alpha[G_t - V(S_t)]$$\n其对于每一个$S_t$所对应的value都需要等待对应的episode结束后才能够更新，而对于一种TD算法（以下为TD(0)或者叫one-step TD），可以如下的更新方式:\n$$V(S_t) \\leftarrow V(S_t)+\\alpha[R_{t+1} + \\gamma V(S_{t+1})- V(S_t)]$$\n这就是把其中的$G_t$替换成立下一个时间点就能得到的reward信息来对其进行更新，这个事实上就是bootstrap（本意为自举，在此处即用后继的值函数来估计当前值函数），而这就是DP的思想 下给出TD(0)的伪代码：\n6.2 Advantages of TD Prediction Methods 6.3 Optimality of TD(0) 6.4 Sarsa: On-policy TD Control 6.5 Q-learning: Off-policy TD Control 6.6 Expected Sarsa 6.7 Maximization Bias and Double Learning 6.8 Games, Afterstates, and Other Special Cases ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl6/","tags":null,"title":"Temporal-Difference Learning"},{"categories":null,"contents":" 放大电路模型，基本定义，符号，几种争议的定义，主要的性能指标，频率响应的定义，认识图和图上的点，知道失真与非线性失真的概念（看到图知道什么回事）\n 放大电路模型 信号的基本概念 信号：信息的载体-温度、压力、速度、声音、亮度。。\n电信号：用电量描述信息的变化\n电信号源的电路表达形式：电压源等效电路、电流源等效电路\n模拟信号：在时间和幅值上都是连续的信号\n数字信号：在时间和幅值上都是离散的信号\n按照时间和幅值的连续性和离散性分类：\n 时间连续、数值连续：模拟信号 时间离散、数值连续：AD转换信号 时间连续、数值离散：DA转换信号 时间离散、数值离散：数字信号  放大电路 放大电路是模拟电路中最基本的单元电路\n一般的放大电路基本如下：\n处于简便考虑，通常会将放大电路的工作电源给隐去，如右图所示\n放大电路是一个双口网络，可以利用端口特性来研究放大电路\n输入端口等价为一个电阻，输出端口根据不同情况等效为不同的电路形式\n放大电路模型  电压放大模型  $R_i$：输入电阻 $R_o$: 输出电阻 $A_{vo}$: 负载开路时的电压增益 由$v_o=A_{vo}v_i\\frac{R_L}{R_O+R_L}$可知，电压增益为$A_v=\\frac{v_o}{v_i}=A_{vo}\\frac{R_L}{R_O+R_L}$ 可知：负载大小会影响增益大小，故而要$R_o\u0026lt;\u0026lt;R_L$,理想情况输出电阻为0 输入回路对信号源的衰减，故而$R_i\u0026gt;\u0026gt;R_S$,理想情况取无穷大   电流放大模型  同上分析可知电流增益为$A_i=A_{is}\\frac{R_O}{R_O+R_L}$ 要减少负载的影响，故而要$R_O\u0026gt;\u0026gt;R_L$,理想情况下取无穷 要减小信号源的衰减，故而$R_i\u0026lt;\u0026lt;R_s$,理想情况为0   互阻放大模型 互导放大模型 隔离放大电路模型  放大电路主要性能指标 输入电阻 $R_i=\\frac{v_i}{i_i}$\n输入电阻决定了放大电路从信号源吸收信号幅值的大小\n电压放大和互导放大的输入信号为电压，要求输入电阻大\n电流放大和互阻放大的输入信号为电流，要求输入电阻小\n输出电阻 输出电阻决定了放大电路带负载的能力\n电压放大和互阻放大的输出信号为电压，要求输出电阻小\n电流放大和互导放大的输出信号为电流，要求输出电阻大\n注意：输入、输出电阻为交流等效电阻\n增益 反映了放大电路在输入信号控制下，将供电电源能量转换为输出信号能量的能力\n其中，$A_v$和$A_i$常用分贝（dB）表示\n 电压增益 $= 20\\lg|A_v|$ 电流增益 $= 20\\lg |A_i|$ 功率增益 $= 10lg A_p$  频率响应及带宽 输入正弦信号情况下，输出随输入信号频率连续变化的稳态响应，称为放大电路的频率响应\n$A_V(\\omega)=|\\frac{\\dot{V}_O(j\\omega)}{\\dot{V}_i(j\\omega)}|$： 幅频响应，反映电压增益的模和角频率之间的关系\n$\\angle \\varphi(\\omega) = \\varphi_o(\\omega) - \\varphi_i (\\omega)$：相频响应，反映输入正弦信号的相位差与角频率之间的关系\n带宽BW=$f_H$(上限频率) - $f_L$(下限频率)\n输出功率约等于中频区的一般的点称为半功率点\n失真：\n 频率失真(线性失真)  幅度失真：对不同频率的信号增益不同 相位失真：对不同频率信号的相移不同   非线性失真：由原件非线性特性引起的失真，在频谱图上表现为由新的频率分量产生  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/","tags":null,"title":"放大电路模型"},{"categories":null,"contents":"Mantel's Theorem: Suppose G(V,E) is a graph on n vertices without triangles, then $|E|\\leq \\frac{n^2}{4}$\nTuran's Theorem: Let $G(V,E)$ be a graph with $|V| = n$. If G has no r-clique, $r \\geqslant 2$, then $|E| \\leqslant \\dfrac{r-2}{2(r-1)} n^2$\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/extremal-graph-theroy/","tags":null,"title":"Extremal Graph Theroy"},{"categories":null,"contents":"无线网络与移动网络 7.1 概述 无线主机(wireless host): 类似于有线主机，运行应用程序的端设备。\n无线链路： 主机通过无线通信链路来连接到一个基站。\n基站(base station): 负责向与之关联的无线主机发送数据和从主机那里获得数据(例如分组)。基站通常负责协调与之相关联的多个无线主机的传输。\n与基站相关联的主机通常称为以基础设施模式运行，在自组织网络中，无线主机没有这样的基础设施与之相连，在这种情况下，主机本身必须提供包括路由选择、地址分配等服务。\n当一台移动主机的移动超出一个基站的覆盖范围并到达另一个基站的覆盖范围之后，它将改变其接入到更大网络的连接点。这一过程称为切换(handoff)\n...\n7.2 无线链路和网络特征 ...\n7.3 WIFI: 802.11无线LAN IEEE 802.11无线LAN：WIFI\n7.3.1 802.11体系结构 主要工作频段是2.4GHz和5GHz\n802.11体系结构的基本构件是基本服务集(Basic Service Set,BSS), 一个BSS包括一个或者多个的无线站点和一个**接入点(Access Point,AP)**即中央基站\n与以太网设备类似，每个802.11无线站点都有一个6字节的MAC地址，这个地址存储在该站适配器的固件中。\n配置AP的无线LAN通常被称为时基础设施无线LAN，其中的基础设施指的是AP连同互联AP和一台路由器的有线以太网。\n信道与关联 网络管理员安装一个AP时，管理员为该接入点分配一个单字或者双字的服务集标识符(SSID),还必须分配一个单信号\nWIFI丛林：一个任意物理位置，能够从多个AP中收到很强的信号\n为了获得因特网接入，你的无线站点需要加入其中一个子网并因此需要和其中一个AP相关联。关联意味着这一无线站点在自身和该AP间建立一个虚拟线路\n802.11标准要求每个AP周期性的发送信号帧，该信号帧包括了AP的SSID和MAC地址。\n无线站点扫描11个信道，找到其中可能位于该区域的AP发出的信号帧\n 主动扫描  无线站点广播探测请求帧 自AP发送探测响应 无线站点选择AP发送关联请求帧 选择的AP相无线站点发送关联的响应帧   被动扫描  自AP发送信标帧 无线站点选择AP发送关联请求帧 AP相无线整点发送关联响应帧    7.3.2 802.11 MAC 协议 采用CSMA/CA协议：带碰撞避免的载波侦听多路访问\n并没有实现碰撞检测，这也就意味着一旦站点开始发送一个帧，他就完全的发送该帧\n不使用碰撞检测的原因：\n 检测碰撞的能力要求站点有同时发送和接收的能力，而在802.11适配器上，接收信号强度远小于发送信号强度，制造相关设备的硬件代价较大 适配器由于隐藏终端问题和衰减问题无法检测到所有的碰撞  802.11的链路层确认方案：目的站点收到一个通过了CRC检验的帧之后等待一个称做短帧间间隔的一小段时间，然后发挥一个确认帧。如果发送站点在给定时间内未收到确认帧，就假定出现了错误并重传该帧，使用CSMA/CA访问该信道。如果在若干固定次重传后仍未收到确认则放弃传送并丢弃该帧。\nCSMA/CA协议过程：\n 某站点监听到信道空闲，他将在一个**分布式帧间间隔（DIFS）**的短时间段后发送该帧 否则，选取一个随机回退值，并且在侦听信道空闲时递减该值。当侦听信道忙时，计数值保持不变 计数值减为0后(这只可能发生在信道空闲时)，发送整个数据帧 收到确认后，发送站点知道他的数据帧已经被接收，则发送第二帧，否则回到第二步，在更大的范围内选取回退值  处理隐藏终端：RTS与CTS 由于信号问题，两个无线站点对AP不隐藏但是对彼此隐藏。这可能导致一个无线站点正在传输一个帧时，另一个站点未听到正在传输，于是发起传输导致了碰撞\n处理方法：站点发送一个短请求发送(RTS)控制帧和一个短允许发送(CTS)控制帧来预约对信道的访问。当发送方需要发送数据时，先向AP发送一个RTS帧，指示传输DATA帧和确认帧需要的总时间，AP收到预约后广播一个CTS帧。既是为了给发送方明确的发送许可，也是为了指示其他站点预约期间不要发送\n实际上设置了RTS门限值，只有帧长超过了门限值才会预约\n7.3.3 IEEE 802.11帧 |帧控制|持续期|地址|地址2|地址3|序号控制|地址4|有效载荷|CRC| 有效载荷通常是一个IP数据报或者ARP分组组成。通常小于1500字节\nAP是链路层设备，他会对802.11帧和以太网帧进行转化\n 地址1：接收该帧的无线站点的MAC地址 地址2：发送该帧的MAC地址 地址3：路由器接口的MAC地址  序号：使接收方区分新传输的帧和以前的帧的重传\n持续期：预约信道一段时间的长度\n控制字段：包括很多子字段，如类型等\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wu-xian-wang-luo-yu-yi-dong-wang-luo/","tags":null,"title":"无线网络与移动网络"},{"categories":null,"contents":"游标管理与索引  游标管理\n 游标的作用 游标的定义、打开、使用、关闭 可滚动游标的定义及其在数据更新命令中的使用  索引 (index)\n B+索引的数据结构，搜索算法   游标管理 游标的定义(declare a cursor):为某一映像语句（可能返回多个结果元组）的结果集合定义一个命名的游标\nEXEC SQL DECLARE cursor-name CURSOR FOR subquery [ ORDER BY ...... ] [ FOR { READ ONLY | UPDATE [ OF columnname, ...... ] } ] ; 游标的打开(open the cursor):执行相应的映像语句并打开获得的结果集，此时游标处于活动状态并指向结果集合的第一条记录的前面\nEXEC SQL OPEN cursor-name ; 游标的使用(fetch a row by the cursor):将游标推向结果集合中的下一条记录，读出游标所指向记录的值并赋给对应的主语言变量，举例如下：\n/*其中agent_dollors是游标名，前带：的是表示主语言定义的变量*/ exec sql fetch agent_dollars into :agent_id, :dollar_sum; 每一个fetch的下一个是随机的（如果没有order by的话），所以每一个被打开过的游标只能遍历一次(但是可以打开多次)\n游标的关闭(close the cursor):关闭所使用的游标，释放相关的系统资源\nEXEC SQL CLOSE cursor-name ; 游标一旦被定义(declare)，可以被重复使用(open-fetch-close)。每一次open一个游标，都将重新执行对应的query，并生成新的结果集。\n应用程序可以通过‘游标状态变量’来了解一个游标的当前状态(是否处于打开状态、结果元组的个数、是否fetch到结果元组...\n可滚动游标的定义:\nEXEC SQL DECLARE cursor_name [ INSENSITIVE ] [ SCROLL ] CURSOR [ WITH HOLD ] FOR subquery { UNION subquery } [ ORDER BY ...... ] [ FOR READ ONLY | FOR UPDATE OF columnname ...... ]; 可滚动游标的更新：\nEXEC SQL FETCH [ { NEXT | PRIOR | FIRST | LAST | { ABSOLUTE | RELATIVE } value_spec } FROM ] cursor_name INTO ......; 索引 顺序文件：按照某个属性的取值进行排序的而构成的数据文件\n索引文件：为了加快数据文件的检索速度，根据用于定义查询条件的属性（索引关键字）来建立索引文件。由一个索引关键字值k_val和一个元组指针t_ptr所构成的二元组称为索引项\n为数据文件中的每个元组都生成一个索引项，由与某个数据文件相关的所有索引项而组成的文件被称为索引文件\n索引的查找：在索引文件中按照特征字段的值进行查找，找到具有该特征的记录的记录指针，从而可以在数据文件中直接定位读出需要的记录\n顺序文件上的索引 如果索引属性的值唯一，采取前三种，否则采取最后一种\n稠密索引 稀疏索引 多级索引 具有重复键值的索引 B/B+树上索引文件 树的最下一级索引是叶节点\nB+树的特点：\n 平衡性：根节点到每个叶节点的路径等长 过半性：除根节点之外每个节点所对应的磁盘空间至少被占用一半 顺序性：既可以从根节点开始随机查找关键字，也可以根据索引关键字的值进行排序进行顺序访问 自适应性：自动保持与数据文件大小相适应的索引层次  B+树的节点：每个节点占用一个磁盘块，每棵B+树有一个称为秩的整形参数n，每个结点可以容纳n个键和n+1个指针。\n结点的内容：$P_1,K_1,P_2,K_2,..,P_m,K_m,P_{m+1}$,其中K为关键字值，且关键字按照从小到大的顺序进行排列\n 根节点：$P_1$到$P_{m+1}$分别指向另一棵子树根节点 叶节点：前m个指针指向数据，最后一个指针指向右边的下一个叶子节点 非叶节点：对于夹在关键字$K_i$与$K_{i+1}$之间的那个指针，其指向的子树的键值都满足$K_i\u0026lt;K\u0026lt;K_{i+1}$  B+树上的随机查找：输入关键字K，根据节点的性质进行比较找到叶节点，判断叶节点中是否有关键字\nB+树上的范围查找：输入范围[a,b],先按照上述算法找到a对应的叶子节点，然后对叶子节点中的每个值与b进行对比直到大于b为止，这个叶节点中都小于b那么利用指向下一个叶节点的指针在下一个叶结点中重复上述判断\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/data-exchange/","tags":null,"title":"游标管理与索引"},{"categories":null,"contents":" 对应章节：《Reinforcement Learning: An Introduction》第二版 Chap 7\n ","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/rl7/","tags":null,"title":"n-step Bootstraping"},{"categories":null,"contents":" 运算放大器:组成单元，参数特点，什么是理想运放与其模型，反馈的概念（不要求分析，即不要求判断正反），深度负反馈是什么回事 重要：虚断等 求差求和等电路的基本形式与特征，输入输出电阻啊等\n 运算放大器 集成电路运算放大器 功能：\n 信号放大 信号运算 信号处理（滤波、调制） 波形的产生和变换  分类\n 通用运放和专用运放 单运放、双运放、四运放  内部组成单元 不讨论集成运放的内部电路，仅从其电路模型和外特性出发，讨论运放构成的放大电路和典型的线性应用电路\n$v_p$称为同相输入端，因为当$v_n=0$时$v_o$和$v_P$同相，而$v_n$被称为反相输入端，因为$v_o$在$v_P$为0时的信号与$v_n$反相\n符号：\n电路模型 放大：在输入信号控制下，放大电路将供电电源能量转换为输出信号能量\n通常开环电压增益很高，输入电阻很大，输出电阻很小。\n$v_O=A_{vo}(v_p-v_N)$ $(V_-\u0026lt;v_O\u0026lt;V_+)$\n当$v_O$超过端值之后取端值，如下：\n理想运算放大器 理想运算放大器的特点：\n 开环差模电压增益无穷大 差模输入电阻无穷大 输出电阻为0  其$V_P-V_N\u0026gt;0$时取$V_+$,小于0时取$V_-$\n基本线性运算放大电路 同相放大电路  反馈：系统的输出返回到输入端并以某种方式改变输入，进而影响系统功能的过程，即将输出量通过某种恰当的检测装置返回到输入端并与输入量进行比较的过程 反馈通路：信号反向传输的渠道 反馈形式：  正反馈：输入量不变，引入反馈后，输出量变大(也可以认为输出不变净输出量减小) 负反馈：输入量不变，引入反馈后，输出量变小（也可以认为输出不变，净输出增大） 判断方法：瞬时极性法    同相放大电路的负反馈：$v_p(v_i)$上升导致，$v_o$上升，导致$v_n$上升，进而导致$v_{id}$下降从而导致$v_o$下降\n利用输出电压通过反馈元件对放大电路起自动调整作用\n如上，其中$A_v$的分母$(1+𝐴_{vo}F_v)$被称为反馈深度，当其远大于1也就是$1+A_{vo}F_v \\approx A_{vo}F_v$时，被称为**深度负反馈**\n运放的两个重要概念：\n 虚短：在深度负反馈作用下，$v_N$自动跟踪$v_P$,净输入电压$(v_P-v_N)\\to 0$,即P端和N端相当于短路 虚断：由于虚短的存在，而输入电阻又很高，即流经两输入端之间的电流$i_P=i_n \\approx 0$ 虚短是本质的，虚断是派生的  在同向放大电路中，加到两输入端的电压接近相等，相位相同是它在闭环状态下工作的重要特征\n几项技术指标的近似计算：\n 电压增益 $A_v=1 + \\frac{R_2}{R_1}$  根据虚短和虚断的概念，$v_p\\approx v_n$,$i_p=i_n=0$,故而$v_i=v_p\\approx v_n = v_f =\\frac{R1}{R1+R2}v_o$   输入电阻$R_i = v_i/i_i \\to \\infty$ 输出电阻 $R_o = r_o||[(R_1||r_i)+R_2] \\to 0$  电压跟随器：\n 令$R_1=\\infty, R_2=0$，电压增益为1，可以用于阻抗变换器和缓冲器  反相放大电路 根据虚短和虚断的概念，有$v_n=v_p=0$,因此反相输入端电位接近地电位， 称为虚地\n$𝐴_𝑣 = 𝑣_𝑜/𝑣_𝑖 = −𝑅_2/𝑅_1$（负号表示和输入反向）\n输入电阻：$𝑅_𝑖=𝑣_𝑖/𝑖_𝑖 =𝑣_𝑖/(𝑣_𝑖/𝑅_1)=𝑅_1$\n输出电阻：$𝑅_𝑜=𝑟_𝑜||𝑅_2→0$\n如果信号源是非理想的电压信号源，应当采用同向放大电路，因为输入电阻更大(避免非理想信号源分压过大)\n同向输入和反向输入放大电路的其他应用 求差电路 又称为是差分放大电路，是反相输入和同相输入相结合的放大电路\n求和电路 ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","tags":null,"title":"运算放大器"},{"categories":null,"contents":"Extremal Set Theroy Sunflowers Definition (sunflower): A set family $ {\\mathcal {F}}\\subseteq 2^{X}$ is a sunflower of size $ r$ with a core $ C\\subseteq X$ if $ \\forall S,T\\in {\\mathcal {F}}$ that $ S\\neq T$, $ S\\cap T=C$.\nSunflower Lemma (Erdős-Rado) Let $ {\\mathcal {F}}\\subseteq {X \\choose k}$. If $ |{\\mathcal {F}}|\u0026gt;k!(r-1)^{k}$, then $ {\\mathcal {F}}$ contains a sunflower of size $ r$.\nErdős–Ko–Rado theorem Erdős–Ko–Rado theorem (proved in 1938, published in 1961): Let $ {\\mathcal {F}}\\subseteq {X \\choose k}$ where $ |X|=n$ and $ n\\geq 2k$. If $ {\\mathcal {F}}$ is intersecting, then $ |{\\mathcal {F}}|\\leq {n-1 \\choose k-1}$.\nSperner Theorem A set family $ {\\mathcal {F}}\\subseteq 2^{X}$ with the relation $ \\subseteq $ define a poset. Thus, a chain is a sequence $ S_{1}\\subseteq S_{2}\\subseteq \\cdots \\subseteq S_{k}$.\nA set family $ {\\mathcal {F}}\\subseteq 2^{X}$ is an antichain (also called a Sperner system) if for all $ S,T\\in {\\mathcal {F}}$ that $ S\\neq T$, we have $ S\\not \\subseteq T$ .\nTheorem (Sperner 1928) Let $ {\\mathcal {F}}\\subseteq 2^{X}$ where $ |X|=n$ . If $ {\\mathcal {F}}$ is an antichain, then $ |{\\mathcal {F}}|\\leq {n \\choose \\lfloor n/2\\rfloor }$ .\n","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/extremal-set-theroy/","tags":null,"title":"Extremal Set Theroy"},{"categories":null,"contents":"计算机网络中的安全 RSA MD5 ","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ji-suan-ji-wang-luo-zhong-de-an-quan/","tags":null,"title":"计算机网络中的安全"},{"categories":null,"contents":"关系数据库规范化理论  8.1 概述\n  模式设计质量的评价指标：数据冗余度，插入/删除等更新异常\n  为什么要研究关系的规划化设计：规范化的目的与手段\n8.2 规范化理论\n8.2.1 函数依赖（FD）\n  函数依赖的定义\n  如何寻找函数依赖：函数依赖与数据完整性约束的关系\n  完全/部分FD，平凡/非平凡FD，直接/传递FD\n  Armstrong公理系统：3条基本规则 + 3条扩充规则\n  基于函数依赖的关键字定义\n  属性集闭包的计算算法\n  关键字的计算算法\n8.2.2 与函数依赖有关的范式\n  范式定义：1NF，2NF，3NF，BCNF\n  理解各级范式与数据冗余度、插入/删除异常的关系\n8.2.3 多值依赖与第四范式\n  多值依赖，平凡多值依赖，非平凡多值依赖\n  多值依赖与函数依赖的关系\n  4NF\n8.3 规范化所引起的一些问题\n  函数依赖的逻辑蕴涵，函数依赖集的等价\n  最小函数依赖集及其判定方法\n  最小函数依赖集的计算算法\n  模式分解的无损联结性、依赖保持性及其判定方法\n  直接到3NF且满足无损联结性和依赖保持性的模式分解算法\n  从3NF到BCNF、4NF的分解方法\n   概述 好的关系模型设计：有合理的数据冗余度，又没有插入和删除等操作异常现象\n在一个关系中，属性之间的内在依赖有两种：函数依赖与多值依赖\n在每个关系中，属性与属性之间的语义连续需要满足一定的要求，称为关系的规范化\n对属性间所存在的内在语义的不同可以将关系的规范化分为几个等级，称为范式。\n规范化理论 规范化的途径：将一个关系分解成多个子关系\n规范化的途径：\n 竖向规范化：采用投影和联接运算，将一个关系模式的属性集分解成若干个子关系模式，有关理论形成了关系数据库的规范化理论，模式分解理论有：无损联接性和依赖保持性 水平规范化：采用选择和并运算，将一个关系元组集合分解成若干个子集，从而构成若干个与原来关系模式相同的子模式，尚未形成成熟的规范化理论  函数依赖（FD） 函数依赖： 一个关系中两组属性之间的某种取值约束\n给定一个关系R，X和Y是关系R的两个子集，如果说每一个X值都有唯一的一个Y值与之对应(即如果两元组X值相同则Y值相同，反之则不一定)，那么我们说X函数决定Y(Y函数依赖于X)，其中X称为决定因素，Y称为依赖因素\n如果一个函数依赖关系$X \\rightarrow Y$ 满足Y不是X的子集，则称这个函数依赖为非平凡的函数依赖，否则为平凡函数依赖\n在关系函数R(U)中，如果有$X\\subset U,Y\\subset U$,且$X\\rightarrow Y$ ,并且对于任何X的真子集X'有$X'\\nrightarrow Y$ ,则称Y完全函数依赖于X，并记作$X\\overset{f}{\\to} Y$ .如满足前者而不完全依赖则称为部分依赖，并记作$X \\overset{P}{\\to} Y$（注意此处的真子集不是针对元组讨论，而是针对属性讨论）\nArmstrong公理系统 基本规则：\n 自反规则：若Y是X子集，则Y依赖于X 增广规则：如果$X \\to Y$,则$XZ \\to YZ$ 传递规则：如果$X \\to Y$,$Y \\to Z$,则$X \\to Z$  扩充规则：\n 分解规则：如果$X\\to YZ$,则$X \\to Y$ 且$X \\to Z$ 合并规则：如果$X\\to Y$且$X \\to Z$，那么$X\\to YZ$ 伪传递规则：如果$X\\to Y$且$WY \\to Z$,则$WX\\to Z$  如果F是关系的一个函数依赖集，X，Y是R的关系子集，如果能从F中已有的函数依赖出发，根据Armstrong公理系统推出$X\\to Y$,则称F逻辑蕴涵$X\\to Y$ 。记为$F \\models X\\to Y$.所有能被F逻辑蕴涵的函数依赖称为F的闭包，记作$F^+$\n关键字：在关系模式R(U,F)中，如果有$K \\subset U$ 且满足$K \\overset{f}{\\to} U$ ,则称K为关系R的关键字\n在关系R中所有关键字中的属性构成的集合称为主属性集，主属性集中的属性称为主属性，对应的其他属性称为非主属性\n如何寻找关键字：\n 利用Armstrong公理系统推导 利用属性集闭包的概念，寻找满足$K_F^+ = U$ 的最小属性集合K 利用最小函数依赖集来优化方法二  属性集闭包：$X_F^+ = {A | F\\models X\\to A}$\n计算属性集X在函数依赖F上的闭包算法（就是对于F中的每一个依赖关系的决定因素，如果决定因素是X+的子集就把对应的依赖因素加入X+，一直重复循环到无法有加入为止）\n输入：关系模式R(U,F),属性集X X+ := X; repeat oldX+ := X+; for each functional dependency Y\\to Z in F do if Y\\subset X+ then X+ := X+ \\cup Z; until ( oldX+ = X+ ) return X+; 寻找关键字的方法二:设置初始关键字K为U，对于K中的每一个元素A，考虑(K-A)之后的属性闭包集，如果为U那么删去A\n对于方法二的优化：考虑根据最小函数依赖集F，只出现在函数依赖左边或者没有出现在函数依赖关系中的为$U_L$,只出现在右边过的为$U_R$，两边都出现过的为$U_A$。考虑到$U_R$的属性不可能出现在任何一个关键字中，而$U_L$中的属性必然是关键字，所以设置初始关键字为$U-U_R$,然后对$U_A$中的每个元素进行判断即可\nset K := U－UR ; for each attribute A in UA { compute $(K – {A})_F^+$ ; if $(K – {A})_F^+$ contains all the attributes in R then set K := K – { A } ; } return K ; 与函数依赖有关的范式 第一范式：关系R(U)中的每个属性都不可分割，则称关系模式满足第一范式。每一个关系都必须满足第一范式1NF\n第二范式：如果有关系$R(U) \\in 1NF$,且其每个非主属性都完全函数依赖于关键字，则称关系满足第二范式（判断第二范式：判断每一个非主属性A与每一个关键字之间是否存在部分函数依赖）\n不满足第二范式的：存在非主属性对关键字的部分函数依赖导致出现了数据冗余导致了产生更新异常\n模式分解：如果存在一组子关系模式 { R1, R2, …, Rk } 满足下述的两个条件，则我们称 { R1, R2, …, Rk } 是关系模式R的一个分解 (Decomposition)：\n $Head(R) = Head(R1)\\cup Head(R2) \\cup … \\cup Head(Rk)$ 设子关系Ri上的函数依赖集为Fi (i=1,2,…,k), 则：$Fi = { X\\to Y | X\\to Y \\in F+ 且 (X∪Y)\\in Head(Ri) }$  模式分解的办法：\n  找出所有不满足范式M要求的函数依赖关系\n  选择一个不符合要求的函数依赖关系作如下的分解：假设 $X\\overset{f}{\\to}Y \\in F+$ 且不满足范式M的要求，则我们将关系模式R分解为如下的两个子关系：\n $R1 ( X\\cup Y, { X\\to Y } )$ $R2 ( Head(R) – Y, F2 )$，其中：$F2 = { A\\to B | (A \\to B) \\in F+ 且 (A∪B)\\subset Head(R2) }$    对于分解得到的子关系模式R2重复上述的步骤1)和步骤2)，直到所有的子关系模式都能满足范式M的要求\n合并那些具有相同关键字的子关系模式\n  对于2NF，要找到的分解出来的依赖关系是$X\\overset{f}{\\to} Y$,其中X是某个候选关键字的真子集，Y是非主属性\n考虑到模式分解的基础是函数依赖集F，而F不是一个最小函数依赖集的情况下，要将关键词相同的子模式合并，故而可以将分解的方法优化为$Head(R1)=X+,Head(R2)=(Head(R)-X+)\\cup X$,其各自的依赖集中属性在Head中\n第三范式：有关系$R(U)\\in 2NF$,且其每个非主属性都不传递函数依赖于关键字，则称关系模式R(U)满足第三范式\n如果关系$R\\notin 3NF$，那么在关系R中必然存在以下形式的函数依赖$X\\overset{f}{\\to} Y $，其中：依赖因素Y是单个的非主属性，而决定因素X则是以下的两种情况之一：\n X是关系R的某个关键字的真子集($R\\notin 2NF$) X并不是关系R的关键字($R \\notin 3NF$ )  BCNF:若关系R(U)满足1NF，且若$X\\to Y$时X必含有该关系模式的关键字，则称其满足BCNF\n满足BCNF的必然是3CNF，但是满足3CNF的不一定是BCNF\n多值依赖与第四范式 多值依赖(MVD): 设有关系模式R(U)，X, Y是U的子集,如果关系模式R(U)满足下述要求：对X的一个确定值，存在Y的一组值与之对应；且Y的这组值又与关系中的其他属性(U-X-Y)(此处是减号)的取值不相关。此时称Y多值依赖于X，并记为：X→→Y\n如果$U-X-Y$是不是空集，则为非平凡的多值依赖，否则为平凡的空值依赖\n多值依赖的性质：\n 如有 X→→Y，则必有 X→→(U-X-Y) 如有 X→Y，则必有 X→→Y (函数依赖是一种特殊的多值依赖)  多值依赖的推导规则：\n 规则 IR1(自反规则)：如果Y是X的子集，则： X → Y 规则 IR2(增广规则)：如果 X → Y，则：XZ → YZ 规则 IR3(传递规则)：如果 X → Y，Y → Z，则：X → Z 规则 IR4(求补规则)：如果 X→→Y，则 X→→(U–X–Y) 规则IR5(多值依赖的增广规则)： 如果 X→→Y 且 $W\\supseteq Z$，则 WX→→YZ 规则IR6(多值依赖的传递规则)：如果 X→→Y，Y→→Z，则 X→→( Z – Y ) 规则IR7(转换规则)：如果 X→Y，则 X→→Y 规则IR8(结合规则)：如果 X→→Y, 且存在另一个属性集合W满足：$W\\cap Y = \\emptyset, W\\to Z, Y \\supseteq Z$, 则：X→Z  第四范式：如果在关系模式$R(U)$中，$X\\to\\to Y$ 是非平凡多值依赖，则X必含有关键字，则称R满足第四范式\n满足第四范式的必然满足BCNF，同时意味着对于不是函数依赖的多值依赖必须是平凡多值依赖\n规范化所引起的一些问题 如果两个函数依赖集的闭包相等，则称这两个函数依赖集等价\n与函数依赖集F相等价的所有函数依赖集中最小者被称为函数依赖集F的最小函数依赖集(也称最小覆盖)\n输入函数依赖集F，找到与F等价的最小的函数依赖集G：\n 消除F中的部分函数依赖，转变为完全函数依赖 消除冗余的函数依赖 以上两部顺序可以对调，但是将部分函数依赖转变为完全函数依赖过程中可能产生新的冗余函数，所以如果先消冗余需要再最后再检查一遍有无冗余函数依赖  具体算法如下： 1. 令 G := F 将 G 中每一个形如 $X\\to (A1,A2,…,An)$ 的函数依赖替换为如下一组依赖因素为单个属性的函数依赖：$X\\to A1, X\\to A2, …, X\\to An$\n 对 G 中的每一个函数依赖 $X\\to A$ 作如下的处理： 对决定因素 X 中的每一个属性 B 作如下处理： 计算属性集的闭包 $(X – B)_G^+$； 如果 $A\\in (X – B)G+$, 则用新的函数依赖 $(X – B)\\to A$ 替换原来的函数依赖 $X\\to A$; 对 G 中的每一个函数依赖 $X\\to A$ 作如下处理： 令 $N := G – { X\\to A }$ ; 计算属性集的闭包 $X_N^+$ ; 如果 $A\\in X_N^+$ , 那么从G中删去函数依赖 $X\\in A$； 将 G 中每一组形如 $X\\to A1, X\\to A2, …, X\\to An$(决定因素相同)的函数依赖合并为一个函数依赖: $X\\to (A1,A2,…,An)$  无损联接性:分解后，原关系中的信息不会丢失.设R是一个关系模式，F是关系模式上R的函数依赖集，$\\rho ={R1,R2,…,Rk}$ 是对R的一个分解。如果对R中满足F的每一个关系实例 r 都有：$r = \\pi_{R1}(r)\\bowtie \\pi_{R2}(r) \\bowtie …… \\bowtie \\pi_{Rk}(r)$ 则称该分解 $\\rho$ 相对于F是“无损联接分解”，或称分解 $\\rho$ 具有无损联接性。\n如果R的分解为 $\\rho = {R1,R2}$，F为R所满足的函数依赖集合，分解$\\rho$具有无损联接性的充分必要条件是：$R1 \\cap R2 \\to (R1 – R2)$ 或 $R1 \\cap R2 \\to (R2 – R1)$\n依赖保持性：原有的函数依赖关系再分解后的关系模式上仍然存在.用 $\\pi_Z(F)$ 来表示函数依赖集F在子关系Z上的投影： $\\pi_Z(F) = { X\\to Y | X\\to Y\\in F+ 且 (X∪Y) \\subseteq Z }$ 如果有：$F+ = (\\pi_{R1}(F) \\cup \\pi_{R2}(F) \\cup … \\cup \\pi_{Rk}(F))^+$. 则称 “分解具有依赖保持性”\n在必须同时满足无损连接性和依赖保持性的要求下，一个关系模式最高可以被分解到满足3NF,分解方法如下：\n   计算F的最小函数依赖集，并用来代替F进行下面的模式分解;     $S = \\emptyset$ ;     对 F 中的每一个函数依赖 $X\\to Y$ 做如下处理： 如果在集合 S 中找不到满足下述条件的子关系模式Z:$X\\cup Y \\supseteq Heading (Z) $,则由X和Y合并构成一个新的子关系模式并加入到集合S中     如果关系 R 的每一个候选关键字 K 都没有出现在分解后的子关系模式中，即：找不到一个原关系R的关键字K和一个子关系模式 Z，且他们之间满足 $K \\subseteq Heading(Z)$ 那么，就从关系R中任选一个候选关键字K, 由K中的属性单独构成一个子关系模式并加入到集合S中去。    ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/normal-form/","tags":null,"title":"关系数据库规范化理论"},{"categories":null,"contents":" ppt上的概念怎么回事，基本运算的逻辑符号 与逻辑表达式认识就够了\n 数字逻辑 数字集成电路的分类\n 根据结构特点和输入信号的响应规则的不同  组合逻辑电路与时序逻辑电路   器件不同  TTL和CMOS电路    数字集成电路的特点\n  电路简单，便于大规模集成，批量生产\n  可靠性、稳定性和精度高，抗干扰能力强\n  体积小、通用性高、成本低\n  可编程性\n  高速度、低功耗\n  加密性好\n  模拟信号：时间、数值连续变化\n  数字信号：时间、数值均离散\n  由于数字信号便于储存分析传输，通常将模拟信号通过模数转换器转换为数字信号\n  数字信号的描述方式 二值数字逻辑与逻辑电平 二值数字逻辑：0、1编码\n表示方式：用高电平表示1，低电平表示0\n数字波形：信号逻辑电平对时间的图形表示\n 非归零型 归零型(1个时间拍内归零)  比特率：每秒钟传输数据的位数\n周期：两个相邻脉冲之间的时间间隔\n脉冲宽度($t_W$): 脉冲幅值的50%的两个时间所跨越的时间\n占空比：脉冲宽度占整个周期的百分比\n上升时间和下降时间：从脉冲幅值的$10%$到$90%$上升下降的时间(ns)\n二进制 进位规律：逢二进一\n优点：\n 易于电路表达 所用元件少，电路简单可靠 运算规则简单  传输：\n 串行传输 并行传输：将一组二进制的所有位同时发送  二值逻辑变量和基本逻辑运算 逻辑运算：二进制数码按照某种特定的因果关系进行运算，使用的数学工具是逻辑代数\n逻辑代数中，有与、或、非三种基本运算\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/","tags":null,"title":"数字逻辑"},{"categories":null,"contents":"多媒体网络 9.1 多媒体网络应用 视频最显著的特点：高比特率\n9.2 流式存储视频 流式存储视频：UDP流、HTTP流、适应性HTTP流\n广泛应用客户端应用缓存，以此缓解变化的端到端时延和变化的服务器和客户之间带宽量的影响\nB：用户应用缓存的长度 Q: 客户应用缓存开始播放之前必须被缓存的比特数 r: 视频消耗速率 x：服务器以恒定速率发送比特，也可以是和时间相关的x(t)\n9.5 支持多媒体的网络 对多媒体应用提供网络层支持：\n 尽可能利用尽力而为服务：公平处理所有流量 区分服务：不同类型流量处理不同 **每连接服务质量(QoS)**保证：每个源到目的地流处理不同，每个应用显式的预约端到端带宽，并因此具有确定的端到端性能。  每连接服务质量保证  标记分组是为了路由器区分不同类型流量的分组 希望在流量类型之间提供流量隔离的度，以便一类流量不会受到另一类流量的负面影响 当为流量类型之间提供隔离的时候，希望尽可能有效的使用资源 如果不总是能够提供充分的资源，并且要确保QoS，则需要一个呼叫准入过程，在这个过程中申告其QoS需求，要么被网络准入，要么无法提供而被网络阻塞  监管：漏桶 分组进入令牌等待队列，在漏桶处取得令牌的分组被发送，桶高度不超过b，每秒生成r个令牌加入桶\n平均速率：r+b/t(长期后为r)\n突发长度：b\n要限制峰值速率：在后面串联一个高度为1的桶，速率r’限制峰值速率\n漏桶+加权公平队列 $$d_{max}=\\frac{b_1}{R*\\frac{w_i}{\\sum w_j}}$$\n","permalink":"http://tristonk.com/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/duo-mei-ti-wang-luo/","tags":null,"title":"多媒体网络"},{"categories":null,"contents":"数据库设计  9.1 数据库设计概述\n  数据库设计的基本任务\n  数据库的生命周期\n9.2 数据库设计的需求分析\n  需求说明书\n9.3 数据库的概念设计\n  数据库概念设计的过程\n  E-R模型与扩充E-R模型的设计\n9.4 数据库的逻辑设计\n  从E－R模型和扩充E－R模型向关系模型的转换\n  对转换得到的关系模式进行规范化设计\n 根据给定的数据完整性约束发现函数依赖（最小函数依赖集） 关键字的计算 范式的判断及分解  9.5 数据库的物理设计\n  索引的作用及其设计策略\n   数据库设计概述 设计的基本任务：\n 根据用户对象的信息需求(用户的数据、结构及其要求)、处理需求(用户对数据的处理过程和方式)和数据库的支持环境(包括硬件、操作系统、DBMS)设计出数据模式 在一定平台制约下，根据信息需求和处理需求设计出性能良好的数据模式  数据库设计的生命周期法：需求分析、概念设计、逻辑设计、物理设计、编码、测试、运行、进一步修改\n其中数据库设计的四个阶段：需求分析、概念设计、逻辑设计、物理设计\n数据库设计的需求分析 确定需要在数据库中保存其信息的客观事物及其相互关系\n可以从三个角度分析数据库的数据需求：\n Things Atrributes Relationships  数据库的概念设计 数据库概念设计的过程：\n 用户分解：首先将所有用户划分为功能相对独立的若干个用户组，然后针对每个用户组进行视图设计。 视图设计：针对每个用户组设计其数据视图，以反映该组用户对于数据的需求。 视图集成：将设计好的若干个局部数据视图集成为一个完整的全局数据视图。  确定所采用的原理与策略 规划视图的集成步骤 发现并解决可能存在的冲突现象    视图集成的原理与策略：\n 等同：指两个或多个数据对象具有相同的语义。包括：属性等同，实体等同，语义相关等同(属性-实体)。如同义同名，同义异名 聚合：数据对象之间的一种组成关系。  由属性聚合成实体 由属性和实体聚合成新的实体   抽取: 将不同实体中的相同属性提取成一个新的实体，并构造成具有继承关系的结构。 常见的几种冲突现象（通过视图修改来解决）  命名冲突:同义异名，同名异义。通过重命名来实现 “同名同义，异名异义” 概念冲突：同一概念在一处为实体，而在另一处则为属性或联系。解决方式：统一为同一个概念（一般为“实体”） 域冲突：例如类型冲突，度量单位的冲突。解决方式：统一 “数据类型” 和 “度量单位” 约束冲突。解决方式：统一数据约束。如果无法统一数据约束，可以视情况来处理：1）如果不同数据约束的语义之间有包含关系，可以尝试构建具有‘父子’关系的继承层次结构，子类可以有比父类更严格的数据约束。2）构建不同的实体集    E-R模型：实体、属性、联系\n扩充E-R模型的设计：属性、实体、联系、嵌套、继承\n数据库的逻辑设计 任务：将前一阶段得到的概念数据模型转换成用户所选择的数据库管理系统支持的逻辑数据模型\n从E－R模型和扩充E－R模型向关系模型的转换：\n 每个实体集被转换成一个关系（模式）。关系及其属性的命名采用原实体集及其属性的名称。实体集的标识属性为关系中的关键字 在一般情况下，每个联系也被转换成一个关系模式，联系名被用作转换得到的关系模式的关系名，该关系模式中的属性由两部分组成：联系自身所具有的属性与该联系相关的实体集的标识属性。来自于相关实体集的标识属性也是相关实体集转换得到的关系模式的主关键字，因此它们也是联系转换得到的关系模式中的外关键字  命名与属性域的处理 关系及属性的命名：\n 尽量采用在EE-R模型中原有的名称 可以重新命名，但要避免命名的冲突现象：在同一个数据库模式中，关系名具有唯一性；在同一个关系模式中，属性名具有唯一性  属性域的定义：根据DBMS的选型进行必要的数据类型转换\n非原子属性处理 集合属性：关系模式不变，但原有关系的一个元组将被纵向展开成多个元组。在上述转换过程中，虽然实体集(或关系模式)中的属性没有增加，但转换得到的关系模式的主关键字由原实体集的标识属性和该集合属性联合构成（红色的属性名集合）。如一个学生对应多门课程，展开后，学号和课程名的组合构成了新的关键字\n元组属性:将一个元组属性横向展开成多个属性.如一个圆对应了半径和圆心(圆心包括x轴，y轴),就将其展开为半径、x轴、y轴\n联系的特殊转换 在一般情况下，一个联系可以被转换成一个关系。但是在有些情况下,联系也可被归并到相关联的实体所对应的关系模式中去，即将联系与某个(或几个)相关联的实体集共同转换成一个关系模式。（考虑是否全参与）\n考虑以下的关系：E1(有属性k1,a),E2(有属性k2,b),(其中k1,k2为两者的关键词)两者之间的联系R(有属性r)，考虑参与基数（下面前者为E1，后者为E2）：\n (0,1)(0,1):即都是非全参与，且关系为1:1,此时分解为三个关系模式：E1(k1,a),E2(k2,b),R(k1,k2,r) (1,1)(0,1):一个全参与一个非全参与，关系1:1,此时分解成两个模式：E1(k1,a,k2,r),E2(K2,b) (1,1)(1,1):即都是全参与，且关系为1:1,此时分解为一个关系模式：E(k1,a,k2,b,r) (?,n)(1,1):关系为一对多，一的这一方全参与，此时分解为两个：E2(K2,b，k1,r),E1(k1,a) (?,n)(0,1):关系为一对多，一的这一方非全参与，此时分解为三个关系模式：E1(k1,a),E2(k2,b),R(k1,k2,r) (?,m)(?,n)：关系为多对多，此时分解为三个关系模式：E1(k1,a),E2(k2,b),R(k1,k2,r)  继承的转换 可以有三种转换方式：\n 每一个实体集都将被转换为一个关系 只有最底层的叶子结点才会被转换为关系，并从其所有超实体集中继承属性。 被转换为单个关系，其中含有所有实体集中的属性。  规范化 通过关系数据库的规范化过程，使设计得到的结果关系模式至少需满足第三范式(3NF)\nRDBMS性能调整 为满足RDBMS在性能、存储空间等方面的要求及其它限制条件所做的调整与修改。包括：\n 逆规范化：减少关系的连接运算次数，提高系统性能 关系的分割：调整每个关系的大小，提高存取效率  水平分割：将一个关系的元组集合划分为若干个不相交的子集，每个子集对应一个子关系模式 垂直分割：将一个关系模式纵向分解成若干个子关系模式（不同于规范化设计中的模式分解）   尽量使用快照  快照(snapshot)：用数据查询命令定义，在创建快照时就执行对应的子查询，并将查询结果以‘实’关系的形式保留在数据库中。 快照的维护：周期性地刷新 / 由用户手工刷新    约束条件设置  完整性约束 安全性约束 数据类型约束 数据量的约束 重新设置每个表的候选键、主键及外键  关系视图的设计 在关系模式基础上所设计的直接面向操作用户的视图即用户的’外模式’，它可以根据用户的需求随时构作，一般 RDBMS 均提供关系视图的功能。\n关系视图的作用\n 提供数据的逻辑独立性 能适应用户对数据的不同需求 有一定数据保密功能  数据库的物理设计 对数据库内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度及有效利用存储空间\n在关系数据库设计中，用户参与物理设计的内容有：存取方法的设计 与 存储结构的设计\n索引 考虑设计的因素：\n 在主关键字及外关键字上建立索引：提高关系联接查询的速度，有利于实体完整性及引用完整性的检查 以读为主的关系应尽可能多地建立索引 如果根据某属性的等值查询所得到的结果元组数量较少，则可以考虑对该属性建立索引 对经常用于统计查询的属性建立索引：可以根据索引数据直接获取统计结果，不必再去访问对应关系的数据块。  ","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/db-design/","tags":null,"title":"数据库设计"},{"categories":null,"contents":" 逻辑门电路：基本参数知道叫什么，不要求分析，但是反相器，与非门，或非门的电路要认识（不要求异或门），传输门要知道怎么回时，不要求分析TTL的工作分析，但是看到要认识\n 逻辑门电路 逻辑门：实现基本逻辑运算和复合逻辑运算的单元电路\n逻辑门电路的分类\n 分立门电路  二极管门电路 三极管门电路   集成门电路  MOS门电路  NMOS门 PMOS门 CMOS门   TTL门电路    一般特性 输入和输出的高低电平 噪声容限：保证输出电平不变的情况下，输入电平允许波动的范围，表示门电路的抗干扰能力 输入高电平的噪声容限$V_{NH}=V_{OH(min)}-V_{IH(min)}$\n输入低电平的噪声容限：$V_{NL}=V_{IL(max)}-V_{OL(max)}$\n传输延迟时间 表征门电路开关速度的参数，说明门电路在输入脉冲波形作用下，输出波形相对于输入延迟了多久的时间\n功耗 静态功耗：门电路没有状态转换时的功耗，即电源总电流$I_D$和电源电压乘积\n动态功耗：指电路输出状态转换时的功耗\n对于TTL而言，静态功耗是主要的\nCMOS的静态功耗很低，有动态功耗\n延时-功耗积 速度功耗综合性指标，用DP表示\n扇入与扇出数 扇入数：取决于逻辑门的输入端个数\n扇出数：在正常工作情况下，所能带同类门电路的最大数目\nMOS开关与等效电路 CMOS反相器 CMOS逻辑门 CMOS传输门(双向模拟开关) TTL逻辑门 ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/","tags":null,"title":"逻辑门电路"},{"categories":null,"contents":"Ramsey theory Ramsey's theorem ramsey's theorem for graph Let $ k,\\ell $ be positive integers. Then there exists an integer $ R(k,\\ell )$ satisfying: If $ n\\geq R(k,\\ell )$, for any coloring of edges of $ K_{n}$ with two colors red and blue, there exists a red $ K_{k}$ or a blue $ K_{\\ell }$ .\nRamsey's Theorem (graph, multicolor) Let $ r,k_{1},k_{2},\\ldots ,k_{r}$ be positive integers. Then there exists an integer $ R(r;k_{1},k_{2},\\ldots ,k_{r})$ satisfying: For any $ r$ -coloring of a complete graph of $ n\\geq R(r;k_{1},k_{2},\\ldots ,k_{r})$ vertices, there exists a monochromatic $ k_{i}$-clique with the $ i$ th color for some $ i\\in {1,2,\\ldots ,r}$.\nramsey number $ R(k,\\ell )\\leq {k+\\ell -2 \\choose k-1}$\nramsey's theorem for hypergraph Ramsey's Theorem (hypergraph, multicolor) Let $ r,t,k_{1},k_{2},\\ldots ,k_{r}$ be positive integers. Then there exists an integer $ R_{t}(r;k_{1},k_{2},\\ldots ,k_{r})$ satisfying: For any $ r$ -coloring of $ {[n] \\choose t}$ with $ n\\geq R_{t}(r;k_{1},k_{2},\\ldots ,k_{r})$, there exist an $ i\\in {1,2,\\ldots ,r}$ and a subset $ X\\subseteq [n]$ with $ |X|\\geq k_{i}$ such that all members of $ {X \\choose t}$ are colored with the $ i$th color.\nApplications \u0026quot;Happy Ending\u0026quot; problem Yao's lowe bound on implicit data structures ","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/ramsey-theroy/","tags":null,"title":"Ramsey Theroy"},{"categories":null,"contents":"半导体存储器是一种能大量存储二值信息的半导体器件\n半导体存储器：\n RAM(Random-Access Memory)：在运行状态可以随时进行读/写操作，必须有电源供应才能保存，掉电后数据丢失  静态随机存储器SRAM 动态随机存储器DRAM  异步存储 同步存储 伪静态随机存储器PSRAM     ROM(Read-Onlu Memory)：正常工作只能读出信息，断电后信息不丢失  固定ROM-掩模ROM 可编程ROM  PROM EPROM E2PROM FLASH      基本概念：\n 字长（位数）：表示一个信息的多位二级制码位一个字，字的位数位字长 字数：字的总量。字数$=2^n$(n为存储器外部地址线的线数) 地址：每个字的编号 存储容量（M）：存储二值信息的总量 = 字数 $\\times$ 位数  ROM ROM的分类：\n 按照存贮单元中器件划分  二极管ROM 三极管ROM MOS管ROM   按写入情况  固定ROM 可编程ROM    掩模ROM 存储矩阵中的每个交叉点是一个存储单元，存储单元中有器件存入1，无器件存入0\n特点：出厂时已经固定，不能更改，适合大量生产，便宜\n可编程ROM（PROM） 总体结构与掩模ROM一样，但存储单元不同\n熔丝由易熔合金制成，出厂时每个结点上都有，编程时将不用的熔断。是一次性编程，不能改写\n写入时，要使用编程器\n可擦除的可编程ROM（EPROM） 总体结构与掩模ROM一样，但存储单元不同\n用紫外线擦除的PROM（UVEPROM） EPROM是采用浮栅技术生产的可编程存储器，它的存储单元多采用N沟道叠栅MOS管（SIMOS），其结构及符号如图所示。除控制栅外，还有一个无外引线的栅极，称为浮栅。当浮栅上无电荷时，给控制栅（接在行选择线上）加上控制电压，MOS管导通；而当浮栅上带有负电荷时，则衬底表面感应的是正电荷，使得MOS管的开启电压变高，如图(b)所示，如果给控制栅加上同样的控制电压，MOS管仍处于截止状态。由此可见，SIMOS管可以利用浮栅是否积累有负电荷来存储二值数据。 在写入数据前，浮栅是不带电的，要使浮栅带负电荷，必须在SIMOS管的漏、栅极加上足够高的电压（如25V），使漏极及衬底之间的PN结反向击穿，产生大量的高能电子。这些电子穿过很薄的氧化绝缘层堆积在浮栅上，从而使浮栅带有负电荷。当移去外加电压后,浮栅上的电子没有放电回路，能够长期保存。当用紫外线或X射线照射时，浮栅上的电子形成光电流而泄放，从而恢复写入前的状态。照射一般需要15至20分钟。为了便于照射擦除，芯片的封装外壳装有透明的石英盖板。EPROM的擦除为一次全部擦除，数据写入需要通用或专用的编程器。\n电可擦除的可编程ROM（$E^2PROM$） 为克服UVEPROM擦除慢，操作不便的缺点，采用FLOTOX（浮栅隧道氧化层MOS管）\n快闪存储器：FLASH RAM 静态随机存储器SRAM 动态随机存储器（DRAM） 动态存储单元是利用MOS管栅极电容可以存储电荷的原理。\n SRAM：速度快，贵 DRAM：相对速度慢，便宜  ","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8/","tags":null,"title":"半导体存储器"},{"categories":null,"contents":"Matching theroy Systems of Distinct Representatives (SDR) A system of distinct representatives (SDR) (also called a transversal) for a sequence of (not necessarily distinct) sets $ S_{1},S_{2},\\ldots ,S_{m}$ is a sequence of distinct elements $ x_{1},x_{2},\\ldots ,x_{m}$ such that $ x_{i}\\in S_{i}$ for all $i=1,2,\\ldots ,m$.\n就是指每个集合中找到一个代表的元素，这些元素各不同。(代表元素也可以存在其他集合中)(相当于每个集合有一个元素与之匹配)\nHall's marriage theorem Hall's Theorem： The sets $S_{1},S_{2},\\ldots ,S_{m}$ have a system of distinct representatives (SDR) **if and only if** $\\left|\\bigcup _{i\\in I}S_{i}\\right|\\geq |I|$ **for all** $I\\subseteq {1,2,\\ldots ,m}$.\nMin-max theorems König-Egerváry theorem Dilworth's theorem Application: Erdős-Szekeres Theorem Application: Hall's Theorem Flow and Cut Flows Cuts Augmenting paths Max-Flow Min-Cut The max-flow min-cut theorem Flow Integrality Theorem Applications: Menger's theorem Applications: König-Egerváry theorem ","permalink":"http://tristonk.com/notes/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/matching-theroy/","tags":null,"title":"Matching Theroy"},{"categories":null,"contents":"微电子学的新发展  生物探测芯片 神经网络计算（人工智能）  忆阻器   超高频电路  石墨烯   超低功耗逻辑/存储  量子隧穿晶体管 自旋电子学晶体管   量子计算  自旋电子学晶体管   智能穿戴  柔性电子学   拓扑绝缘体  忆阻器 用数学模型和算法来描述和模仿神经元的行为和相互关系，但计算仍然运行在传统的计算机上——冯诺依曼架构\n用电子器件模拟生物神经元的功能，构建新的神经计算机——非冯诺依曼架构\n传递信息-处理信息-存储信息\n𝑉(𝑡)=𝑀(𝑞(𝑡))𝐼(𝑡)\n功能如同电阻，但在关掉电源后，仍能“记忆”先前通过的电荷量。忆阻器的电阻值取决于多少电荷经过了这个器件。也就是说，让电荷以一个方向流过，电阻会增加；如果让电荷以相反的方向流过，电阻就会减小。\n 工作原理  一块极薄的二氧化钛被夹在两个电极中间，这些二氧化钛又被分成两个部份，一半是正常的二氧化钛，另一半进行了“掺杂”，少了几个氧原子。因此“掺杂”的那一半带正电，电流通过时电阻比较小，而且当电流从“掺杂”的一边通向正常的一边时，在电场的影响之下缺氧的“掺杂物”会逐渐往正常的一侧游移，使得以整块材料来言，“掺杂”的部份会占比较高的比重，整体的电阻也就会降低。反之，当电流从正常的一侧流向“掺杂”的一侧时，电场会把缺氧的“掺杂物”从回推，电阻就会跟着增加。因此，整个器件就相当于一个滑动变阻器一样。   特点  忆阻器输入输出关系是非线性的。 忆阻器的输入和输出都是连续的, 因而其存储的精度理论上是无限的。 由于忆阻器是基本无源电路元器件，可以方便的将其应用在电路中，形成混合型电路。 由于在电荷流经的时候，忆阻器的内部结构产生变化并能在新的状态下长时间保持。因而具有非易失性的特点。 以上特点都使得忆阻器具备了传统存储器材无可比拟的优势，它的高集成密度、高读写速度、低功耗、多值计算使得它成为下一代存储元件的理想选择。   发展前景  在目前的工艺水平下，基于忆阻器的内存芯片存储密度要比目前基于晶体管的芯片高出至少一个数量级。此外，该存储芯片的运行速度也非常快，将信息存储在忆阻器内存上的速度比存储在快闪内存上的速度高出 3 个数量级 非易失性——目前广泛使用的 DRAM 上存储的内容会随着时间而丢失，因此必须不断地刷新，在存储器数量庞大的时候会消耗巨大的能量。而忆阻器内存因内部构造的原因，一旦写入可以长期保存，不需要被反复刷新。 存算一体    石墨烯 石墨烯（Graphene）是一种由碳原子构成的单层片状结构的新材料。由碳原子以sp2杂化轨道组成六角型呈蜂巢晶格的平面薄膜，只有一个碳原子厚度的二维材料。\n是构建碳纳米管和富勒烯的基本单元\n性能：\n 极薄极轻，厚度为0.34nm，比表面积为2630m2/g 导热率为3000-5000W/mK，与碳纳米管相当 极强的力学性能：拉伸模量1.01TPa，极限强度116GPa 优良的导电性，室温下载流子迁移率是硅的100倍  制备方式：\n 物理方法  机械剥离法 液相或气相直接剥离法   化学方法  表面析出生长法 氧化石墨还原法 化学气相沉积(CVD)法 化学合成法    应用前景\n 低成本石墨烯电池 可折叠弯曲屏 石墨烯传感器：高导电性、高强度、超轻薄 石墨烯过滤器 石墨烯生物器件：可修改化学功能、大接触面积、原子尺寸厚度、分子闸极结构等等特色 石墨烯感光元件 太阳能电池 柔性微处理器  从石墨烯到二维材料：\n 结构有序 二维平面生长 在第三维度超薄  自旋场效应晶体管 在半导体材料中有电子和空穴两种载流子 极化电子有自旋向上和向下的两种载流子\n当电子通过铁磁金属时，电子由简并态，变成向上(+1/2)和向下(-1/2)的非简并态，表现出自旋极化\n柔性电子学 材料：\n 碳纳米管 金属氧化物半导体薄膜 金属纳米薄膜、金属纳米线 有机高分子薄膜 水凝胶离子导体 液态金属  制造方法：\n 转移印刷 喷墨印刷 纤维结构形成  通常具有高导电性和透明性的材料是不可拉伸的。然而，通过几何结构设计，可以使坚硬的材料实现结构上的可拉伸。\n","permalink":"http://tristonk.com/notes/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%8E%E7%94%B5%E8%B7%AF/%E5%BE%AE%E7%94%B5%E5%AD%90%E5%AD%A6%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95/","tags":null,"title":"微电子学的新发展"},{"categories":null,"contents":"正在迁移中，之后就好\n","permalink":"http://tristonk.com/blog/now/","tags":null,"title":"Now"},{"categories":null,"contents":"思考题与作业题 出于考虑，我们删掉了此部分\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/homework/","tags":null,"title":"思考题与作业题"},{"categories":null,"contents":"样卷复习法 出于考虑，我们删掉了此部分\n","permalink":"http://tristonk.com/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/sample-exam/","tags":null,"title":"样卷整理"},{"categories":null,"contents":"当我痛苦地站在你的面前\n你不能说我一无所有\n你不能说我两手空空。\n博客迁移中，稍后再补\nlast edit\n","permalink":"http://tristonk.com/about/","tags":null,"title":"About Me"},{"categories":null,"contents":" 本blog基本搬运jyy的讲义和slides\n FAT FAT文件系统的基本思想是使用链表管理所有的数据块。FAT文件系统把若干个连续的扇区(sector)作为一个簇(cluster)\n希望表示一个文件，我们只需要知道：文件的第一块的编号,对于每一块，它下一块的编号\nFAT文件系统专门在磁盘中开辟一个区域(File Allocation Table, FAT)，来存储每一块的下一块编号。除了编号之外，还有两种特殊的编号：free (0, 该块可以使用),EOF (-1, 该块代表了某个文件的末尾)\n缺点是文件系统可能碎片化，不利用I/O优化，lseek需要读取大量FAT数据块\next2 与上一篇博客中的vsfs基本类似\n采用bitmap进行内存管理\ninode中用多个级别的索引（direct blocks、indirect blocks、double indirect.....）\n目录中顺序存储文件/子目录名字 inode编号 inode--rec_len--name_len--file_type--name\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fat%E4%B8%8Eext2/","tags":null,"title":"FAT与ext2"},{"categories":null,"contents":"System Architecture A Canonical device 硬件接口 + 内部结构\nA Canonical protocol 如上图，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。\n一种典型的协议如下： 对于第一步的while循环，我们称为polling the device (轮询)，在第二步的写数据的时候，如果有main cpu的参与,即称为是programmed I/O(PIO), 即通过CPU执行I/O端口指令来进行数据的读写的数据交换，\nLowering CPU Overhead With Interrupts 为了避免PIO模式下，cpu处于轮询状态而导致资源的浪费，可能有以下几种措施：\n 加入中断操作（但如果device执行操作很快，加入中断反而可能是效率下降） （hybrid，如无法确定device速度）先轮询一会，如果没结束则执行中断  More Efficient Data Movement With DMA DMA(Direct Memory Access)并不负责与计算机系统外的I/O，它的出现主要是为了解决设备访问速度慢的一个缺点：试想我们希望从磁盘中读出海量的数据。\nDMA设备可以看成是只执行memcpy操作的设备\n To transfer data to the device, for example, the OS would program the DMA engine by telling it where the data lives in memory, how much data to copy, and which device to send it to. At that point, the OS is done with the transfer and can proceed with other work. When the DMA is complete, the DMA controller raises an interrupt, and the OS thus knows the transfer is complete.\n Methods Of Device Interaction how the OS actually communicates with the device\n 来源：jyy讲义\n 端口I/O (Port IO, PIO)，相当于是为I/O设备提供了一个单独的地址空间，通过读/写端口的方式实现设备控制。通常，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。顾名思义，我们可以通过控制寄存器实现设备控制(例如设置设备的模式等)，从数据寄存器读写数据，并且读取状态寄存器来查看设备执行命令的状态。（教材上写的是IO instruction） 内存映射I/O (Memory-Mapped I/O, MMIO)。给特定的内存地址赋予特殊的含义，从而读/写内存地址就能实现设备的访问。在PA中，显存就是通过这种方式实现的。一方面，内存映射I/O完全可以用来实现状态/控制/数据寄存器，另一方面，在设备从外部看来是一段连续数据时(例如显存)，MMIO能减少I/O指令的数量。   Fitting Into The OS: The Device Driver device driver(设备驱动程序): 用于对设备进行抽象使得更加上层的部分（通常为文件系统）能够以统一的接口来访问这些设备, 设备驱动程序会将对这些接口的调用翻译成设备的指令发送给设备，并等设备完成.\n设备驱动层帮助我们屏蔽了底层设备的具体实现细节(例如寄存器的含义)。同理，如果我们想创建“虚拟”设备，也是非常容易的，只需要为它编写一个驱动程序即可，实现设备的读接口。Linux系统中就有一些虚拟的设备，如/dev/random, /dev/null\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/io%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8/","tags":null,"title":"IO设备与驱动"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` ... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ... ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ] ```\n","permalink":"http://tristonk.com/search/","tags":null,"title":"Search Results"},{"categories":null,"contents":"FSCK(The File System Checker) 检查的对象：\n  superblock: making sure the file system size is greater than the number of blocks that have been allocated\n  free blocks: 检查inode指向的block和inode本身的状态，确认和bitmap一致，如果不一致，选择相信inode\n  inode state：检查其数据是否看起来合法，如检查文件类型是否有效，如果出错则删除inode并且随之更改bitmap\n  inode links： 检查链接情况（遍历文件树中看link count与inode中是否一致） (没有链接的inode被移到lost+found目录中)\n  duplicates：checks for duplicate pointers, i.e., cases where two different inodes refer to the same block\n  bad blocks：A pointer is considered “bad” if it obviously points to something outside its valid range\n  directory checks：performs additional integrity checks on the contents of each directory, making sure that “.” and “..” are the first entries, that each inode referred to in a directory entry is allocated, and ensuring that no directory is linked to more than once in the entire hierarchy.\n  Journaling(write-ahead logging) 在写之前，在disk的某个确定的位置记录你要做什么，如果发生崩溃，则可以继续执行\n  Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.\n  Checkpoint: Write the pending metadata and data updates to their final locations in the file system.\n  为了节约时间，可以让前几个并发的一起写\n Journal write: Write the contents of the transaction (including TxB, metadata, and data) to the log; wait for these writes to complete. Journal commit: Write the transaction commit block (containing TxE) to the log; wait for write to complete; transaction is said to be committed. Checkpoint: Write the contents of the update (metadata and data) to their final on-disk locations.  Metadata Journaling  Data write: Write data to final location; wait for completion (the wait is optional; see below for details). Journal metadata write: Write the begin block and metadata to the log; wait for writes to complete. Journal commit: Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction (including data) is now committed. Checkpoint metadata: Write the contents of the metadata update to their final locations within the file system. Free: Later, mark the transaction free in journal superblock.  ","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E4%B8%8E%E6%97%A5%E5%BF%97/","tags":null,"title":"崩溃恢复与日志"},{"categories":null,"contents":"CZ 9.1 平面图 若G能够花在一个平面上使得任何两条边都不交叉，称G为一个平面图(planar graph)，若G已经被画在了一个平面上，且任意两条边不交叉，则称G为\t平图(plane graph)。\n一个平图把平面分为一些连通片，这些连通片被称为区域(regions), 在每个平图中总有一个区域是无界的，该区域称为外区域，在一个平图中，顶点与边都与某个给定区域R相关联的子图称为是R的边界.\n 如果G是一个至少含有三条边的连通平图，则G的每个区域的边界至少有三条边\n  **定理9.1 Euler恒等式 **：\n如果G是一个阶为n，边数为m且含有r个区域的连通平图，则n-m+r = 2\n ​ [最小反例证法]\n​ --\u0026gt; 若G是树，显然成立\n​ ---\u0026gt; 若G不是树，取一个含有最小边数且不满足Euler等式的图G，则存在一不是割边的边e，而G-e满足Euler等式，...\n 定理9.2\n如果G是一个阶为$n\\geq 3$且边数为m的平面图，则有$m\\leq 3n-6$\n ​ [直接证法] 计算每个区域的边数之和，割边只计算一次，非割边将计数两次，利用欧拉恒等式构建\n可以利用定理9.2证明有些图不是平面的\n 推论9.3\n每个平面图都含有一个度小于或等于5的顶点\n ​ [逆否证法]\n 推论9.4\n完全图$K_5$是非平面的\n 若G是平面的，且在G的任意两个不邻接的顶点之间添加一条边就可以产生一个非平面，则称G 是极大平面的(maximal planar)，另一种表述形式是：若G是平面的，但G不是其他任何平面图的一个生成子图\n 定理9.5\n图$K_{3,3}$是非平面的\n ​ [反证法] 利用欧拉恒等式，求出其区域数是5，然后计算每个区域的边数之和为2m，再根据其每个区域都不是三角形得出其边数和大于20，即$m\\geq 10$,与m值矛盾\n如果有一个或者多个度为2的顶点插入到了G的一条或者多条边中，则称G‘是G的一个细分(subdivision)\n 定理9.7 Kuratowski定理\n一个图G是平面的当且仅当G不含$K_5，K_{3，3}$，或者是$K_5，K_{3，3}$的一个细分作为子图\n CZ 10.1 顶点染色 地图的对偶是指将一个地图上的一个区域视为图G中的一个点，区域相邻即对应的两个顶点是邻接的，每张地图的对偶都是平面图\n图的一个真染色(proper coloring),或简称为染色(coloring)，指的是给图G每个顶点分配颜色且邻接顶点颜色不同，在所有染色中，使用颜色最少的颜色数称为是色数(chromatic number), 记为$\\chi (G)$, 若能用k中颜色的集合给G染色，则称G是k可染色的(k-colorable),若$\\chi(G)=k$,则也称G是k色的(k-chromatic)的，且G的每个k染色都是G的最小染色(minimum coloring)\n 定理10.1 四色定理\n每个平面图的色数至多是4\n $\\chi(G)=1$当且仅当$G \\cong \\overline{K_n}$(n阶空图)\n若顶点集 S中任意两个顶点不邻接，则称其是独立的，最大独立集的点独立数记为$\\alpha(G)$,\n若G是一个k色图，则可以把V(G)划分为k个独立集，此时这些独立集被称为色类(color classes)\n 定理10.2\n图G的色数是2当且仅当G是一个非空的二部图\n 又由定理1.12，图G是二部的当且仅当没有奇圈，故而若图G有奇圈，则$\\chi(G)\\geq 3$\n图G的一个团(clique)是指G的一个完全子图，图G中最大团的阶数被称为是G的团数(clique number),记为$\\omega(G)$.\n事实上，我们有$\\alpha(G)=k$ 当且仅当 $\\omega(\\overline{G})=k$\n **定理10.5 **\n对于每个n阶图G，我们都有\n​\t$\\chi(G)\\geq\\omega(G)$, $\\chi(G)\\geq \\frac{n}{\\alpha(G)}$\n  定理10.7\n对于每个图G，我们都有$\\chi(G)\\leq 1+\\Delta(G)$ (其中$\\Delta(G)$表示的是图G的最大度)\n  定理10.8 Brooks定理\n对于每个非奇圈也非完全的连通图G，有$\\chi(G)\\leq\\Delta(G)$\n  定理10.9\n对于每个图G，\n​\t$\\chi(G)\\leq 1+max{\\delta(H)}$ （$\\delta(G)$表示G的最小度）\n其中max取遍G的所有诱导子图H\n 图G的影子图(shadow graph)S(G) 是指通过在G中，对每个顶点v，增加一个顶点v'，称为v的影子顶点(shadow vertex)，并连接v’在v中的所有邻点所得到的图（此时v不与原本G中对应的邻点相连）\n 定理 10.10\n对于每个整数$k\\geq 3$,都存在 一个色数为k的无三角的图\n ","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A33/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9D%80%E8%89%B2/","tags":null,"title":"平面图与图着色"},{"categories":null,"contents":" 对应教材：Sutton \u0026amp; Barto's book Reinforcement Learning: An Introduction (2nd Edition) Chap1\n Reinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal\nThe history is the sequence of observations, actions, rewards $$Ht = O_1, R_1, A_1, ..., A_{t−1}, O_t, Rt$$\nState is the information used to determine what happens next, Formally, state is a function of the history: $$S_t = f (H_t)$$\nAn RL agent may include one or more of these components: Policy: agent’s behaviour function Value function: how good is each state and/or action Model: agent’s representation of the environment\nDeterministic policy: $a = π(s)$ Stochastic policy: $π(a|s) = P[A_t = a|S_t = s]$\nValue function is a prediction of future reward. Used to evaluate the goodness/badness of states\nA model predicts what the environment will do next $P$ predicts the next state $R$ predicts the next (immediate) reward, e.g. $$P^a_{ss'} = P[S_{t+1} = s'| S_t = s, A_t = a]$$ $$R^a_s = E [R_{t+1} | S_t = s, A_t = a]$$\n","permalink":"http://tristonk.com/notes/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A01/","tags":null,"title":"强化学习-介绍"},{"categories":null,"contents":"Redundant Array of Inexpensive Disks(RAID): 独立磁盘冗余阵列，通常简称为磁盘阵列\n评价维度 capacity：given a set of N disks each with B blocks, how much useful capacity is available to clients of the RAID\nreliability：How many disk faults can the given design tolerate\nperformance\nRAID-0：striping RAID-0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。\n将每一行的block称为是一个stripe\n也可能是按照chunk来排列，比如一个block为4kb，如果我一个chunk取8kb，将是如下情况：\nRAID-1:Mirroring RAID-1 采用镜像技术,同时在阵列中产生两个完全相同的数据副本，分布在两个不同的磁盘驱动器组上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。\nRAID1+0 RAID0+1 RAID Level 4: Saving Space With Parity 对每一bit做奇偶校验存在一个专门的磁盘的对应bit上\n对于sequential write，先计算出P，然后直接一次写一个stripe\n对于random wirte，将面临如何一边写一边改P，对应的有两种方式： additive parity: 先将其余盘的所有对应的block读出来然后计算P，然后同时写对应block与P，这样的缺点是当disk比较多的时候需要大量的读次数 subtractive parity: 就是看要覆盖的block和要写的block对应bit是否相同，如相同，则对应p不变，如不同则翻转p值，即$P_{new} = (C_{old} ⊕ C_{new}) ⊕ P_{old}$ 在性能分析时，我们分析subtractive parity， 虽然可以并行的读data disk 但是由于parity disk只有一个，故而只能依次来进行（small-write problem），同时每个周期需要读一次写一次，故而只有r/2\nRAID Level 5: Rotating Parity summary To conclude, if you strictly want performance and do not care about reliability, striping is obviously best. If, however, you want random I/O performance and reliability, mirroring is the best; the cost you pay is in lost capacity. If capacity and reliability are your main goals, then RAID-5 is the winner; the cost you pay is in small-write performance. Finally,if you are always doing sequential I/O and want to maximize capacity,RAID-5 also makes the most sense.\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/","tags":null,"title":"持久数据的可靠性"},{"categories":null,"contents":"一些基本定理 除法定理 ： 对于任何整数a与任何正整数n，存在唯一整数q和r，满足$0 \\leq r \u0026lt; n$, 且 $a = qn +r$\n$gcd(a,b) = ar+bs$\n如果任意整数a，b都不为0，那么$gcd(a,b)$为a和b的线性组合集{$ax+by: x,y \\in Z$}中的最小正元素\n$gcd(a,0) = |a|$\ngcd递归定理： $gcd(a,b) = gcd (b, a\\mod b)$\n若x，y为满足$ax+ny=1$的整数，则a在$Z_n$中的乘法逆元是 x mod n\n扩展欧几里得算法 求解$d = gcd(a,b) = ax+by$, 算法返回值为$(d,x,y)$\n模运算 $Z^*_n = {[a]_n : gcd(a,n)=1}$\n$Z^*_n $的规模表示为$\\phi(n)$, 且\n$$\\phi(n) = n \\prod_{p为能整除n的素数}(1-\\frac{1}{p})$$\n中国剩余定理 计算满足$a_i = a\\mod n_i$的a：\n​\t取$m_i = n / n_i$(其中$n=n_1n_2*...*n_k$) ​\t定义$c_i = m_i(m_i^{-1} \\mod n_i)$ ​\t$a = (a_1c_1+a_2c_2+..)\\mod n$\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/","tags":null,"title":"数论基础及数论算法"},{"categories":null,"contents":"基本概念 每一个file都有一个low-level name， 一般我们指inode number,\ndirectory：存储a list of pairs (user-readable name, low-level name)\n UNIX/Linux的File System Hierarchy标准规定了文件系统目录树中各个目录的功能：\n /boot - 系统启动数据 /bin - 应用程序 (bash, ps, grep, ...) /dev - 设备文件 /sbin - 系统程序 (mkfs, fdisk, ifconfig, dhclient, ...) /etc - 配置文件 (= \u0026quot;etcetera\u0026quot;) /home - 用户目录 /lib - 库文件 (libc.so, libpthread.so, ...) /media - 可移动设备 (cdrom, USB flash ,...) /usr - 用户程序 (/usr/bin/, /usr/lib/, /usr/local/) /var - 可变文件 (logs, snapshots, ...) /tmp - 临时文件   File System Interface Creating files int fd = open(\u0026quot;foo\u0026quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);\nO_CREAT :creates the file if it does not exist, O_WRONLY: ensures that the file can only be written to, and, O_TRUNC: if the file already exists, truncates it to a size of zero bytes thus removing any existing content\nReading And Writing Files cat :dump the contents of the file to the screen.\n...(还有一些 不想抄了)\nShared File Table Entries: fork() And dup() dup() call allows a process to create a new file descriptor that refers to the same underlying open file as an existing descriptor.\nWriting Immediately With fsync() fsync(int fd). When a process calls fsync() for a particular file descriptor, the file system responds by forcing all dirty (i.e., not yet written) data to disk, for the file referred to by the specified file descriptor.\nrename rename(char*old, char *new), call is that it is (usually) implemented as an atomic call\nGetting Information About Files stat() or fstat()\nReading Directories opendir(), readdir(), and closedir()\nreaddir()得到以下结构体： Hard Links link() system call takes two arguments, an old pathname and a new one; when you “link” a new file name to an old one, you essentially create another way to refer to the same file. The command-line program ln is used to do this\nlink后的两个指向相同的inode number，对于文件系统而言，对用户可见的名字不同没有关系，因为他们指向相同的内部的结构metadata，这个是根据inode number来查找的\n当你删除一个文件的时候，会调用unlink()，将检查对应inode number对应的reference count（link count），并将其减少1，只有其变为0的时候，才会free掉对应的数据结构\nSymbolic Links(soft links) The way a symbolic link is formed is by holding the pathname of the linked-to file as the data of the link file\nMaking And Mounting A File System mkfs：give the tool, as input, a device (such as a disk partition, e.g., /dev/sda1) and a file system type (e.g., ext3), and it simply writes an empty file system, starting with a root directory, onto that disk partition.\nmount完成的工作是把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里。\n文件系统实现 VSFS(Very Simple File System) Overall Organization 我们假设以4kb为一个block，现在我们假设有一个非常小的disk，只有64个block，考虑其应该有的组成 a) 首先必然存储数据且应该是大部分block都存储数据 b）对于每一个文件，都应该有一个inode c）需要有一个分配结构来追踪每一个data或者inode的block是否为free，有多种实现方式，如链表，此处采用bitmap的方式，每一个bit为0/1表示对应的block是否被占用，此处应有两个bitmap，data和inode各一个 d）一个superblock， 用于存储关于这个文件系统的信息，如有多少各inode和data blocks，inode table从哪里开始等（当挂载一个文件系统的时候，首先读superblock的信息来初始化各种参数）\nFile Organization: The Inode Inode: index node\n每一个inode都会被一个数字所指代（i-number），在操作系统中，给你这个数字，你可以直接计算出在这个磁盘中对应inode的位置\ninode有多种存储方式，如下：\n 连续存储在文件系统中的某个区域，这样可以直接根据inode的编号计算出inode在磁盘中的位置，这也是实现文件唯一id的一个途径；（上图采用的方式） 存储在文件头部，文件唯一id = 第一个数据块的编号； 存储在目录文件中，文件唯一id = 第一个数据块的编号，在支持链接的文件系统中，文件的元数据会有多份拷贝。  在inode中，几乎存储了所有关于其对应文件的信息，我们将这些信息称为metadata,\n包括\n 文件的唯一id； 文件的类型，用于区分普通文件和目录文件； 访问权限，就是大家熟知的rwxrwxrwx； 所有者信息 (uid, gid)，但这在跨系统访问时成为很大的麻烦； 文件大小； 文件访问的时间信息：创建时间、访问时间、修改时间； 链接数量 (刚才已经提到)； 一些其他信息，例如文件的第一个数据块的编号等  一种inode存储的信息示例如下：\n在inode中有一个重要信息是指向文件data所在block的地址的指针，一种实现方式是采用direct pointer，但是这样对于较大的文件，存储在多个不同的block中时会比较麻烦，此时一种方式时采用indirect pointer,这个指针指向一个全部存储对应的direct pointer的block，而如果还要更大的话，则可以采用double indirect pointer(即指向一个全是indirect pointer的block)，如果还要更多，可以以此类推triple indirect pointer\nDirectory Organization each entry has an inode number, record length (the total bytes for the name plus any left over space), string length (the actual length of the name), and finally the name of the entry.\n目录同样被操作系统认为是一个文件，有对应的inode，只是inode中其类型为directory\nFree Space Management 在vsfs中，用的是bitmap，还可以用链表来实现，现代操作系统中有更多的实现方式如b-tree\nAccess Paths: Reading and Writing 对于一个路径，如果我们想找到对应的文件或目录的inode值，其值一般会存储在其父目录中，而**/**没有父目录，故而一般在unix系统中设置其inode值为2，找到父目录的inode之后，就根据指针找到其data区域，在data中找到其对应文件的入口，找到后，文件系统就获取的该文件的inode number，之后类似的重复直到找到对应文件为止。在open（）操作中，找到文件后，会把文件的inode读入，并在pre-process open-file table中分配一个fd给这个process。\n打开文件后如执行read操作，则会更新inode中的存储的时间变量，然后回更新fd对应的in-memory open file table，修改文件偏移量\n如果要写文件的话，要先读inode，再读bitmap，再写bitmap，分配后再写data，写完后更新inode\nFAT与ext2 断章了，见下一篇blog\n","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","tags":null,"title":"文件系统"},{"categories":null,"contents":"这一章 毫无打字的想法 最讨厌打公式了的说(╯°Д°)╯︵┻━┻\n28.1 求解线性方程组 对于线性方程组，设$A=(a_{ij}),x=(x_i),b=(b_i)$,记为 $Ax=b$, 若A为非奇异矩阵，则其具有逆向量，于是$x=A^{-1}b$ 是其解向量。若A的秩为n， 若方程数目少于n，则其是**欠定的**，若多于，则为**超定的**\nLUP分解综述 LUP分解就是要找到三个$n \\times n$ 的矩阵L,U,P，从而满足 $PA=LU$, 其中L是一个单位下三角矩阵，U是一个上三角矩阵，P是一个置换矩阵。满足要求的L,U,P被称为是矩阵A的LUP分解，每一个非奇异矩阵A都有这样一种分解。\n求解Ax=b时，将其转化为$LUx=Pb$, 进而设$y=Ux$, 通过正向替换的方法求解下三角系统$Ly=Pb$ 得到未知向量y, 然后通过一种反向替换的方法来求解上三角系统$Ux=y$ 得到未知向量x，此时的x就是解向量。\n正向替换与反向替换 重写等式，替换，代入。\n上算法中，我们假定维数n出现在属性L.rows中，置换矩阵P使用数组$\\pi$表示\n计算一个LU分解\n分解$A=LU$, 我们利用高斯消元法来创建一个LU分解\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A33/%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/","tags":null,"title":"矩阵计算"},{"categories":null,"contents":" 参考阅读\n 终端默认是“cooked mode”，即自带一个“行编辑器”，只有按下回车键，read系统调用才返回\nshell执行程序 int pid = fork(); if (pid == 0) { // 管道、重定向、……  execve(...); } else { if (!endswith(\u0026#34;\u0026amp;\u0026#34;)) { wait(NULL); } } ","permalink":"http://tristonk.com/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%88%E7%AB%AF%E4%B8%8Eshell/","tags":null,"title":"终端与shell"},{"categories":null,"contents":" 参考书籍：\n 群论-李新征讲义 Thomas Judson: Abstract Algebra - Theory and Applications, 2018.   群 群：设𝐆是一些元素（操作）的集合，记为𝐆 = {⋯，g，⋯}，在𝐆中定义了乘运算，如果𝐆中元素对这种运算满足下面四个条件：\n 封闭性：∀两个元素（操作）的乘积仍属于这类元素（操作）的集合 结合律：对∀三个元素（操作）𝐟、𝐠、𝐡，有(𝐟𝐠)𝐡 = 𝐟(𝐠𝐡) 有唯一单位元素 e，使得对∀𝐟 ∈ 𝐆，有𝐞𝐟 = 𝐟𝐞 = 𝐟 对∀𝐟 ∈ 𝐆，存在且唯一存在$𝐟^{−𝟏}$属于 G，使$𝐟^−𝟏𝐟$ = $ 𝐟𝐟^{−𝟏} $ = 𝐞； 这时我们称𝐆是一个群，其中元素是群元，𝐞为其单位元素，$𝐟^{−𝟏}$为𝐟的逆。  有限群： 群内元素的个数称为群的阶，群阶有限时称为有限群\nAbel群：群内的运算可以互换（可以看出abel群的乘法表都是关于对角线对称的）\n重排定理：设𝐆 = {⋯，$𝐠{𝛂}$，⋯}，对∀𝐮 ∈ 𝐆，当$ 𝐠_𝛂 $取遍𝐆中所有元素时，$𝐮𝐠_𝛂$给出且仅仅一次给出𝐆中所有元素。\n子群与陪集 子群：设 H 是群 G 的一个子集（部分元素的集合），若对群 G 相同的乘法运算，H 也构成一个群，则称 H 为 G 的子群。 要证明一个群为子群，只需要证明其封闭性与每个元素唯一逆即可，单位元可以通过封闭性得证，结合律必然成立\nn 阶循环群：它的定义是$a^n = e$，由${a、a^2、⋯ 、a^{n−1}、a^n = e}$组成。这样的群是 Abel 群，乘法可易。\n群元的阶：对任意一个有限群𝐆，从中取一个元素𝐚，从𝐚出发作幂操作，总是可以构成𝐆的一个循环子群$𝐙_𝐤$的，这个𝐙𝐤等于${𝐚、𝐚^𝟐、 ⋯、𝐚^{𝐤−𝟏}、𝐚^𝐤 = 𝐞}$，这时称𝐤（满足这个性质的最小的𝐤）为群元𝐚的阶。\n陪集：设𝐇是群𝐆的子群，𝐇 = {$𝐡_𝛂$}，由固定的𝐠 ∈ 𝐆，可生成子群𝐇的左陪集：$𝐠𝐇 = {𝐠𝐡_𝛂|𝐡_𝛂 ∈ 𝐇}$，也可生成子群𝐇的右陪集：𝐇𝐠 = {$𝐡_𝛂𝐠|𝐡_𝛂 ∈ 𝐇$}。\n陪集定理：设群𝐇是群𝐆的子群，则𝐇的两个左（或右）陪集或者完全相同，或者没有任何公共元素。\n拉格朗日（Lagrange）定理：有限群子群的阶，必为群阶的因子。\n类与不变子群 共轭：所谓共轭，指的是群𝐆中两个元素𝐟、𝐡，如果在𝐆中存在一个𝐠，使得𝐟、𝐡可以通过$𝐠𝐟𝐠^{−𝟏} = 𝐡$联系起来，则称𝐟、𝐡共轭，记为𝐟~𝐡。\n 类：群 G 中所有相互共轭的元素形成的集合，称为群 G 的一个类。\n 一个群中的单位元素自成一类，因为对任意 f 属于 G，$fef^{−1} = e$； Abel 群的所有元素都自成一类，因为对任意 f 属于 G，取任意 h 属于 G，$hfh^{−1} = hh^{−1}f = f$； 设群元素 f 的阶为 m，即$f^m = e$，则与它同类的元素的阶也为 m  定理 1.4 有限群的每个类中元素的个数都是群阶的因子。\n共轭子群：设 H 和 K 是群 G 的两个子群，若存在 g 属于 G，使得$𝐊 =𝐠𝐇𝐠^{−𝟏} = {𝐠𝐡𝐠^{−𝟏}|𝐡 ∈ 𝐇}$。这时，称 H 和 K 是共轭子群\n正规子群：设 H 是 G 的子群，如果 H 中所有元素的同类元素都属于 H，则称 H是 G 的不变子群（数学上一般称为正规子群）。\n定理 1.5 设 H 是 G 的不变子群，那么对任意固定的 f 属于 G，当$h_α$取遍 H 中所有元素的时候，$fh_αf^{−1}$给出且仅仅一次给出 H 中所有元素 实际上，所有 Abel 群的子群都是其不变子群。因为每个元素自成一类，其同类元素自然在这个子群中\n定理 1.6 不变子群的左陪集与右陪集是重合的。 不变子群的陪集还有另外一个更加重要的性质，就是两个（非子群的）不同陪集中元素的乘积，必为第三个陪集中的元素。这个说的是什么呢？就是H是G的不变子群，由H，可将G分解为G={g0H、g1H、g2H、…}。这样的话在这一系列的陪集中，取giH与gjH这两个陪集中的元素gihα与gjhβ相乘，结果是这样的：当giH与gjH都不是g0H时，必属于giH与gjH外的另一个陪集；当giH、gjH其中一个是g0H时，必属于giH与gjH中的另一个；giH与gjH都是g0H时，必属于g0H。\n同态与同构 同构映射：若从群 G 到群 F 上，存在一一对应的满映射$\\Phi$，且这个映射本身保持群的乘法运算规律不变，也就是说 G 中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同构，记作 G≅F。映射$\\Phi$ 称为同构映射。\n群 G 的两个互为共轭的子群H与K，由定义，是存在一个固定的 g 属于 G，使得对任意的hα ∈ H，都有$k_α = gh_αg^{−1} \\in K$与之对应。这个对应关系是一对一的，同时单位元素对应单位元素，互逆元素对应互逆元素。所以同一个群的两个共轭子群同构。\n同态：设存在从群 G 到群 F 的满映射（注意，没有一对一了）𝚽，且这个映射本身保持群的乘法运算规律不变，也就是说G中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同态，记作 G~F。映射𝚽称为同态映射。\n同态核：设 G 与 F 同态，那么 G 中与 F 的单位元素对应的所有元素的集合称为同态核。\n（同态核定理）设 G 与 F 同态，则有：\n 同态核 H 是 G 的不变子群； 商群 G/H 与 F 同构。  第一同态定理: 若$\\varphi:G\\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\\phi:G\\to G/K$是规范同态函数。则存在唯一的同构函数$\\eta:G/K\\to\\varphi(G)$使得$\\varphi=\\eta\\phi$\n规范同态函数产生的商群与原同态函数的像同构\n第二同态定理: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\\cap N$是$H$的正规子群，且$$H/H\\cap N\\cong HN/N$$ 一致性定理: 设$N$是$G$的正规子群，则$H\\mapsto H/N$是包含$N$的子群$H$的集合与$G/N$的子群的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。 第三同构定理: 设$N$和$H$是$G$的正规子群满足$N\\subseteq H$,则$$G/H\\cong\\frac{G/N}{H/N}$$.\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E7%BE%A4%E8%AE%BA%E5%9F%BA%E7%A1%80/","tags":null,"title":"群论基础"},{"categories":null,"contents":"基本概念 $$ε_A(x)=\\dfrac{|cost(A(x))−OptU(x)∣}{Opt_U(x)}$$\n$$R_A(x)=max{OptU(x)/cost(A(x)),costA(x)/OptU(x)}.$$\nNPO问题分类 NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)\nNPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)\nNPO(III): 包含所有$U∈NPO$ 满足：\n 对某些δ\u0026gt;1存在多项式时间的δ−近似算法 对某些d\u0026lt;δ不存在多项式时间的的d−近似算法 i.e.U没有PTAS  NPO(IV): 包含所有$U∈NPO$满足：\n满足：\n 对某些f:N→R+,存在多项式时间的f(n)−近似算法,其中f以某个多项式函数为界  对任意$δ∈R^+$不存在任何多项式时间的δ−近似算法 e.g.集合覆盖问题    NPO(V): 包含所有$U∈NPO$，满足若存在多项式时间的f(n)−近似算法，则f(n)不以任何多项式函数为界(e.g. TSP, 最大团问题)\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/","tags":null,"title":"近似算法"},{"categories":null,"contents":"基本概念 $RandomA(x):$ 对于所有A在x上的随机计算中使用的random bits的最大数量 $Prob_{A,x}(C)$: 某一次AA对输入xx的计算CC, 由相应的随机序列的概率决定 $Prob(A(x)=y)$: A 对于输入x输出y的概率 $Time(C)$: the time complexity of the run C of A on x\n随机算法 Las Vegas Algorithms 要么给出问题的正确答案，要么得不到答案\n$$Prob(A(x)=F(x))⩾ \\frac{1}{2}$$,and $$Prob(A(x) = “?”) = 1 - Prob(A(x) = F(x)) \\leqslant \\dfrac{1}{2}.$$\nOne-Sided-Error Monte Carlo Algorithms for every $x \\in L$, $Prob(A(x) = 1) \\geqslant \\dfrac{1}{2}$, and for every $x \\notin L$, $Prob(A(x) = 0) = 1$ 跑k次，只要有一次输出1，则其必然为1，若均为0，则出错概率小于$(1/2)^k$, (只会单向出错)\nTwo-Sided-Error Monte Carlo Algorithms $Prob(A(x)=F(x))⩾ \\dfrac{1}{2}+ε$.\n跑t次，输出至少出现了$\\lceil t/2 \\rceil$ 次的结果\nUnbounded-Error Monte Carlo Algorithms $Prob(A(x)=F(x)) \u0026gt; \\dfrac{1}{2}$.\n","permalink":"http://tristonk.com/notes/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A34/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/","tags":null,"title":"随机算法"}]