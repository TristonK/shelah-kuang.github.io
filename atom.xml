<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>少年游</title>
  
  <subtitle>茫茫人海，却似荒野</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shelah-kuang.github.io/"/>
  <updated>2019-07-03T06:20:16.826Z</updated>
  <id>http://shelah-kuang.github.io/</id>
  
  <author>
    <name>kuangsl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RL2</title>
    <link href="http://shelah-kuang.github.io/2019/07/03/RL2/"/>
    <id>http://shelah-kuang.github.io/2019/07/03/RL2/</id>
    <published>2019-07-03T06:20:16.000Z</published>
    <updated>2019-07-03T06:20:16.826Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>强化学习-介绍</title>
    <link href="http://shelah-kuang.github.io/2019/07/03/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A01/"/>
    <id>http://shelah-kuang.github.io/2019/07/03/强化学习1/</id>
    <published>2019-07-03T06:19:50.000Z</published>
    <updated>2019-07-03T07:40:10.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 对应教材：Sutton &amp; Barto’s book <a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement Learning: An Introduction (2nd Edition)</a> Chap1</p></blockquote><p>Reinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 对应教材：Sutton &amp;amp; Barto’s book &lt;a href=&quot;http://incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;R
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java学习(1)-基础语法</title>
    <link href="http://shelah-kuang.github.io/2019/06/27/java%E5%AD%A6%E4%B9%A01/"/>
    <id>http://shelah-kuang.github.io/2019/06/27/java学习1/</id>
    <published>2019-06-27T15:19:57.000Z</published>
    <updated>2019-06-27T16:04:19.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>教材：Core Java Volume I-Fundamentals (10th edition)</p></blockquote><blockquote><p>Tips:   对于有c++基础的同学而言，这一章挺简单的，建议瞟一眼跳了就行</p></blockquote><h2 id="一个简单的java程序"><a href="#一个简单的java程序" class="headerlink" title="一个简单的java程序"></a>一个简单的java程序</h2><p>源代码的文件名必须与公共类的文件名字相同，并用<code>.java</code>作为文件扩展名</p><p>java中的main函数必须是静态的</p><p>java中的所有函数都属于某个类的方法</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>与c++一致 <code>\\</code> <code>\**\</code></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 <strong>-128（-2^7）</strong>；</li><li>最大值是 <strong>127（2^7-1）</strong>；</li><li>默认值是 <strong>0</strong>；</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong>；</li><li>最大值是 <strong>32767（2^15 - 1）</strong>；</li><li>默认值是 <strong>0</strong>；</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 <strong>0</strong> ；</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li><li>默认值是 <strong>0L</strong>；</li></ul><p><strong>java 整型变量大小与平台无关（32位/64位），且不存在无符号整数类型</strong></p><p>在java7之后可以给数字字面加上下划线更加易读，如<code>1_000_000</code>表示1百万，编译器会去掉这些下划线</p><h4 id="8-16-2进制表示"><a href="#8-16-2进制表示" class="headerlink" title="8/16/2进制表示"></a>8/16/2进制表示</h4><p>十六进制<code>0x</code> 或者<code>0X</code></p><p> 八进制：前缀0（易混淆不建议使用）</p><p>二进制：从java7开始，可以用<code>0b</code>或<code>0B</code>开头表示二进制</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>float：+/- 3.40282347E+38F （有效数字6-7位）</p><p>double：+/- 1.79769313486231570E + 308 (有效数字15位)</p><p>float类型的数值有一个后缀<code>f</code>或<code>F</code>，没有后缀的浮点数值默认为double类型</p><p><code>Double.POSITIVE_INFINITY</code> 表示正无穷大， <code>Double_NEGATIVE_INFINITY</code>表示负无穷大， <code>Double.NaN</code>表示不是一个数字（但是注意不能直接用<code>==</code>来检测一个值是不是NaN，这个判断是永不成立的，应当使用<code>Double.isNaN()</code>方法）</p><h3 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h3><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出后换行：<code>System.out.println()</code><br>输出后不换行：<code>System.out.print()</code></p><h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;教材：Core Java Volume I-Fundamentals (10th edition)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips:   对于有c++基础的同学而言，这一章挺简单的，建议瞟一眼跳了就行&lt;
      
    
    </summary>
    
      <category term="coding" scheme="http://shelah-kuang.github.io/categories/coding/"/>
    
    
      <category term="-java" scheme="http://shelah-kuang.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>终端与shell</title>
    <link href="http://shelah-kuang.github.io/2019/06/22/%E7%BB%88%E7%AB%AF%E4%B8%8Eshell/"/>
    <id>http://shelah-kuang.github.io/2019/06/22/终端与shell/</id>
    <published>2019-06-22T12:59:01.000Z</published>
    <updated>2019-06-22T13:19:32.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html#Implementing-a-Shell" target="_blank" rel="noopener">参考阅读</a></p></blockquote><p>终端默认是“cooked mode”，即自带一个“行编辑器”，只有按下回车键，read系统调用才返回</p><h2 id="shell执行程序"><a href="#shell执行程序" class="headerlink" title="shell执行程序"></a>shell执行程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 管道、重定向、……</span></span><br><span class="line">  execve(...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!endswith(<span class="string">"&amp;"</span>)) &#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html#Implementing-a-Shell&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>崩溃恢复与日志</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E4%B8%8E%E6%97%A5%E5%BF%97/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/崩溃恢复与日志/</id>
    <published>2019-06-21T13:42:10.000Z</published>
    <updated>2019-06-22T12:22:00.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FSCK-The-File-System-Checker"><a href="#FSCK-The-File-System-Checker" class="headerlink" title="FSCK(The File System Checker)"></a>FSCK(The File System Checker)</h2><p>检查的对象：</p><ul><li><p>superblock: making sure the file system size is greater than the number of blocks that have been allocated</p></li><li><p>free blocks: 检查inode指向的block和inode本身的状态，确认和bitmap一致，如果不一致，选择相信inode</p></li><li><p>inode state：检查其数据是否看起来合法，如检查文件类型是否有效，如果出错则删除inode并且随之更改bitmap</p></li><li><p>inode links： 检查链接情况（遍历文件树中看link count与inode中是否一致） (没有链接的inode被移到lost+found目录中)</p></li><li><p>duplicates：checks for duplicate pointers, i.e., cases where two different inodes refer to the same block</p></li><li><p>bad blocks：A pointer is considered “bad” if it obviously points to something outside its valid range</p></li><li><p>directory checks：performs additional integrity checks on the contents of each directory, making sure that “.” and “..” are the first entries, that each inode referred to in a directory entry is allocated, and ensuring that no directory is linked to more than once in the entire hierarchy.</p></li></ul><h2 id="Journaling-write-ahead-logging"><a href="#Journaling-write-ahead-logging" class="headerlink" title="Journaling(write-ahead logging)"></a>Journaling(write-ahead logging)</h2><p>在写之前，在disk的某个确定的位置记录你要做什么，如果发生崩溃，则可以继续执行</p><ol><li><p>Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.</p></li><li><p>Checkpoint: Write the pending metadata and data updates to their final locations in the file system.</p></li></ol><p>为了节约时间，可以让前几个并发的一起写</p><ol><li>Journal write: Write the contents of the transaction (including TxB, metadata, and data) to the log; wait for these writes to complete.</li><li>Journal commit: Write the transaction commit block (containing TxE) to the log; wait for write to complete; transaction is said to be committed.</li><li>Checkpoint: Write the contents of the update (metadata and data) to their final on-disk locations.</li></ol><h4 id="Metadata-Journaling"><a href="#Metadata-Journaling" class="headerlink" title="Metadata Journaling"></a>Metadata Journaling</h4><ol><li>Data write: Write data to final location; wait for completion (the wait is optional; see below for details).</li><li>Journal metadata write: Write the begin block and metadata to the log; wait for writes to complete.</li><li>Journal commit: Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction (including data) is now committed.</li><li>Checkpoint metadata: Write the contents of the metadata update to their final locations within the file system.</li><li>Free: Later, mark the transaction free in journal superblock.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FSCK-The-File-System-Checker&quot;&gt;&lt;a href=&quot;#FSCK-The-File-System-Checker&quot; class=&quot;headerlink&quot; title=&quot;FSCK(The File System Checker)&quot;&gt;&lt;/a&gt;F
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>持久数据的可靠性</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/持久数据的可靠性/</id>
    <published>2019-06-21T13:41:53.000Z</published>
    <updated>2019-06-22T09:32:09.043Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>Redundant Array of Inexpensive Disks(RAID)</code></strong>: 独立磁盘冗余阵列，通常简称为磁盘阵列</p><p><img src="/2019/06/21/持久数据的可靠性/raid.png"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p><strong>capacity</strong>：given a set of N disks each with B blocks, how much useful capacity is available to clients of the RAID</p><p><strong>reliability</strong>：How many disk faults can the given design tolerate</p><p><strong>performance</strong></p><h2 id="RAID-0：striping"><a href="#RAID-0：striping" class="headerlink" title="RAID-0：striping"></a>RAID-0：striping</h2><p>RAID-0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 </p><p><img src="/2019/06/21/持久数据的可靠性/r0.png" height="75%" width="75%"></p><p>将每一行的block称为是一个<strong>stripe</strong></p><p>也可能是按照chunk来排列，比如一个block为4kb，如果我一个chunk取8kb，将是如下情况：</p><p><img src="/2019/06/21/持久数据的可靠性/r01.png" height="50%" width="50%"></p><h2 id="RAID-1-Mirroring"><a href="#RAID-1-Mirroring" class="headerlink" title="RAID-1:Mirroring"></a>RAID-1:Mirroring</h2><p>RAID-1 采用镜像技术,同时在阵列中产生两个完全相同的数据副本，分布在两个不同的磁盘驱动器组上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。</p><p><img src="/2019/06/21/持久数据的可靠性/r1.png" height="75%" width="75%"></p><h3 id="RAID1-0"><a href="#RAID1-0" class="headerlink" title="RAID1+0"></a>RAID1+0</h3><p><img src="/2019/06/21/持久数据的可靠性/1+0.png"></p><h3 id="RAID0-1"><a href="#RAID0-1" class="headerlink" title="RAID0+1"></a>RAID0+1</h3><p><img src="/2019/06/21/持久数据的可靠性/0+1.png"></p><h2 id="RAID-Level-4-Saving-Space-With-Parity"><a href="#RAID-Level-4-Saving-Space-With-Parity" class="headerlink" title="RAID Level 4: Saving Space With Parity"></a>RAID Level 4: Saving Space With Parity</h2><p><img src="/2019/06/21/持久数据的可靠性/r4.png" height="75%" width="75%"></p><p>对每一bit做奇偶校验存在一个专门的磁盘的对应bit上</p><p>对于sequential write，先计算出P，然后直接一次写一个stripe</p><p>对于random wirte，将面临如何一边写一边改P，对应的有两种方式：<br><strong><code>additive parity</code></strong>: 先将其余盘的所有对应的block读出来然后计算P，然后同时写对应block与P，这样的缺点是当disk比较多的时候需要大量的读次数<br><strong><code>subtractive parity</code></strong>: 就是看要覆盖的block和要写的block对应bit是否相同，如相同，则对应p不变，如不同则翻转p值，即$P_{new} = (C_{old} ⊕ C_{new}) ⊕ P_{old}$<br>在性能分析时，我们分析subtractive parity， 虽然可以并行的读data disk 但是由于parity disk只有一个，故而只能依次来进行（small-write problem），同时每个周期需要读一次写一次，故而只有r/2</p><h2 id="RAID-Level-5-Rotating-Parity"><a href="#RAID-Level-5-Rotating-Parity" class="headerlink" title="RAID Level 5: Rotating Parity"></a>RAID Level 5: Rotating Parity</h2><p><img src="/2019/06/21/持久数据的可靠性/r5.png" height="75%" width="75%"></p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>To conclude, if you strictly want performance and do not care about reliability, striping is obviously best. If, however, you want random I/O performance and reliability, mirroring is the best; the cost you pay is in lost capacity. If capacity and reliability are your main goals, then RAID-5 is the winner; the cost you pay is in small-write performance. Finally,if you are always doing sequential I/O and want to maximize capacity,RAID-5 also makes the most sense.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;Redundant Array of Inexpensive Disks(RAID)&lt;/code&gt;&lt;/strong&gt;: 独立磁盘冗余阵列，通常简称为磁盘阵列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/06/21/持久数据的可靠性/raid.p
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>FAT与ext2</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/FAT%E4%B8%8Eext2/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/FAT与ext2/</id>
    <published>2019-06-21T13:41:38.000Z</published>
    <updated>2019-06-22T09:12:27.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本blog基本搬运jyy的讲义和slides</p></blockquote><h2 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h2><p>FAT文件系统的基本思想是使用链表管理所有的数据块。FAT文件系统把若干个连续的扇区(sector)作为一个簇(cluster)</p><p>希望表示一个文件，我们只需要知道：文件的第一块的编号,对于每一块，它下一块的编号</p><p>FAT文件系统专门在磁盘中开辟一个区域(File Allocation Table, FAT)，来存储每一块的下一块编号。除了编号之外，还有两种特殊的编号：free (0, 该块可以使用),EOF (-1, 该块代表了某个文件的末尾)</p><p>缺点是文件系统可能碎片化，不利用I/O优化，lseek需要读取大量FAT数据块</p><h2 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h2><p>与上一篇博客中的vsfs基本类似</p><p>采用bitmap进行内存管理</p><p>inode中用多个级别的索引（direct blocks、indirect blocks、double indirect…..）</p><p>目录中顺序存储文件/子目录名字 inode编号<br>inode–rec_len–name_len–file_type–name</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本blog基本搬运jyy的讲义和slides&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;FAT&quot;&gt;&lt;a href=&quot;#FAT&quot; class=&quot;headerlink&quot; title=&quot;FAT&quot;&gt;&lt;/a&gt;FAT&lt;/h2&gt;&lt;p&gt;FAT文件系统的基
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/文件系统/</id>
    <published>2019-06-21T13:41:14.000Z</published>
    <updated>2019-06-22T08:54:29.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>每一个file都有一个<code>low-level name</code>， 一般我们指<strong><code>inode number</code></strong>, </p><p><strong><code>directory</code></strong>：存储a list of pairs  (user-readable name, low-level name)</p><blockquote><p>UNIX/Linux的File System Hierarchy标准规定了文件系统目录树中各个目录的功能：</p><ul><li>/boot - 系统启动数据</li><li>/bin - 应用程序 (bash, ps, grep, …)</li><li>/dev - 设备文件</li><li>/sbin - 系统程序 (mkfs, fdisk, ifconfig, dhclient, …)</li><li>/etc - 配置文件 (= “etcetera”)</li><li>/home - 用户目录</li><li>/lib - 库文件 (libc.so, libpthread.so, …)</li><li>/media - 可移动设备 (cdrom, USB flash ,…)</li><li>/usr - 用户程序 (/usr/bin/, /usr/lib/, /usr/local/)</li><li>/var - 可变文件 (logs, snapshots, …)</li><li>/tmp - 临时文件</li></ul></blockquote><h2 id="File-System-Interface"><a href="#File-System-Interface" class="headerlink" title="File System Interface"></a>File System Interface</h2><h3 id="Creating-files"><a href="#Creating-files" class="headerlink" title="Creating files"></a>Creating files</h3><p>int fd = <strong><code>open</code></strong>(“foo”, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);</p><p>O_CREAT :creates the file  if it does not exist,<br>O_WRONLY: ensures that the file can only be written to, and,<br>O_TRUNC: if the file already exists, truncates it to a size of zero bytes thus removing any existing<br>content </p><h3 id="Reading-And-Writing-Files"><a href="#Reading-And-Writing-Files" class="headerlink" title="Reading And Writing Files"></a>Reading And Writing Files</h3><p><strong><code>cat</code></strong> :dump the contents of the file to the screen.</p><p>…(还有一些 不想抄了)</p><h3 id="Shared-File-Table-Entries-fork-And-dup"><a href="#Shared-File-Table-Entries-fork-And-dup" class="headerlink" title="Shared File Table Entries: fork() And dup()"></a>Shared File Table Entries: fork() And dup()</h3><p>dup() call allows a process to create a new file descriptor that refers to the same underlying open file as an existing descriptor.</p><h3 id="Writing-Immediately-With-fsync"><a href="#Writing-Immediately-With-fsync" class="headerlink" title="Writing Immediately With fsync()"></a>Writing Immediately With fsync()</h3><p><strong><code>fsync(int fd)</code></strong>. When a process calls fsync() for a particular file descriptor, the file system responds by forcing all dirty (i.e., not yet written) data to disk, for the file referred to by the specified file descriptor.</p><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><p><strong><code>rename(char*old, char *new),</code></strong> call is that it is (usually) implemented as an atomic call</p><h3 id="Getting-Information-About-Files"><a href="#Getting-Information-About-Files" class="headerlink" title="Getting Information About Files"></a>Getting Information About Files</h3><p><strong><code>stat()</code></strong> or <strong><code>fstat()</code></strong></p><h3 id="Reading-Directories"><a href="#Reading-Directories" class="headerlink" title="Reading Directories"></a>Reading Directories</h3><p>opendir(), readdir(), and closedir()</p><p>readdir()得到以下结构体：<br><img src="/2019/06/21/文件系统/dirent.png"></p><h3 id="Hard-Links"><a href="#Hard-Links" class="headerlink" title="Hard Links"></a>Hard Links</h3><p><strong><code>link()</code></strong> system call takes two arguments, an old pathname and a new one; when you “link” a new file name to an old one, you essentially create another way to refer to the same file. The command-line program <code>ln</code> is used to do this</p><p>link后的两个指向相同的inode number，对于文件系统而言，对用户可见的名字不同没有关系，因为他们指向相同的内部的结构metadata，这个是根据inode number来查找的</p><p>当你删除一个文件的时候，会调用unlink()，将检查对应inode number对应的reference count（link count），并将其减少1，只有其变为0的时候，才会free掉对应的数据结构</p><h3 id="Symbolic-Links-soft-links"><a href="#Symbolic-Links-soft-links" class="headerlink" title="Symbolic Links(soft links)"></a>Symbolic Links(soft links)</h3><p>The way a symbolic link is formed is by holding the pathname of the linked-to file as the data of the<br>link file</p><h3 id="Making-And-Mounting-A-File-System"><a href="#Making-And-Mounting-A-File-System" class="headerlink" title="Making And Mounting A File System"></a>Making And Mounting A File System</h3><p><strong><code>mkfs</code></strong>：give the tool, as input, a device (such as a disk partition, e.g., /dev/sda1) and a file system type (e.g., ext3), and it simply writes an empty file system, starting with a root directory, onto that disk partition.</p><p><strong><code>mount</code></strong>完成的工作是<strong>把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里</strong>。</p><h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="VSFS-Very-Simple-File-System"><a href="#VSFS-Very-Simple-File-System" class="headerlink" title="VSFS(Very Simple File System)"></a>VSFS(Very Simple File System)</h3><h4 id="Overall-Organization"><a href="#Overall-Organization" class="headerlink" title="Overall Organization"></a>Overall Organization</h4><p><img src="/2019/06/21/文件系统/rg.png"></p><p>我们假设以4kb为一个block，现在我们假设有一个非常小的disk，只有64个block，考虑其应该有的组成<br>a)  首先必然存储数据且应该是大部分block都存储数据<br>b）对于每一个文件，都应该有一个inode<br>c）需要有一个分配结构来追踪每一个data或者inode的block是否为free，有多种实现方式，如链表，此处采用<code>bitmap</code>的方式，每一个bit为0/1表示对应的block是否被占用，此处应有两个bitmap，data和inode各一个<br>d）一个superblock， 用于存储关于这个文件系统的信息，如有多少各inode和data blocks，inode table从哪里开始等（当挂载一个文件系统的时候，首先读superblock的信息来初始化各种参数）</p><h4 id="File-Organization-The-Inode"><a href="#File-Organization-The-Inode" class="headerlink" title="File Organization: The Inode"></a>File Organization: The Inode</h4><p><strong><code>Inode</code></strong>: index node</p><p>每一个inode都会被一个数字所指代（i-number），在操作系统中，给你这个数字，你可以直接计算出在这个磁盘中对应inode的位置</p><p><img src="/2019/06/21/文件系统/nt.png"></p><p>inode有多种存储方式，如下：</p><ul><li>连续存储在文件系统中的某个区域，这样可以直接根据inode的编号计算出inode在磁盘中的位置，这也是实现文件唯一id的一个途径；（上图采用的方式）</li><li>存储在文件头部，文件唯一id = 第一个数据块的编号；</li><li>存储在目录文件中，文件唯一id = 第一个数据块的编号，在支持链接的文件系统中，文件的元数据会有多份拷贝。</li></ul><p>在inode中，几乎存储了所有关于其对应文件的信息，我们将这些信息称为<strong><code>metadata</code></strong>,</p><p>包括</p><ul><li>文件的唯一id；</li><li>文件的类型，用于区分普通文件和目录文件；</li><li>访问权限，就是大家熟知的rwxrwxrwx；</li><li>所有者信息 (uid, gid)，但这在跨系统访问时成为很大的麻烦；</li><li>文件大小；</li><li>文件访问的时间信息：创建时间、访问时间、修改时间；</li><li>链接数量 (刚才已经提到)；</li><li>一些其他信息，例如文件的第一个数据块的编号等</li></ul><p>一种inode存储的信息示例如下：</p><p><img src="/2019/06/21/文件系统/inode.png" height="75%" width="75%"></p><p>在inode中有一个重要信息是指向文件data所在block的地址的指针，一种实现方式是采用<strong><code>direct pointer</code></strong>，但是这样对于较大的文件，存储在多个不同的block中时会比较麻烦，此时一种方式时采用<strong><code>indirect pointer</code></strong>,这个指针指向一个全部存储对应的direct pointer的block，而如果还要更大的话，则可以采用<strong><code>double indirect pointer</code></strong>(即指向一个全是indirect pointer的block)，如果还要更多，可以以此类推<strong><code>triple indirect pointer</code></strong></p><h4 id="Directory-Organization"><a href="#Directory-Organization" class="headerlink" title="Directory Organization"></a>Directory Organization</h4><p>each entry has an inode number, record length (the total bytes for the name plus any left over space), string length (the actual length of the name), and finally the name of the entry.</p><p>目录同样被操作系统认为是一个文件，有对应的inode，只是inode中其类型为directory</p><h4 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free Space Management"></a>Free Space Management</h4><p>在vsfs中，用的是bitmap，还可以用链表来实现，现代操作系统中有更多的实现方式如b-tree</p><h4 id="Access-Paths-Reading-and-Writing"><a href="#Access-Paths-Reading-and-Writing" class="headerlink" title="Access Paths: Reading and Writing"></a>Access Paths: Reading and Writing</h4><p>对于一个路径，如果我们想找到对应的文件或目录的inode值，其值一般会存储在其父目录中，而<strong>/</strong>没有父目录，故而一般在unix系统中设置其inode值为2，找到父目录的inode之后，就根据指针找到其data区域，在data中找到其对应文件的入口，找到后，文件系统就获取的该文件的inode number，之后类似的重复直到找到对应文件为止。在open（）操作中，找到文件后，会把文件的inode读入，并在pre-process open-file table中分配一个fd给这个process。</p><p>打开文件后如执行read操作，则会更新inode中的存储的时间变量，然后回更新fd对应的in-memory open file table，修改文件偏移量</p><p>如果要写文件的话，要先读inode，再读bitmap，再写bitmap，分配后再写data，写完后更新inode</p><h3 id="FAT与ext2"><a href="#FAT与ext2" class="headerlink" title="FAT与ext2"></a>FAT与ext2</h3><p>断章了，见下一篇blog</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;每一个file都有一个&lt;code&gt;low-level name&lt;/code&gt;， 一般我们指&lt;strong&gt;&lt;code&gt;ino
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>IO设备与驱动</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/IO设备与驱动/</id>
    <published>2019-06-21T02:13:42.000Z</published>
    <updated>2019-06-21T13:38:21.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="System-Architecture"><a href="#System-Architecture" class="headerlink" title="System Architecture"></a>System Architecture</h2><p><img src="/2019/06/21/IO设备与驱动/361.png" width="65%" height="50%"></p><p><img src="/2019/06/21/IO设备与驱动/n362.png" width="65%" height="50%"></p><h2 id="A-Canonical-device"><a href="#A-Canonical-device" class="headerlink" title="A Canonical device"></a>A Canonical device</h2><p> <img src="/2019/06/21/IO设备与驱动/362.png" width="65%" height="50%"></p><p>硬件接口 + 内部结构</p><h2 id="A-Canonical-protocol"><a href="#A-Canonical-protocol" class="headerlink" title="A Canonical protocol"></a>A Canonical protocol</h2><p>如上图，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。</p><p>一种典型的协议如下：<br><img src="/2019/06/21/IO设备与驱动/prot.png" width="65%" height="50%"></p><p>对于第一步的while循环，我们称为<strong><code>polling the device (轮询)</code></strong>，在第二步的写数据的时候，如果有main cpu的参与,即称为是<strong><code>programmed I/O(PIO)</code></strong>, 即通过CPU执行I/O端口指令来进行数据的读写的数据交换，</p><h2 id="Lowering-CPU-Overhead-With-Interrupts"><a href="#Lowering-CPU-Overhead-With-Interrupts" class="headerlink" title="Lowering CPU Overhead With Interrupts"></a>Lowering CPU Overhead With Interrupts</h2><p>为了避免PIO模式下，cpu处于轮询状态而导致资源的浪费，可能有以下几种措施：</p><ol><li>加入中断操作（但如果device执行操作很快，加入中断反而可能是效率下降）</li><li>（hybrid，如无法确定device速度）先轮询一会，如果没结束则执行中断</li></ol><h2 id="More-Efficient-Data-Movement-With-DMA"><a href="#More-Efficient-Data-Movement-With-DMA" class="headerlink" title="More Efficient Data Movement With DMA"></a>More Efficient Data Movement With DMA</h2><p><strong><code>DMA(Direct Memory Access)</code></strong>并不负责与计算机系统外的I/O，它的出现主要是为了解决设备访问速度慢的一个缺点：试想我们希望从磁盘中读出海量的数据。</p><p>DMA设备可以看成是只执行memcpy操作的设备</p><blockquote><p>To transfer data to the device, for example, the OS would program the DMA engine by telling it where the data lives in memory, how much data to copy, and which device to send it to. At that point, the OS is done with the transfer and can proceed with other work. When the DMA is complete, the DMA controller raises an interrupt, and the OS thus knows the transfer is complete.</p><p><img src="/2019/06/21/IO设备与驱动/dma.png"></p></blockquote><h2 id="Methods-Of-Device-Interaction"><a href="#Methods-Of-Device-Interaction" class="headerlink" title="Methods Of Device Interaction"></a>Methods Of Device Interaction</h2><p>how the OS actually  communicates with the device</p><blockquote><p>来源：jyy讲义</p><ul><li>端口I/O (Port IO, PIO)，相当于是为I/O设备提供了一个单独的地址空间，通过读/写端口的方式实现设备控制。通常，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。顾名思义，我们可以通过控制寄存器实现设备控制(例如设置设备的模式等)，从数据寄存器读写数据，并且读取状态寄存器来查看设备执行命令的状态。（教材上写的是IO instruction）</li><li>内存映射I/O (Memory-Mapped I/O, MMIO)。给特定的内存地址赋予特殊的含义，从而读/写内存地址就能实现设备的访问。在PA中，显存就是通过这种方式实现的。一方面，内存映射I/O完全可以用来实现状态/控制/数据寄存器，另一方面，在设备从外部看来是一段连续数据时(例如显存)，MMIO能减少I/O指令的数量。</li></ul></blockquote><h2 id="Fitting-Into-The-OS-The-Device-Driver"><a href="#Fitting-Into-The-OS-The-Device-Driver" class="headerlink" title="Fitting Into The OS: The Device Driver"></a>Fitting Into The OS: The Device Driver</h2><p><strong><code>device driver(设备驱动程序)</code></strong>: 用于对设备进行抽象使得更加上层的部分（通常为文件系统）能够以统一的接口来访问这些设备, 设备驱动程序会将对这些接口的调用翻译成设备的指令发送给设备，并等设备完成.</p><p>设备驱动层帮助我们屏蔽了底层设备的具体实现细节(例如寄存器的含义)。同理，如果我们想创建“虚拟”设备，也是非常容易的，只需要为它编写一个驱动程序即可，实现设备的读接口。Linux系统中就有一些虚拟的设备，如<code>/dev/random</code>, <code>/dev/null</code></p><p><img src="/2019/06/21/IO设备与驱动/364.png" height="75%" width="75%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;System-Architecture&quot;&gt;&lt;a href=&quot;#System-Architecture&quot; class=&quot;headerlink&quot; title=&quot;System Architecture&quot;&gt;&lt;/a&gt;System Architecture&lt;/h2&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>随机算法</title>
    <link href="http://shelah-kuang.github.io/2019/06/19/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    <id>http://shelah-kuang.github.io/2019/06/19/随机算法/</id>
    <published>2019-06-19T07:15:49.000Z</published>
    <updated>2019-06-19T12:54:42.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>$RandomA(x):$ 对于所有A在x上的随机计算中使用的random bits的最大数量<br>$Prob_{A,x}(C)$: 某一次AA对输入xx的计算CC, 由相应的随机序列的概率决定<br>$Prob(A(x)=y)$: A 对于输入x输出y的概率<br>$Time(C)$: the time complexity of the run C of A on x</p><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><h3 id="Las-Vegas-Algorithms"><a href="#Las-Vegas-Algorithms" class="headerlink" title="Las Vegas Algorithms"></a>Las Vegas Algorithms</h3><p>要么给出问题的正确答案，要么得不到答案</p><p>$$Prob(A(x)=F(x))⩾ \frac{1}{2}$$,and $$Prob(A(x) = “?”) = 1 - Prob(A(x) = F(x)) \leqslant \dfrac{1}{2}.$$</p><h3 id="One-Sided-Error-Monte-Carlo-Algorithms"><a href="#One-Sided-Error-Monte-Carlo-Algorithms" class="headerlink" title="One-Sided-Error Monte Carlo Algorithms"></a>One-Sided-Error Monte Carlo Algorithms</h3><p>for every $x \in L$, $Prob(A(x) = 1) \geqslant \dfrac{1}{2}$, and  for every $x \notin L$, $Prob(A(x) = 0) = 1$<br>跑k次，只要有一次输出1，则其必然为1，若均为0，则出错概率小于$(1/2)^k$, (只会单向出错)</p><h3 id="Two-Sided-Error-Monte-Carlo-Algorithms"><a href="#Two-Sided-Error-Monte-Carlo-Algorithms" class="headerlink" title="Two-Sided-Error Monte Carlo Algorithms"></a>Two-Sided-Error Monte Carlo Algorithms</h3><p>$Prob(A(x)=F(x))⩾ \dfrac{1}{2}+ε$.</p><p>跑t次，输出至少出现了$\lceil t/2 \rceil$ 次的结果</p><h3 id="Unbounded-Error-Monte-Carlo-Algorithms"><a href="#Unbounded-Error-Monte-Carlo-Algorithms" class="headerlink" title="Unbounded-Error Monte Carlo Algorithms"></a>Unbounded-Error Monte Carlo Algorithms</h3><p>$Prob(A(x)=F(x)) &gt; \dfrac{1}{2}$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;$RandomA(x):$ 对于所有A在x上的随机计算中使用的random bits的最大数量&lt;br&gt;$Prob_{A,x}
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>近似算法</title>
    <link href="http://shelah-kuang.github.io/2019/06/19/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <id>http://shelah-kuang.github.io/2019/06/19/近似算法/</id>
    <published>2019-06-19T07:15:37.000Z</published>
    <updated>2019-06-19T13:47:31.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>$$ε_A(x)=\dfrac{|cost(A(x))−OptU(x)∣}{Opt_U(x)}$$</p><p>$$R_A(x)=max{OptU(x)/cost(A(x)),costA(x)/OptU(x)}.$$</p><h2 id="NPO问题分类"><a href="#NPO问题分类" class="headerlink" title="NPO问题分类"></a>NPO问题分类</h2><p><img src="/2019/06/19/近似算法/def.png" alt="def"></p><p>NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)</p><p>NPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)</p><p>NPO(III): 包含所有$U∈NPO$ 满足：</p><ul><li>对某些δ&gt;1存在多项式时间的δ−近似算法</li><li>对某些d&lt;δ不存在多项式时间的的d−近似算法</li><li>i.e.U没有PTAS</li></ul><p>NPO(IV): 包含所有$U∈NPO$满足：</p><p>满足：</p><ul><li>对某些f:N→R+,存在多项式时间的f(n)−近似算法,其中f以某个多项式函数为界<ul><li>对任意$δ∈R^+$不存在任何多项式时间的δ−近似算法<br>e.g.集合覆盖问题</li></ul></li></ul><p>NPO(V): 包含所有$U∈NPO$，满足若存在多项式时间的f(n)−近似算法，则f(n)不以任何多项式函数为界(e.g. TSP, 最大团问题)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;$$ε_A(x)=\dfrac{|cost(A(x))−OptU(x)∣}{Opt_U(x)}$$&lt;/p&gt;
&lt;p&gt;$$R_A
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>数论基础及数论算法</title>
    <link href="http://shelah-kuang.github.io/2019/06/18/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    <id>http://shelah-kuang.github.io/2019/06/18/数论基础及数论算法/</id>
    <published>2019-06-18T13:44:55.000Z</published>
    <updated>2019-06-19T14:38:14.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些基本定理"><a href="#一些基本定理" class="headerlink" title="一些基本定理"></a>一些基本定理</h2><p><strong>除法定理</strong> ： 对于任何整数a与任何正整数n，存在唯一整数q和r，满足$0 \leq r &lt; n$, 且 $a = qn +r$</p><p>$gcd(a,b) = ar+bs$</p><p>如果任意整数a，b都不为0，那么$gcd(a,b)$为a和b的线性组合集{$ax+by: x,y \in Z$}中的最小正元素</p><p>$gcd(a,0) = |a|$</p><p><strong>gcd递归定理</strong>： $gcd(a,b) = gcd (b, a\mod b)$</p><p>若x，y为满足$ax+ny=1$的整数，则a在$Z_n$中的乘法逆元是 x mod n</p><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>求解$d = gcd(a,b) = ax+by$, 算法返回值为$(d,x,y)$</p><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>$Z^*_n = {[a]_n : gcd(a,n)=1}$</p><p>$Z^*_n $的规模表示为$\phi(n)$, 且</p><p>$$\phi(n) = n \prod_{p为能整除n的素数}(1-\frac{1}{p})$$</p><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>计算满足$a_i = a\mod n_i$的a：</p><p>​    取$m_i = n / n_i$(其中$n=n_1n_2<em>…</em>n_k$)<br>​    定义$c_i = m_i(m_i^{-1} \mod n_i)$<br>​    $a = (a_1c_1+a_2c_2+..)\mod n$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些基本定理&quot;&gt;&lt;a href=&quot;#一些基本定理&quot; class=&quot;headerlink&quot; title=&quot;一些基本定理&quot;&gt;&lt;/a&gt;一些基本定理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;除法定理&lt;/strong&gt; ： 对于任何整数a与任何正整数n，存在唯一整数q和r，满足$0 
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>群论基础</title>
    <link href="http://shelah-kuang.github.io/2019/06/18/%E7%BE%A4%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://shelah-kuang.github.io/2019/06/18/群论基础/</id>
    <published>2019-06-18T07:11:04.000Z</published>
    <updated>2019-06-18T13:44:17.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考书籍：</p><ol><li><a href="http://www.phy.pku.edu.cn/~xzli/teaching.html" target="_blank" rel="noopener">群论-李新征讲义</a></li><li>Thomas Judson: Abstract Algebra - Theory and Applications, 2018.</li></ol></blockquote><h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><p> <strong><code>群</code></strong>：设𝐆是一些元素（操作）的集合，记为𝐆 = {⋯，g，⋯}，在𝐆中定义了乘运算，如果𝐆中元素对这种运算满足下面四个条件：<br>1) 封闭性：∀两个元素（操作）的乘积仍属于这类元素（操作）的集合<br>2) 结合律：对∀三个元素（操作）𝐟、𝐠、𝐡，有(𝐟𝐠)𝐡 = 𝐟(𝐠𝐡)<br>3) 有唯一单位元素 e，使得对∀𝐟 ∈ 𝐆，有𝐞𝐟 = 𝐟𝐞 = 𝐟<br>4) 对∀𝐟 ∈ 𝐆，存在且唯一存在$𝐟^{−𝟏}$属于 G，使$𝐟^−𝟏𝐟$ = $ 𝐟𝐟^{−𝟏} $ = 𝐞；<br>这时我们称𝐆是一个群，其中元素是群元，𝐞为其单位元素，$𝐟^{−𝟏}$为𝐟的逆。 </p><p><strong><code>有限群</code></strong>： 群内元素的个数称为群的阶，群阶有限时称为有限群</p><p><strong><code>Abel群</code></strong>：群内的运算可以互换（可以看出abel群的乘法表都是关于对角线对称的）</p><p><strong><code>重排定理</code></strong>：设𝐆 = {⋯，$𝐠{𝛂}$，⋯}，对∀𝐮 ∈ 𝐆，当$ 𝐠<em>𝛂 $取遍𝐆中所有元素时，$𝐮𝐠</em>𝛂$给出且仅仅一次给出𝐆中所有元素。 </p><h2 id="子群与陪集"><a href="#子群与陪集" class="headerlink" title="子群与陪集"></a>子群与陪集</h2><p><strong><code>子群</code></strong>：设 H 是群 G 的一个子集（部分元素的集合），若对群 G 相同的乘法运算，H 也构成一个群，则称 H 为 G 的子群。<br>要证明一个群为子群，只需要证明其封闭性与每个元素唯一逆即可，单位元可以通过封闭性得证，结合律必然成立 </p><p><strong><code>n 阶循环群</code></strong>：它的定义是$a^n = e$，由${a、a^2、⋯ 、a^{n−1}、a^n = e}$组成。这样的群是 Abel 群，乘法可易。</p><p><strong><code>群元的阶</code></strong>：对任意一个有限群𝐆，从中取一个元素𝐚，从𝐚出发作幂操作，总是可以构成𝐆的一个循环子群$𝐙_𝐤$的，这个𝐙𝐤等于${𝐚、𝐚^𝟐、 ⋯、𝐚^{𝐤−𝟏}、𝐚^𝐤 = 𝐞}$，这时称𝐤（满足这个性质的最小的𝐤）为群元𝐚的阶。 </p><p><strong><code>陪集</code></strong>：设𝐇是群𝐆的子群，𝐇 = {$𝐡<em>𝛂$}，由固定的𝐠 ∈ 𝐆，可生成子群𝐇的左陪集：$𝐠𝐇 = {𝐠𝐡</em>𝛂|𝐡<em>𝛂 ∈ 𝐇}$，也可生成子群𝐇的右陪集：𝐇𝐠 = {$𝐡</em>𝛂𝐠|𝐡_𝛂 ∈ 𝐇$}。</p><p><strong><code>陪集定理</code></strong>：设群𝐇是群𝐆的子群，则𝐇的两个左（或右）陪集或者完全相同，或者没有任何公共元素。 </p><p><strong><code>拉格朗日（Lagrange）定理</code></strong>：有限群子群的阶，必为群阶的因子。 </p><h2 id="类与不变子群"><a href="#类与不变子群" class="headerlink" title="类与不变子群"></a>类与不变子群</h2><p><strong><code>共轭</code></strong>：所谓共轭，指的是群𝐆中两个元素𝐟、𝐡，如果在𝐆中存在一个𝐠，使得𝐟、𝐡可以通过$𝐠𝐟𝐠^{−𝟏} = 𝐡$联系起来，则称𝐟、𝐡共轭，记为𝐟~𝐡。 </p><p><strong><code>类</code></strong>：群 G 中所有相互共轭的元素形成的集合，称为群 G 的一个类。<br>1) 一个群中的单位元素自成一类，因为对任意 f 属于 G，$fef^{−1} = e$；<br>2) Abel 群的所有元素都自成一类，因为对任意 f 属于 G，取任意 h 属于 G，$hfh^{−1} = hh^{−1}f = f$；<br>3) 设群元素 f 的阶为 m，即$f^m = e$，则与它同类的元素的阶也为 m</p><p>定理 1.4 有限群的每个类中元素的个数都是群阶的因子。 </p><p><strong><code>共轭子群</code></strong>：设 H 和 K 是群 G 的两个子群，若存在 g 属于 G，使得$𝐊 =𝐠𝐇𝐠^{−𝟏} = {𝐠𝐡𝐠^{−𝟏}|𝐡 ∈ 𝐇}$。这时，称 H 和 K 是共轭子群</p><p><strong><code>正规子群</code></strong>：设 H 是 G 的子群，如果 H 中所有元素的同类元素都属于 H，则称 H是 G 的不变子群（数学上一般称为正规子群）。</p><p>定理 1.5 设 H 是 G 的不变子群，那么对任意固定的 f 属于 G，当$h_α$取遍 H 中所有元素的时候，$fh_αf^{−1}$给出且仅仅一次给出 H 中所有元素<br>实际上，所有 Abel 群的子群都是其不变子群。因为每个元素自成一类，其同类元素自然在这个子群中</p><p>定理 1.6 不变子群的左陪集与右陪集是重合的。<br>不变子群的陪集还有另外一个更加重要的性质，就是两个（非子群的）不同陪集中元素的乘积，必为第三个陪集中的元素。这个说的是什么呢？就是H是G的不变子群，由H，可将G分解为G={g0H、g1H、g2H、…}。这样的话在这一系列的陪集中，取giH与gjH这两个陪集中的元素gihα与gjhβ相乘，结果是这样的：当giH与gjH都不是g0H时，必属于giH与gjH外的另一个陪集；当giH、gjH其中一个是g0H时，必属于giH与gjH中的另一个；giH与gjH都是g0H时，必属于g0H。</p><p><img src="/2019/06/18/群论基础/shanqun.png" alt="shanqun"></p><h2 id="同态与同构"><a href="#同态与同构" class="headerlink" title="同态与同构"></a>同态与同构</h2><p><strong><code>同构映射</code></strong>：若从群 G 到群 F 上，存在一一对应的满映射$\Phi$，且这个映射本身保持群的乘法运算规律不变，也就是说 G 中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同构，记作 G≅F。映射$\Phi$ 称为同构映射。</p><p>群 G 的两个互为共轭的子群H与K，由定义，是存在一个固定的 g 属于 G，使得对任意的hα ∈ H，都有$k_α = gh_αg^{−1} \in K$与之对应。这个对应关系是一对一的，同时单位元素对应单位元素，互逆元素对应互逆元素。所以同一个群的两个共轭子群同构。</p><p><strong><code>同态</code></strong>：设存在从群 G 到群 F 的满映射（注意，没有一对一了）𝚽，且这个映射本身保持群的乘法运算规律不变，也就是说G中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同态，记作 G~F。映射𝚽称为同态映射。 </p><p>同态核：设 G 与 F 同态，那么 G 中与 F 的单位元素对应的所有元素的集合称为同态核。</p><p> （同态核定理）设 G 与 F 同态，则有：<br>1) 同态核 H 是 G 的不变子群；<br>2) 商群 G/H 与 F 同构。 </p><p><img src="/2019/06/18/群论基础/tth1.png" alt="tth1"></p><p><img src="/2019/06/18/群论基础/天天喝.png" alt="tth2"></p><p><strong>第一同态定理</strong>:  若$\varphi:G\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\phi:G\to G/K$是规范同态函数。则存在唯一的同构函数$\eta:G/K\to\varphi(G)$使得$\varphi=\eta\phi$ </p><p>规范同态函数产生的商群与原同态函数的像同构</p><p><strong>第二同态定理</strong>: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\cap N$是$H$的正规子群，且$$H/H\cap N\cong HN/N$$<br><strong>一致性定理</strong>: 设$N$是$G$的正规子群，则$H\mapsto H/N$是包含$N$的子群$H$的集合与$G/N$的子群的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。<br><strong>第三同构定理</strong>: 设$N$和$H$是$G$的正规子群满足$N\subseteq H$,则$$G/H\cong\frac{G/N}{H/N}$$. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考书籍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.phy.pku.edu.cn/~xzli/teaching.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;群论-李新征讲义&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>问求四机考复习</title>
    <link href="http://shelah-kuang.github.io/2019/06/17/%E9%97%AE%E6%B1%82%E5%9B%9B%E6%9C%BA%E8%80%83%E5%A4%8D%E4%B9%A0/"/>
    <id>http://shelah-kuang.github.io/2019/06/17/问求四机考复习/</id>
    <published>2019-06-17T08:12:01.000Z</published>
    <updated>2019-06-21T13:39:15.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机考内容：<br>    线性规划（会提供模板、框架）<br>    KMP（会提供框架）<br>    模拟退火（会提供框架参考）<br>    Miller-Rabin素数测试</p></blockquote><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>TODO</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><blockquote><p> 板子来源：<a href="https://doowzs.com/blog/2019-02-28-simplex-cpp-template/" target="_blank" rel="noopener">https://doowzs.com/blog/2019-02-28-simplex-cpp-template/</a></p></blockquote><p>将A[0][j]设置为目标函数的参数，整个函数为<br>$$<br>f = \sum_{j = 1}^{n} A[0][j]<br>$$<br>第<em>i</em>个约束条件为<br>$$<br>\sum_{j = 1}^n A[i][j] \leq A[i][0]<br>$$<br>运行<code>simplex()</code>的结果若为-1则无解，1则无界，0则代表有解。最优解为$A[0][0]$，v[j]为各个参数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[MAXN+MAXM] = &#123;&#125;;</span><br><span class="line"><span class="keyword">double</span> v[MAXN] = &#123;&#125;;</span><br><span class="line"><span class="keyword">double</span> a[MAXM][MAXN] = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; -EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> x &gt; EPS ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  swap(id[n + r], id[c]);</span><br><span class="line">  <span class="keyword">double</span> x = -a[r][c];</span><br><span class="line">  a[r][c] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[r][i] /= x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sgn(a[i][c]) &amp;&amp; i != r) &#123;</span><br><span class="line">      x = a[i][c];</span><br><span class="line">      a[i][c] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) a[i][j] += x * a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* important: revert symbols of conditions */</span></span><br><span class="line">  <span class="comment">/* bug fixed thanks to TuoMianZiGan */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      a[i][j] *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">  <span class="comment">/* initial-simplex */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[x][i]) &gt; <span class="number">0</span>) &#123; y = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// infeasible</span></span><br><span class="line">    pivot(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* solve-simplex */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[<span class="number">0</span>][i]) &gt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">break</span>; <span class="comment">// finished</span></span><br><span class="line">    <span class="keyword">double</span> w = <span class="number">0</span>, t = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[i][x]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        t = -a[i][<span class="number">0</span>] / a[i][x];</span><br><span class="line">        <span class="keyword">if</span> (f || t &lt; w) &#123;</span><br><span class="line">          w = t, y = i, f = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!y) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="comment">// unbounded</span></span><br><span class="line">    pivot(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) v[id[i]] = a[i - n][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>TODO</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h3 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>TODO</p><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><blockquote><p>来源：<a href="https://maxmute.com/oj/" target="_blank" rel="noopener">https://maxmute.com/oj/</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000077</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;s[i] != <span class="string">'\0'</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = next[i];</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j];</span><br><span class="line">    next[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output all occurrences of `s` in `t`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_match</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">  kmp(s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; ;++i, ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'\0'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, j - i); <span class="comment">//found an entry</span></span><br><span class="line">    <span class="keyword">if</span>(t[j] == <span class="string">'\0'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j]) i = next[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><p>POJ 3461</p><h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><h3 id="算法介绍-2"><a href="#算法介绍-2" class="headerlink" title="算法介绍"></a>算法介绍</h3><blockquote><p> 模拟退火算法描述：</p><p>​         若J( Y(i+1) )&gt;= J( Y(i) )  (即移动后得到更优解)，则总是接受该移动</p><p>​         若J( Y(i+1) )&lt; J( Y(i) )  (即移动后的解比当前解要差)，则<strong>以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）</strong></p><p>　　这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。</p><p>　　根据热力学的原理，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：</p><p>　　　　<strong>P(dE) = exp( dE/(kT) )</strong></p><p>　　其中k是一个常数，exp表示自然指数，且dE&lt;0。这条公式说白了就是：温度越高，出现一次能量差为dE的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于dE总是小于0（否则就不叫退火了），因此dE/kT &lt; 0 ，所以P(dE)的函数取值范围是(0,1) 。</p><p>　　随着温度T的降低，P(dE)会逐渐降低。</p><p>　　我们将一次向较差解的移动看做一次温度跳变过程，我们以概率P(dE)来接受这样的移动。</p><p>来源：<a href="http://www.cnblogs.com/heaad/" target="_blank" rel="noopener">http://www.cnblogs.com/heaad/</a></p></blockquote><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* J(y)：在状态y时的评价函数值</span></span><br><span class="line"><span class="comment">* Y(i)：表示当前状态</span></span><br><span class="line"><span class="comment">* Y(i+1)：表示新的状态</span></span><br><span class="line"><span class="comment">* r： 用于控制降温的快慢</span></span><br><span class="line"><span class="comment">* T： 系统的温度，系统初始应该要处于一个高温的状态</span></span><br><span class="line"><span class="comment">* T_min ：温度的下限，若温度T达到T_min，则停止搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>( T &gt; T_min )</span><br><span class="line">&#123;</span><br><span class="line">　　dE = J( Y(i+<span class="number">1</span>) ) - J( Y(i) ) ; </span><br><span class="line">   <span class="keyword">if</span> ( dE &gt;=<span class="number">0</span> ) <span class="comment">//表达移动后得到更优解，则总是接受移动</span></span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　<span class="keyword">else</span>&#123;<span class="comment">// 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">exp</span>( dE/T ) &gt; random( <span class="number">0</span> , <span class="number">1</span> ) )</span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　T = r * T ; <span class="comment">//降温退火 ，0&lt;r&lt;1 。r越大，降温越慢；r越小，降温越快</span></span><br><span class="line">　　<span class="comment">/*</span></span><br><span class="line"><span class="comment">　　* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值</span></span><br><span class="line"><span class="comment">　　*/</span></span><br><span class="line">　　i ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h3><p>todo</p><h2 id="Miller-Rabin素数测试"><a href="#Miller-Rabin素数测试" class="headerlink" title="Miller-Rabin素数测试"></a>Miller-Rabin素数测试</h2><h3 id="算法介绍-3"><a href="#算法介绍-3" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>反复平方法取$a^b \mod n$</p><p><img src="/2019/06/17/问求四机考复习/反复平方法取幂.png" alt="反复平方法取幂"></p><p>利用费马小定理（如果p是一个素数,且0&lt;a&lt;p,则$a^{p-1}%p=1$.）<br>对于待测试的奇数n而言，(n-1)的二进制表示是u的二进制表示后恰好跟着t个0，所以可以先计算$2^u \mod n$,在反复平方t次来计算$2^{n-1}\mod n$.</p><p><img src="/2019/06/17/问求四机考复习/witness.png" alt="witness"></p><p><img src="/2019/06/17/问求四机考复习/rm.png" alt="miller-rabin"></p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exp_mod</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bit[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        bit[i++] = (b &amp; <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i--; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        s = s * s % m;</span><br><span class="line">        <span class="keyword">if</span>(bit[i]) s = s * a % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a,LL n)</span></span>&#123;</span><br><span class="line">    LL m = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( !(m&amp;<span class="number">1</span>) )&#123;</span><br><span class="line">        j++;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL x = exp_mod(a,m,n);</span><br><span class="line">    LL y;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span> || x == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// n may be prime</span></span><br><span class="line">    <span class="keyword">while</span>(j--)&#123;</span><br><span class="line">        y = x * x % n;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x!=<span class="number">1</span> &amp;&amp; x!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// composite</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//may be prime</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n,<span class="keyword">int</span> T=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>( !(n&amp;<span class="number">1</span>) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL a = rand() * (n<span class="number">-2</span>) / RAND_MAX + <span class="number">1</span>; <span class="comment">//[1,n+1]</span></span><br><span class="line">        <span class="keyword">if</span>( Witness(a,n) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目-3"><a href="#相关题目-3" class="headerlink" title="相关题目"></a>相关题目</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2138&amp;tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">HDU2138</a> </p><p>套板子就行了，只不过要看清题目有多个case，然后如果while+scanf来判断输入结束的话，记得加上!=EOF（<del>我才不会说我因为这个tle了很多次呢</del>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;机考内容：&lt;br&gt;    线性规划（会提供模板、框架）&lt;br&gt;    KMP（会提供框架）&lt;br&gt;    模拟退火（会提供框架参考）&lt;br&gt;    Miller-Rabin素数测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线性规划&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>社会实践常见问题答复</title>
    <link href="http://shelah-kuang.github.io/2019/05/25/%E7%A4%BE%E4%BC%9A%E5%AE%9E%E8%B7%B5%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E5%A4%8D/"/>
    <id>http://shelah-kuang.github.io/2019/05/25/社会实践常见问题答复/</id>
    <published>2019-05-25T11:45:23.000Z</published>
    <updated>2019-05-25T13:15:40.474Z</updated>
    
    <content type="html"><![CDATA[<p>（动态更新）</p><h3 id="几个重点提示："><a href="#几个重点提示：" class="headerlink" title="几个重点提示："></a>几个重点提示：</h3><p>   1.如果你想要报销的话，一定要记得<strong>留发票</strong>！！！！</p><ol start="2"><li>积极的参与各种活动，因为你要知道，你懒得参加的活动很多人也会懒得参加，这会导致你们的竞争压力并不大，这些活动的奖项或许会在之后给你意想不到的惊喜</li><li>如果你没去宣讲会或者去了没听，<strong>请务必看一遍群里的ppt</strong></li><li><strong>群文件里面那个选题类型是去年的</strong> ，仅供大家参考，今年主题为<strong>“万名学子看中国”</strong>，具体的在ppt里面，大家可以看看</li></ol><h3 id="几个常见问题的答复"><a href="#几个常见问题的答复" class="headerlink" title="几个常见问题的答复"></a>几个常见问题的答复</h3><ol><li><p>我们每个立项都有机会参加校级答辩吗？还是有个数限制？有多少名额？</p><p>答：不会 ，院内会通过一些方式（今年的具体方式还在讨论）对你们的立项进行排序，然后上传给校团委，校团委会按照一定的比例或名额给院系排序的前面一部分团队让他们去答辩，然后决定这些团队是校重点还算校一般，具体名额与比例还有时间会根据今年的文件确定（但是今年文件还没下来）.</p></li><li><p>实践人数的限制</p><p>答：实践本身是没有人数限制的，本身有限制的是毛概论文上交的时候，院级团队的论文最多只能有5人拿到成绩，校级团队则可10人拿到成绩。故而有一些<del>无良</del>的校级团队在双选会的时候会多招一些人，然后最终根据小组贡献排名前十的拿到署名（就相当于你白做了）</p></li><li><p>实践与毛概的关系</p><blockquote><p>以下回答来自咨询群实志部 章抒文的回答：</p><p>（1）毛概报告和暑期社会实践的关系：学校里绝大多数同学会用暑期社会实践结项材料中的调研报告来交毛概实践课程的作业。毛概报告不一定要用暑期社会实践的报告，只要有一篇符合毛概要求报告就行。<br>（2）一般来说，毛概报告中，校级团队可以写10个人的名字，院级团队可以写5个人的名字，做一次实践长期有效，但老师可能会有自己的要求。这个人数限制也不是绝对的，可能会有变化，老师也不一定按这个人数要求大家。<br>（3）社会实践本身不限人数，但如果交毛概，使用同一份报告的人数有限制；如果团队人数确实超过规定，老师不允许你们这么多人用同一份报告，可以写两份不一样的报告或者让其中几个人交别的报告。<br>（4）关于哪些选题可以交毛概：详见群文件里2018年的毛概实践课程要求，今年可能有细微变动。<br>（5）毛概能不能只交纪录片：根据毛概要求，必须交文字版的实践报告，纪录片可以作为你们团队的附属作品</p></blockquote></li><li><p>关于跨院系组队，跨校组队立项院系</p><p>负责人在哪个院，就立在哪个院，结项与评优也在那个院进行（如负责人分流则以分流后院系为准）</p></li><li><p>关于双选会</p><p>双选会大概就是给个地方然后各个还缺人的校级团队在那摆个摊来收人，但就我去年的感觉来看（以下全为一面之词）,完全就是一个卖方市场，大多数团队正常的核心成员已经招收的差不多了，缺的是那些专业的人才（比如你统计学软件很6或者你是走宣传口的），大多数做个调研啊什么的人才已经不太缺了（但如果你运气好说不定也能捡个漏呢）</p><p>当然除了校级团队之外，特别专项也会在那个时候进行招人，如果有想参加特别专项的同学也可以等到那个时候去加入</p></li><li><p>关于报销</p><p>校级队伍是固定的有一批经费的(去年是校级重点3000，重点提名2000，校级一般1000，以上为启动经费，后续的经费会根据大家参与的评优得到一部分奖励经费，启动经费+奖励经费为各团队最终能够报销的经费总额度)，但是院级队伍去年立项的时候是说没有经费，但是今年结项的时候，校团委给每个院级队伍追加了一笔经费可供报销，今年情况不确定，（但是<strong>保险费一定报</strong>）所以建议大家<strong>能留发票就留发票</strong>（发票请按照格式留好，具体格式见ppt或之后的实践文件），别想着给学校省钱（但是如果院内最终走发票报销方式的话，建议还是用了多少报多少，没必要特意凑发票）</p></li><li><p>关于介绍信之类的</p><p>这个只有校级队伍会提供，<del>但是你可以找校级队伍要然后自己彩印一份</del> ，不过旗子和文化衫什么就没啦，所以大家还是积极的申请校级队伍吧</p></li><li><p>实践团队的人员可以变动吗</p><p>可以，只要负责人同学不变就行，最终以结项时上交的材料为准</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（动态更新）&lt;/p&gt;
&lt;h3 id=&quot;几个重点提示：&quot;&gt;&lt;a href=&quot;#几个重点提示：&quot; class=&quot;headerlink&quot; title=&quot;几个重点提示：&quot;&gt;&lt;/a&gt;几个重点提示：&lt;/h3&gt;&lt;p&gt;   1.如果你想要报销的话，一定要记得&lt;strong&gt;留发票&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>R语言学习</title>
    <link href="http://shelah-kuang.github.io/2019/05/06/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shelah-kuang.github.io/2019/05/06/R语言学习/</id>
    <published>2019-05-06T12:39:03.000Z</published>
    <updated>2019-05-08T09:21:03.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-数据处理样例"><a href="#5-数据处理样例" class="headerlink" title="5 数据处理样例"></a>5 数据处理样例</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><code>匹配顺序：</code>圆括号括起来的表达式最优先，其次是表示重复次数的操作（即 * + { }）；再次是连接运算（即几个字符放在一起，如abc）；最后是表示可选项的运行（|）</p><p>常用的元字符</p><table><thead><tr><th><strong>符号</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符“/n”以外的任意字符</td></tr><tr><td>\</td><td>转义字符，匹配元字符时，使用“\元字符”</td></tr><tr><td>\</td><td></td><td>表示可选项，即 \</td><td>前后的表达式任选一个</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr><tr><td>(   )</td><td>提取匹配的字符串，即括号内的看成一个整体，即指定子表达式</td></tr><tr><td>[   ]</td><td>可匹配方括号内任意一个字符</td></tr><tr><td>{}</td><td>前面的字符或表达式的重复次数：{n}表示重复n次；{n,}重复n次到更多次；{n,m}表示重复n次到m次</td></tr><tr><td>*</td><td>前面的字符或表达式重复0次或更多次</td></tr><tr><td>+</td><td>前面的字符或表达式重复1次或更多次</td></tr><tr><td>？</td><td>前面的字符或表达式重复0次或1次</td></tr></tbody></table><p>特殊字符与反义</p><table><thead><tr><th><strong>符号</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>\d与 \D</td><td>匹配1位数字字符，匹配非数字字符</td></tr><tr><td>\s 与 \S</td><td>匹配空白符，匹配非空白符</td></tr><tr><td>\w 与 \W</td><td>匹配字母或数字或下划线或汉字，匹配非\w字符</td></tr><tr><td>\b 与 \B</td><td>匹配单词的开始或结束的位置，匹配非\b的位置</td></tr><tr><td>\h 与 \H</td><td>匹配水平间隔，匹配非水平间隔</td></tr><tr><td>\v 与 \V</td><td>匹配垂直间隔，匹配非垂直间隔</td></tr><tr><td>[^…]</td><td>匹配除了…以外的任意字符</td></tr></tbody></table><p>POSIX字符类</p><table><thead><tr><th><strong>符号</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>[[:lower:]]</td><td>小写字母</td></tr><tr><td>[[:upper:]]</td><td>大写字母</td></tr><tr><td>[[:alpha:]]</td><td>所有大小写字母</td></tr><tr><td>[[:digit:]]</td><td>数字0-9</td></tr><tr><td>[[:alnum:]]</td><td>字母和数字</td></tr><tr><td>[[:blank:]]</td><td>空白符：空格、制表符、换行符、中文全角空格等</td></tr><tr><td>[[:cntrl:]]</td><td>控制字符</td></tr><tr><td>[[:punct:]]</td><td>标点符号：! ” # % &amp; ’ () * + - . / : ;等</td></tr><tr><td>[[:space:]]</td><td>空格字符：空格, 制表符, 垂直制表符,   回车,   换行符,   换页符</td></tr><tr><td>[[:xdigit:]]</td><td>十六进制数字：0-9 A-F a-f</td></tr><tr><td>[[:print:]]</td><td>控制字符：[[:alpha:]], [[:punct:]],   [[:space:]]</td></tr><tr><td>[[:graph:]]</td><td>图形化字符：[[:alpha:]], [[:punct:]]</td></tr></tbody></table><p>在R语言中，如果需要匹配后替换，可以使用<code>sub()</code> 与 <code>gsub()</code>指令，如需匹配元字符，在前面加上<code>\\</code>符号。</p><h3 id="处理实例"><a href="#处理实例" class="headerlink" title="处理实例"></a>处理实例</h3><h4 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h4><p><code>readLines()</code> : 将文档转为以行为单位存放的list格式, <code>readLines(file,n=读入行数)</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = readLines(<span class="string">"d:/offline.final.trace.txt"</span>)</span><br><span class="line">length(txt)  <span class="comment"># 查看多少行数据</span></span><br><span class="line">substr(txt,<span class="number">1</span>,<span class="number">1</span>)==“<span class="comment">#” #查找注释行</span></span><br></pre></td></tr></table></figure><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><p><strong><code>strsplit(x, split, fixed= F, perl= F, useBytes= F)</code></strong></p><p>  在R里面，strsplit一般用来进行字符串分割操作，strsplit函数有<strong>x、split、fixed、perl</strong>这四个选项。<br>参数x为字符串格式向量，函数依次对向量的每个元素进行拆分<br>参数split为拆分位置的字串向量，即在哪个字串处开始拆分；该参数默认是正则表达式匹配；若设置fixed= T则表示是用普通文本匹配或者正则表达式的精确匹配。用普通文本来匹配的运算速度要快些。<br>参数perl的设置和perl的版本有关，表示可以使用perl语言里面的正则表达式。如果正则表达式过长，则可以考虑使用perl的正则来提高运算速度。<br>参数useBytes表示是否逐字节进行匹配，默认为FALSE，表示是按字符匹配而不是按字节进行匹配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;5-数据处理样例&quot;&gt;&lt;a href=&quot;#5-数据处理样例&quot; class=&quot;headerlink&quot; title=&quot;5 数据处理样例&quot;&gt;&lt;/a&gt;5 数据处理样例&lt;/h2&gt;&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UTcode_learning</title>
    <link href="http://shelah-kuang.github.io/2019/05/04/UTcode-learning/"/>
    <id>http://shelah-kuang.github.io/2019/05/04/UTcode-learning/</id>
    <published>2019-05-04T14:55:35.000Z</published>
    <updated>2019-05-09T15:28:30.406Z</updated>
    
    <content type="html"><![CDATA[<p>此篇blog为看LARG团队的<a href="https://github.com/LARG/utaustinvilla3d" target="_blank" rel="noopener">UT框架代码</a>的学习笔记，仅作学习用。</p><h1 id="Main-cc"><a href="#Main-cc" class="headerlink" title="Main.cc"></a>Main.cc</h1><p>调用流程（整个过程中利用try-catch进行了异常处理）：<br>PrintGreeting() -&gt; ReadOptions( ) -&gt; Init( ) -&gt; Run( ) -&gt; Done( ) </p><h2 id="ReadOptions（）"><a href="#ReadOptions（）" class="headerlink" title="ReadOptions（）"></a>ReadOptions（）</h2><p>设置team名 -&gt; 对argv[i]字符串匹配 (下列举部分)</p><p>默认设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">outputFile</span><span class="params">(<span class="string">""</span>)</span></span>; <span class="comment">// For optimization</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">agentType</span><span class="params">(<span class="string">"naoagent"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rsg</span><span class="params">(<span class="string">"rsg/agent/nao/nao.rsg"</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><blockquote><p>string.substr(size_t pos = 0, size_t len = npos) :<br>    从第pos（默认为0）的位置复制 len长度的子字符串</p><p>strncmp()</p></blockquote><p>–team：<br>    设置argv[i+1] 为teamname<br>–paramsfile<br>    设置inputsFile = argv[i+1]，并调用 <code>LoadParams(inputsFile)</code><br>–experimentout<br>    设置outputFile = argv[i+1]<br>–optimize<br>    设置agentType = argv[i+1]<br>– type<br>    设置rsg = “rsg/agent/nao/nao_hetero.rsg “ + string(argv[i+1])，并令agentBodyType = atoi(argv[i+1])<br>–rsg<br>    设置rsg = argv[i+1]<br>–pkgoalie \ –pkshooter \ –gazebo \ –recordstats<br>    设置agentType 为对应输入</p><h2 id="Run"><a href="#Run" class="headerlink" title="Run( )"></a>Run( )</h2><p>根据agentType的不同类型决定不同的Behavior子类</p><p>然后进入循环，执行以下操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (gLoop)</span><br><span class="line">&#123;</span><br><span class="line">    GetMessage(msg);</span><br><span class="line">    <span class="built_in">string</span> msgToServer = behavior-&gt;Think(msg);</span><br><span class="line">    <span class="comment">// To support agent sync mode</span></span><br><span class="line">    msgToServer.append(<span class="string">"(syn)"</span>);</span><br><span class="line">    PutMessage(msgToServer);</span><br><span class="line">    <span class="keyword">if</span> (mPort != <span class="number">-1</span>) &#123;</span><br><span class="line">        PutMonMessage(behavior-&gt;getMonMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage()"></a>GetMessage()</h3><p>挖坑，之后补</p><h3 id="PutMessage（）"><a href="#PutMessage（）" class="headerlink" title="PutMessage（）"></a>PutMessage（）</h3><p>挖坑，之后补</p><h1 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Behavior</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Behavior();<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Behavior();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="comment">/** called once when the initially connected to the server */</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** called for every message received from the server; should</span></span><br><span class="line"><span class="comment">        return an action string */</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">Think</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** Get message for sending to the server through the monitor port */</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getMonMessage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p></blockquote><p>在几种类型的behavior中，<code>GazeboBehavior,PKShooterBehavior,PKGoalieBehavior</code> 都以public的方式<code>NaoBehavior</code>基类，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇blog为看LARG团队的&lt;a href=&quot;https://github.com/LARG/utaustinvilla3d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UT框架代码&lt;/a&gt;的学习笔记，仅作学习用。&lt;/p&gt;
&lt;h1 id=&quot;Main-c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习-wed</title>
    <link href="http://shelah-kuang.github.io/2019/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-wed/"/>
    <id>http://shelah-kuang.github.io/2019/02/11/机器学习-wed/</id>
    <published>2019-02-11T08:04:35.000Z</published>
    <updated>2019-05-13T13:34:25.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="we"><a href="#we" class="headerlink" title="we"></a>we</h2><h4 id="监督学习：我们教计算机（supervised-learning）"><a href="#监督学习：我们教计算机（supervised-learning）" class="headerlink" title="监督学习：我们教计算机（supervised learning）"></a>监督学习：我们教计算机（supervised learning）</h4><p>给予数据集，希望得到更多的正确答案 </p><p>回归问题（regression problem）：预测连续值输出 predict continuous valued output</p><p>分类问题（classification problem）：试图预测离散值输出（例如判断恶性肿瘤与良性肿瘤）</p><h4 id="无监督学习-计算机自行学习（unsupervised-learning）"><a href="#无监督学习-计算机自行学习（unsupervised-learning）" class="headerlink" title="无监督学习: 计算机自行学习（unsupervised learning）"></a>无监督学习: 计算机自行学习（unsupervised learning）</h4><p>给了数据集，试图对其进行分类</p><p>聚类算法（clustering algorithms）：给了一个数据集，但是没有特征 ，可能把数据分成几个簇（例如给了客户数据判断细分市场）</p><p>cocktail party problem（有两个录音，每个录音都混合了两种声音，但是由于每个录音都与其中一个音源近，试图分离两种声音）</p><h2 id="week-2-单变量线性回归（univariate-linear-regreesion）"><a href="#week-2-单变量线性回归（univariate-linear-regreesion）" class="headerlink" title="week 2 单变量线性回归（univariate linear regreesion）"></a>week 2 单变量线性回归（univariate linear regreesion）</h2><p>课程中使用的符号</p><p>​    m：训练样本数量</p><pre><code>x：输入变量\特征</code></pre><p>​    y：输出</p><p>​    $x^{(i)},y^{(i)}$ : 第i个训练样本</p><p>​    h：假设函数（hypothesis）$h_\theta(x)=\theta_0+\theta_1x$</p><p>代价函数（cost function）</p><p>​    Hypothesis: $h_\theta(x)=\theta_0+\theta_1x​$</p><p>​        $\theta_i$’s: parameters of model 模型参数    </p><p> 我们想要让估计值与真实值的差最小，即(其中的1/2只是为了便于计算)</p><p>​                                $${\mathop{minimize}\limits_{\theta_0,\theta_1} \frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}$$</p><p>记${J(\theta_0,\theta_1)=\frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}​$为代价函数（cost function）（平方误差函数）</p><p>假设$\theta_0$为0，可以画出$J(\theta_1)$的图像（类似于一个碗状函数的基本形状）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;we&quot;&gt;&lt;a href=&quot;#we&quot; class=&quot;headerlink&quot; title=&quot;we&quot;&gt;&lt;/a&gt;we&lt;/h2&gt;&lt;h4 id=&quot;监督学习：我们教计算机（supervised-learning）&quot;&gt;&lt;a href=&quot;#监督学习：我们教计算机（supervise
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python学习</title>
    <link href="http://shelah-kuang.github.io/2019/01/31/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shelah-kuang.github.io/2019/01/31/python学习/</id>
    <published>2019-01-31T14:22:26.000Z</published>
    <updated>2019-01-31T14:22:26.826Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高级英语词汇 word power made easy</title>
    <link href="http://shelah-kuang.github.io/2019/01/03/%E9%AB%98%E7%BA%A7%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87-word-power-made-easy/"/>
    <id>http://shelah-kuang.github.io/2019/01/03/高级英语词汇-word-power-made-easy/</id>
    <published>2019-01-03T14:52:11.000Z</published>
    <updated>2019-01-05T15:28:51.889Z</updated>
    
    <content type="html"><![CDATA[<p>这怎么背的完啊  呜呜呜呜呜呜</p><p>我是怎样的傻才会傻到选词汇啊……</p><h1 id="PART-1"><a href="#PART-1" class="headerlink" title="PART 1"></a>PART 1</h1><h3 id="SESSION-1-3"><a href="#SESSION-1-3" class="headerlink" title="SESSION 1-3"></a>SESSION 1-3</h3><p>egoist</p><p>egotist</p><p>introvert            n.性格内向的人<br>extrovert    n. 外向；外倾者；性格外向者（等于extravert）<br>ambivert    中间性格者<br>ambidextrous    两手都善用的<br>ambidexterity    n.双手都灵活,怀二心<br>dexterous    a.灵巧的，熟练的<br>dexterity    n.纯熟，灵巧<br>perilous    adj. 危险的，冒险的<br>sinister    a.恶意的；凶兆的，不祥的<br>gauche    笨拙的，缺乏社交经验的：lacking grace<br>gaucherie    n．笨拙<br>adroit    a.熟练的，灵巧的<br>misanthrope    n.厌恶人类者<br>misogynist    n. 厌恶女人的人<br>misogamist    n.厌恶结婚的人<br>anthropo    人，人类<br>Anthropology    n. 人类学<br>philanthropist    n. 慈善家<br>gynecologist    妇科医生<br>Polygamy    n．一夫多妻制,多配偶制<br>monogamy    n.一夫一妻制<br>bigamy    n. 重婚罪，重婚<br>Polyandry    n. 一妻多夫制<br>ascetic    a.禁欲的；n.苦行者<br>Asceticism    n.禁欲主义</p><p>Quiz 1</p><p>gynecology</p><p>anthropology</p><p>philanthropy</p><p>misnthropy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这怎么背的完啊  呜呜呜呜呜呜&lt;/p&gt;
&lt;p&gt;我是怎样的傻才会傻到选词汇啊……&lt;/p&gt;
&lt;h1 id=&quot;PART-1&quot;&gt;&lt;a href=&quot;#PART-1&quot; class=&quot;headerlink&quot; title=&quot;PART 1&quot;&gt;&lt;/a&gt;PART 1&lt;/h1&gt;&lt;h3 id=&quot;SE
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
</feed>
