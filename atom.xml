<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>少年游</title>
  
  <subtitle>茫茫人海，却似荒野</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shelah-kuang.github.io/"/>
  <updated>2019-07-13T07:10:00.519Z</updated>
  <id>http://shelah-kuang.github.io/</id>
  
  <author>
    <name>kuangsl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RL7</title>
    <link href="http://shelah-kuang.github.io/2019/07/13/RL7/"/>
    <id>http://shelah-kuang.github.io/2019/07/13/RL7/</id>
    <published>2019-07-13T07:10:00.000Z</published>
    <updated>2019-07-13T07:10:00.519Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RL6</title>
    <link href="http://shelah-kuang.github.io/2019/07/13/RL6/"/>
    <id>http://shelah-kuang.github.io/2019/07/13/RL6/</id>
    <published>2019-07-13T07:09:55.000Z</published>
    <updated>2019-07-15T09:05:47.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应章节：<a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">《Reinforcement Learning: An Introduction》第二版</a>  Chap 6</p></blockquote><p><del>假装加一个TODO（）就会继续补一样</del></p><h2 id="6-1-TD-Prediction"><a href="#6-1-TD-Prediction" class="headerlink" title="6.1 TD Prediction"></a>6.1 TD Prediction</h2><h2 id="6-2-Advantages-of-TD-Prediction-Methods"><a href="#6-2-Advantages-of-TD-Prediction-Methods" class="headerlink" title="6.2 Advantages of TD Prediction Methods"></a>6.2 Advantages of TD Prediction Methods</h2><h2 id="6-3-Optimality-of-TD-0"><a href="#6-3-Optimality-of-TD-0" class="headerlink" title="6.3 Optimality of TD(0)"></a>6.3 Optimality of TD(0)</h2><h2 id="6-4-Sarsa-On-policy-TD-Control"><a href="#6-4-Sarsa-On-policy-TD-Control" class="headerlink" title="6.4 Sarsa: On-policy TD Control"></a>6.4 Sarsa: On-policy TD Control</h2><h2 id="6-5-Q-learning-Off-policy-TD-Control"><a href="#6-5-Q-learning-Off-policy-TD-Control" class="headerlink" title="6.5 Q-learning: Off-policy TD Control"></a>6.5 Q-learning: Off-policy TD Control</h2><h2 id="6-6-Expected-Sarsa"><a href="#6-6-Expected-Sarsa" class="headerlink" title="6.6 Expected Sarsa"></a>6.6 Expected Sarsa</h2><h2 id="6-7-Maximization-Bias-and-Double-Learning"><a href="#6-7-Maximization-Bias-and-Double-Learning" class="headerlink" title="6.7 Maximization Bias and Double Learning"></a>6.7 Maximization Bias and Double Learning</h2><h2 id="6-8-Games-Afterstates-and-Other-Special-Cases"><a href="#6-8-Games-Afterstates-and-Other-Special-Cases" class="headerlink" title="6.8 Games, Afterstates, and Other Special Cases"></a>6.8 Games, Afterstates, and Other Special Cases</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对应章节：&lt;a href=&quot;http://www.incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Reinforcement Learning:
      
    
    </summary>
    
      <category term="强化学习" scheme="http://shelah-kuang.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="-RL" scheme="http://shelah-kuang.github.io/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-Monte Carlo Methods</title>
    <link href="http://shelah-kuang.github.io/2019/07/13/RL5/"/>
    <id>http://shelah-kuang.github.io/2019/07/13/RL5/</id>
    <published>2019-07-13T07:09:46.000Z</published>
    <updated>2019-07-15T10:17:01.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应章节：<a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">《Reinforcement Learning: An Introduction》第二版</a>  Chap 5</p></blockquote><p>蒙特卡洛方法不需要环境的信息，只需要经验（experience—sample sequences of states, actions, and rewards from actual or simulated interaction with an environment.）</p><p>Monte Carlo methods are ways of solving the reinforcement learning problem based on averaging sample returns. To ensure that well-defined returns are available, here we define Monte Carlo methods only for episodic tasks.</p><h2 id="5-1-Monte-Carlo-Prediction"><a href="#5-1-Monte-Carlo-Prediction" class="headerlink" title="5.1 Monte Carlo Prediction"></a>5.1 Monte Carlo Prediction</h2><p>有两种方法，一种是“<strong><code>first-visit</code></strong>“,把整个片段集所有第一次访问到状态<img src="https://www.zhihu.com/equation?tex=s" alt="[公式]">时的returns做平均化处理，来估计$v_\pi(s)$的值另一种是”<strong><code>every visit</code></strong>”，把整个片段集中所有访问到s状态时的returns取平均，来估计$v_\pi(s)$的值。两种方法都有应用，下给出first-visit，在9和12章介绍every-visit</p><p><img src="/2019/07/13/RL5/51.png"></p><p>每一次返回平均值都是其本身的无偏估计，标准偏差在$\sqrt{\frac{1}{n}}$内</p><p>蒙特卡洛算法每一次运行都是独立的，也就是说他不是”bootstrap”的</p><h2 id="5-2-Monte-Carlo-Estimation-of-Action-Values"><a href="#5-2-Monte-Carlo-Estimation-of-Action-Values" class="headerlink" title="5.2 Monte Carlo Estimation of Action Values"></a>5.2 Monte Carlo Estimation of Action Values</h2><p>如何估计$q_\pi(s,a)$, 同上一小节一样也是first-visit与every-visit两种方式</p><p>不过有一个问题在于如何保证所有的action都被考虑到，这就是之前第二章提到的如何保持exploit和explore的关系的问题，称为“<strong><code>maintaining exloration</code></strong>“问题，一种解决方式是对于每一个state–action pair，都给予其一定的概率作为一个episode的起点，这样当取样次数趋于无限的时候，每一个pair的取样次数也趋于无限了，这种方式的假设称为<strong><code>exploring starts</code></strong>.<br>但是这样有一个问题就是”it cannot be relied upon in general, particularly when learning directly from actual interaction with an environment.”, 此时一种常见的策略是调整policy，使得对于一个状态，所有的action都有一定的概率发生</p><h2 id="5-3-Monte-Carlo-Control"><a href="#5-3-Monte-Carlo-Control" class="headerlink" title="5.3 Monte Carlo Control"></a>5.3 Monte Carlo Control</h2><p>蒙特卡洛方法估计最优policies的方法和DP差不多：先迭代value function使之逼近当前policy的真实value function，然后基于更新后的value function进行policy improvement，直到最终policy基本不再变化</p><p><img src="/2019/07/13/RL5/52.png"></p><p>由于我们在此处估计的是$q_\pi(s,a)$，就不需要额外的model来确定最优的action了，可以直接根据$\pi(s)=\arg \max_a q(s, a)$来确定</p><p>为了更具备实际意义，我们要考虑如何去掉infinte number of episodes 的假设 ，一种方式是设立一个极小值，当两次policy evaluation的差别小于这个值的时候，认为此次policy evaluation结束，这种方式在小规模情况下很好，但是数据规模较大时仍然会需要比较多次。另一种方式就是放弃完整的policy evaluation，类似于4.6中的value  iteration</p><p>以下算法仍然基于了exploring starts 假设</p><p><img src="/2019/07/13/RL5/53.png"></p><h2 id="5-4-Monte-Carlo-Control-without-Exploring-Starts"><a href="#5-4-Monte-Carlo-Control-without-Exploring-Starts" class="headerlink" title="5.4 Monte Carlo Control without Exploring Starts"></a>5.4 Monte Carlo Control without Exploring Starts</h2><p><strong><code>on-policy</code></strong>: 直接优化或评价目标策略</p><p>对于on-policy策略而言，对于所有的pair有$\pi(a|s) \ge \frac{\varepsilon}{|\mathcal A(s)|}$</p><p>采取第二章中提到的类似的方法，以$p= 1- \varepsilon + \frac{\varepsilon}{|\mathcal A(s)|}$的概率选取原先确定的action</p><p><img src="/2019/07/13/RL5/54.png"></p><p><del>此处省略一大段，如果有兴趣看相关证明的可以自己看书</del></p><h2 id="5-5-Off-policy-Prediction-via-Importance-Sampling"><a href="#5-5-Off-policy-Prediction-via-Importance-Sampling" class="headerlink" title="5.5 Off-policy Prediction via Importance Sampling"></a>5.5 Off-policy Prediction via Importance Sampling</h2><p>在on-policy中，由于我们需要explore所有的action，这也就导致我们在一些时候会选择非最优的情况，故而我们有了off-policy的想法</p><p><strong><code>off-policy</code></strong>: 有两个策略，一个叫行为策略 $b$（behavior policy），另一个叫做目标策略$\pi$（target policy），从behavior policy生成的episodes中学习target policy的过程，叫做off-policy learning。</p><blockquote><p>关于off-policy与on-policy的应用比较</p><p>Throughout the rest of this book we consider both on-policy and off-policy methods. On-policy methods are generally simpler and are considered first. Off-policy methods require additional concepts and notation, and because the data is due to a di↵erent policy, off-policy methods are often of greater variance and are slower to converge. On the other hand, off-policy methods are more powerful and general.They include on-policy methods as the special case in which the target and behavior policies are the same. Off-policy methods also have a variety of additional uses in applications. For example, they can often be applied to learn from data generated by a conventional non-learning controller, or from a human expert. Off-policy learning is also seen by some as key to learning multi-step predictive models of the world’s dynamics</p></blockquote><p><del>下面又是一大波我不想看的数学知识</del></p><p>TODO()<del>以后一定补</del></p><p>因此有两种方式，可以取：</p><p>一种是取平均（ordinary importance sampling）</p><p>$$V(s) = \frac{\sum_{t \in \mathcal T(s)} \rho_t G_t}{|\mathcal T(s)|}$$</p><p>另一种是加权平均（weighted average）</p><p>$$V(s) = \frac{\sum_{t \in \mathcal T(s)} \rho_t G_t}{\sum_{t \in \mathcal T(s)} \rho_t}$$</p><h2 id="5-6-Incremental-Implementation"><a href="#5-6-Incremental-Implementation" class="headerlink" title="5.6 Incremental Implementation"></a>5.6 Incremental Implementation</h2><p><img src="/2019/07/13/RL5/55.png"></p><h2 id="5-7-Off-policy-Monte-Carlo-Control"><a href="#5-7-Off-policy-Monte-Carlo-Control" class="headerlink" title="5.7 Off-policy Monte Carlo Control"></a>5.7 Off-policy Monte Carlo Control</h2><p><img src="/2019/07/13/RL5/56.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对应章节：&lt;a href=&quot;http://www.incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Reinforcement Learning:
      
    
    </summary>
    
      <category term="强化学习" scheme="http://shelah-kuang.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="-RL" scheme="http://shelah-kuang.github.io/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-Dynamic Programming</title>
    <link href="http://shelah-kuang.github.io/2019/07/13/RL4/"/>
    <id>http://shelah-kuang.github.io/2019/07/13/RL4/</id>
    <published>2019-07-13T07:09:38.000Z</published>
    <updated>2019-07-15T08:44:28.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 对应章节：<a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">《Reinforcement Learning: An Introduction》第二版</a>  Chap 4</p></blockquote><p>The key idea of DP, and of reinforcement learning generally, is <strong>the use of value functions to organize and structure the search for good policies</strong>.</p><blockquote><p>如果看完了西瓜书，感觉这一章略读就好</p></blockquote><h2 id="4-1-Policy-Evaluation-Prediction"><a href="#4-1-Policy-Evaluation-Prediction" class="headerlink" title="4.1 Policy Evaluation (Prediction)"></a>4.1 Policy Evaluation (Prediction)</h2><p>已知$\pi$, 估计value-function：</p><p><img src="/2019/07/13/RL4/41.png"></p><h2 id="4-2-Policy-Improvement"><a href="#4-2-Policy-Improvement" class="headerlink" title="4.2 Policy Improvement"></a>4.2 Policy Improvement</h2><p>通过上面的算法，我们可以计算出一个policy的value函数，那么为了更好的提升policy，我们可以在当前状态s下选择另一个动作a，之后的行为仍然按照原policy执行，如果$q_\pi(s,a) &gt; v_\pi(s)$的话，可以说明替换后的策略更好。</p><p>证明如下：<br><img src="/2019/07/13/RL4/44.png"></p><p>那么我们可以得到一种greedy的策略：</p><p><img src="/2019/07/13/RL4/45.png"></p><h2 id="4-3-Policy-Iteration"><a href="#4-3-Policy-Iteration" class="headerlink" title="4.3 Policy Iteration"></a>4.3 Policy Iteration</h2><p>利用之前的evaluation与improvement来得到最优的策略：</p><p><img src="/2019/07/13/RL4/42.png" length="80%" width="80%"></p><p>Policy iteration often converges in surprisingly few iterations</p><h2 id="4-4-Value-Iteration"><a href="#4-4-Value-Iteration" class="headerlink" title="4.4 Value Iteration"></a>4.4 Value Iteration</h2><p>由于每进行一次improvement都要进行一次评估，可能导致比较慢，所以可以考虑每进行一步就直接improvement</p><p><del>这些西瓜书都讲了，再看一遍太浪费时间了</del></p><p><img src="/2019/07/13/RL4/43.png"></p><h2 id="4-5-Asynchronous-Dynamic-Programming"><a href="#4-5-Asynchronous-Dynamic-Programming" class="headerlink" title="4.5 Asynchronous Dynamic Programming"></a>4.5 Asynchronous Dynamic Programming</h2><p>以上的DP算法 的一个缺点是需要遍历整个状态集多次，但是当状态集比较大的时候就耗时比较大了(比如举了无数次的例子的backgammon有$10^{20}$个状态)</p><p><strong><code>Asynchronous DP algorithms</code></strong> are in-place iterative DP algorithms that are not organized in terms of systematic sweeps of the state set. These algorithms update the values of states in any order whatsoever, using whatever values of other states happen to be available. The values of some states may be updated several times before the values of others are updated once. To converge correctly, however, an asynchronous algorithm must continue to update the values of all the states: it can’t ignore any state after some point in the computation. Asynchronous DP algorithms allow great flexibility in selecting states to update.</p><p><em><del>第八章有更详细的讨论，不多写了</del></em></p><h2 id="4-6-Generalized-Policy-Iteration"><a href="#4-6-Generalized-Policy-Iteration" class="headerlink" title="4.6 Generalized Policy Iteration"></a>4.6 Generalized Policy Iteration</h2><blockquote><p>Policy iteration consists of two simultaneous, interacting processes, one making the value function consistent with the current policy (policy evaluation), and the other making the policy greedy with respect to the current value function (policy improvement). In policy iteration, these two processes alternate, each completing before the other begins, but this is not really necessary. In value iteration, for example, only a single iteration of policy evaluation is performed in between each policy improvement. In asynchronous DP methods, the evaluation and improvement processes are interleaved at an even finer grain. In some cases a single state is updated in one process before returning to the other. As long as both processes continue to update all states, the ultimate result is typically the same—convergence to the optimal value function and an optimal policy.</p></blockquote><p>我们用generalized policy iteration (GPI）来表示上述两个子过程不断接触修改</p><p><img src="/2019/07/13/RL4/46.png"></p><blockquote><p><del>竞争中有合作，合作中有竞争</del></p><p>The evaluation and improvement processes in GPI can be viewed as both competing and cooperating. They compete in the sense that they pull in opposing directions. Making the policy greedy with respect to the value function typically makes the value function incorrect for the changed policy, and making the value function consistent with the policy typically causes that policy no longer to be greedy. In the long run, however, these two processes interact to find a single joint solution: the optimal value function and an optimal policy.</p><p>如下图：</p></blockquote><p><img src="/2019/07/13/RL4/47.png"></p><h2 id="4-7-Efficiency-of-Dynamic-Programming"><a href="#4-7-Efficiency-of-Dynamic-Programming" class="headerlink" title="4.7 Efficiency of Dynamic Programming"></a>4.7 Efficiency of Dynamic Programming</h2><p>如果用n和k表示状态数与动作数的话，忽略一些实现细节的情况下，复杂度为$k^n$</p><p>In practice, DP methods can be used with today’s computers to solve MDPs with millions of states</p><h2 id="4-8-Summary"><a href="#4-8-Summary" class="headerlink" title="4.8  Summary"></a>4.8  Summary</h2><p>总结了一下前面的内容，然后引出了新概念：</p><p>All of them update estimates of the values of states based on estimates of the values of successor states. That is, they update estimates on the basis of other estimates. We call this general idea <strong><code>bootstrapping</code></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 对应章节：&lt;a href=&quot;http://www.incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Reinforcement Learning
      
    
    </summary>
    
      <category term="强化学习" scheme="http://shelah-kuang.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="-RL" scheme="http://shelah-kuang.github.io/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-Finite Markov Decision Processes</title>
    <link href="http://shelah-kuang.github.io/2019/07/13/RL3/"/>
    <id>http://shelah-kuang.github.io/2019/07/13/RL3/</id>
    <published>2019-07-13T07:09:21.000Z</published>
    <updated>2019-07-15T07:05:24.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应章节：<a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">《Reinforcement Learning: An Introduction》第二版</a>  Chap 3</p></blockquote><p>感觉这一章就给了一些基础概念，看西瓜书也成啊</p><h2 id="3-1-The-Agent–Environment-Interface"><a href="#3-1-The-Agent–Environment-Interface" class="headerlink" title="3.1 The Agent–Environment Interface"></a>3.1 The Agent–Environment Interface</h2><p>The learner and decision maker is called the <strong><code>agent</code></strong>. The thing it interacts with, comprising everything outside the agent, is called the <strong><code>environment</code></strong>.</p><p><img src="/2019/07/13/RL3/31.png"></p><p>One time step later, in part as a consequence of its action, the agent receives a numerical reward, $R_{t+1}\in \textbf{R}$, and finds itself in a new state, $S_{t+1}$.</p><p>定义：$p(s’, r|s, a)= Pr{S_t=s’,R_t=r | S_{t−1}=s,A_{t−1}=a}$<br>            The function p defines the <strong><code>dynamics</code></strong> of the <strong><code>MDP</code></strong></p><p>可以看出在马尔可夫决策过程中，每一个的概率只依靠于前一次的状态于动作</p><p>类似的，可以定义以下函数：</p><p><img src="/2019/07/13/RL3/32.png" width="75%" length="75%"></p><p>The general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment.</p><p>然后举了几个简单的例子，有兴趣可以去看</p><h2 id="3-2-Goals-and-Rewards"><a href="#3-2-Goals-and-Rewards" class="headerlink" title="3.2 Goals and Rewards"></a>3.2 Goals and Rewards</h2><p>在强化学习中，agent的目标是获取最大化的奖励和。这意味着不能单单只看立即得到的眼前的奖励，而要看长远过程下的奖励之和</p><p>奖励信号更应该告诉agent最终目标，而不是其实现过程，如同下棋时，应当是当你赢时给与奖励而不是局部最优时给予，如果那样设定的话可能导致agent追求局部最优而忽略全局</p><h2 id="3-3-Returns-and-Episodes"><a href="#3-3-Returns-and-Episodes" class="headerlink" title="3.3 Returns and Episodes"></a>3.3 Returns and Episodes</h2><p>In general, we seek to maximize the <strong><code>expected return</code></strong>, where the return, denoted $G_t$, is defined as some specific function of the reward sequence. In the simplest case the return is the sum of the rewards:$G_t=R_{t+1} + R_{t+2} + R_{t+3} + · · · + R_T$ , where T is a final time step.</p><p>This approach makes sense in applications in which there is a natural notion of final time step, that is, when the agent–environment interaction breaks naturally into subsequences, which we call <strong><code>episodes</code></strong>(有时也用trials)</p><p>每一个episode都有一个终止状态，终止状态后将被重置为初始状态</p><p>Tasks with episodes of this kind are called <strong><code>episodic tasks</code></strong>（举例：下棋，走迷宫）. In episodic tasks we sometimes need to distinguish the set of all nonterminal states, denoted $S$, from the set of all states plus the terminal state, denoted $S^+$. The time of termination, $T$, is a random variable that normally varies from episode to episode</p><p>但也有些任务是一直不会终止的，我们称为<strong><code>continuing tasks</code></strong>, 这样的话我们的$G_t$将会是无限大，故而我们采取一种概念上复杂但是数学上简单的<strong><code>discount</code></strong>定义</p><p>$$G_t=R_{t+1} +\gamma R_{t+2} +\gamma^2 R_{t+3} + · · · =R_{t+1} + \gamma G_{t+1}$$</p><p>即discounting rate $0 \leq \gamma\leq 1$，决定了未来奖励的当前价值。</p><h2 id="3-4-Unified-Notation-for-Episodic-and-Continuing-Tasks"><a href="#3-4-Unified-Notation-for-Episodic-and-Continuing-Tasks" class="headerlink" title="3.4 Unified Notation for Episodic and Continuing Tasks"></a>3.4 Unified Notation for Episodic and Continuing Tasks</h2><p>在之后的介绍中，我们两种任务都会探讨，所以我们希望寻求一种能够通用的表示两种任务的记法</p><p>我们可以考虑让episode tasks 在进入终止状态后进入一个特殊的 <strong><code>absorbing state</code></strong>，在这个状态下永远只转移到自身状态并且reward永为0，如下图深色方框：<br><img src="/2019/07/13/RL3/33.png"></p><p>故而可定义$$Gt=\sum_{k=t+1}^T\gamma^{k−t−1}R_k$$，这个公式包含了$T = \infin$ or $\gamma = 1$ (but not both)的可能性.</p><h2 id="3-5-Policies-and-Value-Functions"><a href="#3-5-Policies-and-Value-Functions" class="headerlink" title="3.5 Policies and Value Functions"></a>3.5 Policies and Value Functions</h2><p><strong><code>value functions</code></strong>—functions of states (or of state–action pairs) that estimate how good it is for the agent to be in a given state (or how good it is to perform a given action in a given state).</p><p><strong><code>policy</code></strong> is a mapping from states to probabilities of selecting each possible action.</p><p>定义：</p><p>state-value function for policy : $v_\pi(s) = E_\pi(G_t | S_t = s) = E_\pi( \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} | S_t =s)$</p><p>action-value function for policy: $q_\pi(s, a) = E_\pi(G_t | S_t = s, A_t = a) = E_\pi( \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} | S_t =s, A_t = a)$</p><p>我们一般可以通过经验（大量随机实验样本的均值）来获取其估计值，（如Monte Carlo methods），但是当状态空间很大的时候，这是不现实的，那时可以将其当作参数方程，通过调参的方式来得到返回值，其精确度取决于近似方式</p><p>满足递归关系, 称为是Bellman equation for $v_\pi$, It expresses a relationship between the value of a state and the values of its successor states.<br><img src="/2019/07/13/RL3/34.png"></p><p>如果已知参数（p(s′,r|s,a),π等), 则可以视为线性方程组，对于小规模的状态集，可以直接求解，其解就是值函数</p><p>对应的backup diagram：</p><p><img src="/2019/07/13/RL3/35.png"></p><h2 id="3-6-Optimal-Policies-and-Optimal-Value-Functions"><a href="#3-6-Optimal-Policies-and-Optimal-Value-Functions" class="headerlink" title="3.6 Optimal Policies and Optimal Value Functions"></a>3.6 Optimal Policies and Optimal Value Functions</h2><p>optimal policy：$\pi_*$</p><p>optimal state-value function, denoted $v_<em>$ and defined as $v_</em>(s) = \max_\pi v_\pi(s)$</p><p>optimal action-value function, denoted $q_<em>$, and defined as $q_</em>(s,a) = max_\pi q_\pi(s,a)$</p><p>有关系： $q_<em>(s, a) = E[R_{t+1} + \gamma v_</em>(S_{t+1}) | S_t=s,A_t=a]$ .</p><p>因为$v_*$也是policy的value-function，故而其也满足贝尔曼方程的条件，称为<strong><code>Bellman optimality equation</code></strong>.</p><p>可以写作：<br><img src="/2019/07/13/RL3/36.png"></p><p>最后两行（3.18，3.19）是两种常见的不同的表达形式</p><p>对应的有：<br><img src="/2019/07/13/RL3/37.png"></p><p>对应的backup diagram为：<br><img src="/2019/07/13/RL3/38.png" width="75%"></p><p>For finite MDPs, the Bellman optimality equation for $v_{*}$ has a unique solution。如果有n个状态，那么就得到一个n个变量的n个等式，如果知道必要的参数，可以通过解非线性方程组的方式对其进行求解</p><p>解出来后：<br>If you have the optimal value function, $v_{<em>}$, then the actions that appear best after a one-step search will be optimal actions. Another way of saying this is that any policy that is greedy with respect to the optimal evaluation function $v_{</em>}$ is an optimal policy.</p><p>With $q_{<em>}$, the agent does not even have to do a one-step-ahead search: for any state s, it can simply find any action that maximizes $q_{</em>}(s, a)$.</p><p><img src="/2019/07/13/RL3/39.png" width="75%"></p><p>但是这种方式的缺点在于：我们需要精确的知道环境的动态性质且有足够的计算资源去完成所有运算，同时环境需满足马尔科夫性质</p><blockquote><p>Many different decision-making methods can be viewed as ways of approximately solving the Bellman optimality equation. For example, heuristic search methods can be viewed as expanding the right-hand side of (3.19) several times, up to some depth, forming a “tree” of possibilities, and then using a heuristic evaluation function to approximate $v_{<em>}$ at the “leaf” nodes. (Heuristic search methods such as $A^</em>$ are almost always based on the episodic case.) The methods of dynamic programming can be related even more closely to the Bellman optimality equation. Many reinforcement learning methods can be clearly understood as approximately solving the Bellman optimality equation, using actual experienced transitions in place of knowledge of the expected transitions. We consider a variety of such methods in the following chapters.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对应章节：&lt;a href=&quot;http://www.incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Reinforcement Learning:
      
    
    </summary>
    
      <category term="强化学习" scheme="http://shelah-kuang.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="-RL" scheme="http://shelah-kuang.github.io/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>博客上传pdf文件</title>
    <link href="http://shelah-kuang.github.io/2019/07/13/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0pdf%E6%96%87%E4%BB%B6/"/>
    <id>http://shelah-kuang.github.io/2019/07/13/博客上传pdf文件/</id>
    <published>2019-07-13T07:09:08.000Z</published>
    <updated>2019-07-13T07:24:25.232Z</updated>
    
    <content type="html"><![CDATA[<p>多种实现方式，以下给出<del>最无脑的</del>两种：</p><ol><li><p>可以在博客中直接预览</p><ol><li><p>下载插件</p><p><code>npm install --save hexo-pdf</code></p></li><li><p>将上传的文件存储在同名的文件夹中，然后直接引用就行了，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf  test.pdf %&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><br></p><div class="row">    <embed src="Test.pdf" width="100%" height="550" type="application/pdf"></div><p><br> </p></li></ol></li><li><p>存在一个子域名下面，如<code>shelah-kuang.github.io/docs/</code></p><p>新建一个repo，然后在setting里面将他设置为page就行了（如果选择的是matser分支，那么就直接在下面了），你可以通过<code>用户名.github.io/repo名</code>进行访问(这样进入的是你的readme以及下载整个repo的界面)，也可以直接<code>用户名.github.io/repo名/文件名</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多种实现方式，以下给出&lt;del&gt;最无脑的&lt;/del&gt;两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以在博客中直接预览&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载插件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install --save hexo-pdf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="-blog" scheme="http://shelah-kuang.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-Multi-armed Bandits</title>
    <link href="http://shelah-kuang.github.io/2019/07/03/RL2/"/>
    <id>http://shelah-kuang.github.io/2019/07/03/RL2/</id>
    <published>2019-07-03T06:20:16.000Z</published>
    <updated>2019-07-14T08:07:35.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应章节：<a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">《Reinforcement Learning: An Introduction》第二版</a>  Chap 2 </p></blockquote><p><strong>这个读书笔记建立在已经看完了西瓜书第16章的基础上，略过了很多东西</strong></p><blockquote><p>部分该章节西瓜书笔记可<a href="https://shelah-kuang.github.io/docs/RLzzh.pdf">点击</a>, <strong>因为太懒了，后面一部分的笔记还没<del>抄</del></strong></p></blockquote><p><strong><code>nonsassociative</code></strong> problem: one that does not involve learning to act in more than one situation<br><strong><code>associative</code></strong> problem:  when actions are taken in more than one situation</p><p>本章主要围绕Multi-armed Bandits（多臂老虎机问题）展开讨论，以此为例介绍几种算法</p><h2 id="2-1-A-k-armed-Bandit-Problem"><a href="#2-1-A-k-armed-Bandit-Problem" class="headerlink" title="2.1 A k-armed Bandit Problem"></a>2.1 A k-armed Bandit Problem</h2><h3 id="Problem-definition"><a href="#Problem-definition" class="headerlink" title="Problem definition"></a>Problem definition</h3><p> You are faced repeatedly with a choice among k different options, or actions. After each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. Your objective is to maximize the expected total reward over some time period</p><h3 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h3><p>第t步的动作：$A_t$, 对应奖赏$R_t$<br>对于一个动作，预期奖赏为$q_*(a) = E[R_t | A_t = a]$<br>第t步选择动作a的估计奖赏为$Q_t(a)$</p><p>选择最优：exploiting 选择非最优：exploring</p><p><em>然后就是探索与利用的关系，看西瓜书就行</em></p><h2 id="2-2-Action-value-Methods"><a href="#2-2-Action-value-Methods" class="headerlink" title="2.2 Action-value Methods"></a>2.2 Action-value Methods</h2><p>计算Q：取平均值</p><p>有多种方式求解：</p><ol><li>greedy（全利用）</li><li>$\epsilon - greedy$</li></ol><h2 id="2-3-The-10-armed-Testbed"><a href="#2-3-The-10-armed-Testbed" class="headerlink" title="2.3 The 10-armed Testbed"></a>2.3 The 10-armed Testbed</h2><p>比较了一下$\epsilon - greedy$与$greedy$的差异，优缺点以及优化看西瓜书即可</p><h2 id="2-4-Incremental-Implementation"><a href="#2-4-Incremental-Implementation" class="headerlink" title="2.4 Incremental Implementation"></a>2.4 Incremental Implementation</h2><p>如何快速更新Q估计值：<br>        $Q_{n+1} = Q_n + 1/n(R_n-Q_n)$ </p><p>上为以下公式的一种形式</p><p>$$NewEstimate\leftarrow OldEstimate + StepSize [Target − OldEstimate]$$</p><p>$[Target − OldEstimate] $被称为是估计中的$error$<br>将$StepSize$表示为$\alpha$, 更一般的，表示为$\alpha_t(a)$</p><h2 id="2-5-Tracking-a-Nonstationary-Problem"><a href="#2-5-Tracking-a-Nonstationary-Problem" class="headerlink" title="2.5 Tracking a Nonstationary Problem"></a>2.5 Tracking a Nonstationary Problem</h2><p><strong><code>stationary</code></strong>: the reward probabilities do not change over time</p><p>对于Nonstationary的问题，我们要给更多的权重给最近得到的rewards。<br>一种常见的方式是给$\alpha$设置一个常数值（展开可知$Q_{n+1} = (1-\alpha)^nQ_1+\sum_{i=1}^n\alpha(1-\alpha)^{n-i}R_i$），我们称其为<code>weighted average</code>，因为其权重和为1.有时候也称其为<code>exponential recency-weighted average</code>.</p><p>有时候让$\alpha$随时间变化而变化，用$\alpha_n(a)$第n次选择动作a时的stepsize。<br>要保证在数量足够大的情况下能够让估计值趋向于真实值，根据随机近似理论(stochastic approximation),要满足以下条件：</p><p>$$\sum_{n=1}^\infin a_n(a) = \infin \,,\sum_{n=1}^\infin a_n^2(a) &lt; \infin $$</p><p>The first condition is required to guarantee that the steps are large enough to eventually overcome any initial conditions or random fluctuations. The second condition guarantees that eventually the steps become small enough to assure convergence.</p><p>可以看出我们之前让$\alpha$为一个常数时是满足第一个条件而不满足第二个条件的，这导致其会一直变化，这也正是我们希望在Nonstationary的情况下做到的</p><p>值得说明的是，满足两个条件的参数一般都收敛的比较慢，需要仔细的调参。故而虽然在理论分析时考虑这个，但是实际应用时很少考虑这个</p><h2 id="2-6-Optimistic-Initial-Values"><a href="#2-6-Optimistic-Initial-Values" class="headerlink" title="2.6 Optimistic Initial Values"></a>2.6 Optimistic Initial Values</h2><p>之前提到的所有的方式都某种程度上依赖于初始值的估计$Q_1(a)$, 可以说这些方式都有初始值的偏差（biased by their initial estimates.）对于sample-average methods而言，只需要每个动作试一遍就可以消除这种误差了，但是对于step size为常数的方式而言，这种误差是一直存在的（虽然会不断缩小，理由可见表达式）。</p><p>初始值有时也可以被用于促进exploration，如将其初始值设定的比估计值都大，那么就可以使得会优先把所有的动作都尝试一遍，我们称呼这种为<strong><code>Optimistic Initial Values</code></strong></p><p>但这种方式不适用于nonstationary的情况，因为任务一旦变化，所有的初始值都不可能始终适用</p><h2 id="2-7-Upper-Confidence-Bound-Action-Selection"><a href="#2-7-Upper-Confidence-Bound-Action-Selection" class="headerlink" title="2.7 Upper-Confidence-Bound Action Selection"></a>2.7 Upper-Confidence-Bound Action Selection</h2><p>探索是必要的， 但是$\epsilon - greedy$并没有给出一个偏向性，使得尽可能去探索接近greedy的或者是探索次数还不够多导致并不确定的动作。所以有了<strong><code>upper confidence bound (UCB) action selection</code></strong></p><p>$$A_t = arg\,max[Q_t(a)+c\sqrt{\frac{\ln t }{N_t(a)}}]$$</p><p>其中$N_t(a)$表示动作a在第t次前被执行的次数，the number c &gt; 0 controls the degree of exploration，c可以看作是对于估计的信任程度</p><blockquote><p>UCB often performs well, as shown here, but is more difficult than “-greedy to extend beyond bandits<br>to the more general reinforcement learning settings considered in the rest of this book.<br>One difficulty is in dealing with nonstationary problems; methods more complex than those presented in Section 2.5 would be needed. Another difficulty is dealing with large state spaces, particularly when using function approximation as developed in Part II of this book. In these more advanced settings the idea of UCB action selection is usually not practical.</p></blockquote><h2 id="2-8-Gradient-Bandit-Algorithms"><a href="#2-8-Gradient-Bandit-Algorithms" class="headerlink" title="2.8 Gradient Bandit Algorithms"></a>2.8 Gradient Bandit Algorithms</h2><p>构建一个数值类型的函数$H_t(a)$使得对于每一个动作a有一定的偏向性</p><p><strong><code>soft-max distribution</code></strong>:</p><p>$$Pr{A_t = a} = \frac{e^{H_t(a)}}{\sum_{b=1}^k e^{H_t(b)}} = \pi_t(a)$$</p><p>对于第t步选择了$A_t$之后，更新各个概率为</p><p>$H_{t+1}(A_t) = H_t(A_t) + \alpha (R_t - \overline{R_t})(1-\pi_t(A_t))$  and</p><p>$H_{t+1}(a) = H_t(a) - \alpha (R_t - \overline{R_t})\pi_t(a)$ </p><p>其中$ \overline{R_t}$ 表示除去第t步之外的所有奖赏的平均值，其相当于一个baseline，如果奖赏高于这个baseline，那么对应动作$A_t$的在未来被选择的概率将增加，否则将减少</p><h2 id="2-9-Associative-Search-Contextual-Bandits"><a href="#2-9-Associative-Search-Contextual-Bandits" class="headerlink" title="2.9 Associative Search (Contextual Bandits)"></a>2.9 Associative Search (Contextual Bandits)</h2><blockquote><p>However, in a general reinforcement learning task there is more than one situation, and the goal<br>is to learn a policy: a mapping from situations to the actions that are best in those situations.</p></blockquote><blockquote><p>associative search task, so called because it involves both trial-and-error learning to search for the best actions, and association of these actions with the situations in which they are best. Associative search tasks are often now called contextual bandits in the literature.</p></blockquote><blockquote><p>Associative search tasks are intermediate between the k-armed bandit problem and the full reinforcement learning problem.If actions are allowed to affect the next situation as well as the reward, then we have the full reinforcement learning problem.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对应章节：&lt;a href=&quot;http://www.incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Reinforcement Learning:
      
    
    </summary>
    
      <category term="强化学习" scheme="http://shelah-kuang.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="-RL" scheme="http://shelah-kuang.github.io/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-介绍</title>
    <link href="http://shelah-kuang.github.io/2019/07/03/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A01/"/>
    <id>http://shelah-kuang.github.io/2019/07/03/强化学习1/</id>
    <published>2019-07-03T06:19:50.000Z</published>
    <updated>2019-07-11T09:08:10.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 对应教材：Sutton &amp; Barto’s book <a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement Learning: An Introduction (2nd Edition)</a> Chap1</p></blockquote><p>Reinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal</p><p>The <strong><code>history</code></strong> is the sequence of observations, actions, rewards<br>$$Ht = O_1, R_1, A_1, …, A_{t−1}, O_t, Rt$$</p><p><strong><code>State</code></strong> is the information used to determine what happens next, Formally, state is a function of the history:<br>$$S_t = f (H_t)$$</p><p>An RL agent may include one or more of these components:<br>    <strong><code>Policy</code></strong>: agent’s behaviour function<br>    Value function: how good is each state and/or action<br>    Model: agent’s representation of the environment</p><p>Deterministic policy: $a = π(s)$<br>Stochastic policy: $π(a|s) = P[A_t = a|S_t = s]$</p><p><strong><code>Value function</code></strong> is a prediction of future reward. Used to evaluate the goodness/badness of states</p><p>A model predicts what the environment will do next<br>    $P$ predicts the next state<br>    $R$ predicts the next (immediate) reward, e.g.<br>    $$P^a_{ss’} = P[S_{t+1} = s’| S_t = s, A_t = a]$$<br>    $$R^a_s = E [R_{t+1} | S_t = s, A_t = a]$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 对应教材：Sutton &amp;amp; Barto’s book &lt;a href=&quot;http://incompleteideas.net/book/the-book-2nd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;R
      
    
    </summary>
    
      <category term="强化学习" scheme="http://shelah-kuang.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="-RL" scheme="http://shelah-kuang.github.io/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>java学习(1)-基础语法</title>
    <link href="http://shelah-kuang.github.io/2019/06/27/java%E5%AD%A6%E4%B9%A01/"/>
    <id>http://shelah-kuang.github.io/2019/06/27/java学习1/</id>
    <published>2019-06-27T15:19:57.000Z</published>
    <updated>2019-06-27T16:04:19.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>教材：Core Java Volume I-Fundamentals (10th edition)</p></blockquote><blockquote><p>Tips:   对于有c++基础的同学而言，这一章挺简单的，建议瞟一眼跳了就行</p></blockquote><h2 id="一个简单的java程序"><a href="#一个简单的java程序" class="headerlink" title="一个简单的java程序"></a>一个简单的java程序</h2><p>源代码的文件名必须与公共类的文件名字相同，并用<code>.java</code>作为文件扩展名</p><p>java中的main函数必须是静态的</p><p>java中的所有函数都属于某个类的方法</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>与c++一致 <code>\\</code> <code>\**\</code></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 <strong>-128（-2^7）</strong>；</li><li>最大值是 <strong>127（2^7-1）</strong>；</li><li>默认值是 <strong>0</strong>；</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong>；</li><li>最大值是 <strong>32767（2^15 - 1）</strong>；</li><li>默认值是 <strong>0</strong>；</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 <strong>0</strong> ；</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li><li>默认值是 <strong>0L</strong>；</li></ul><p><strong>java 整型变量大小与平台无关（32位/64位），且不存在无符号整数类型</strong></p><p>在java7之后可以给数字字面加上下划线更加易读，如<code>1_000_000</code>表示1百万，编译器会去掉这些下划线</p><h4 id="8-16-2进制表示"><a href="#8-16-2进制表示" class="headerlink" title="8/16/2进制表示"></a>8/16/2进制表示</h4><p>十六进制<code>0x</code> 或者<code>0X</code></p><p> 八进制：前缀0（易混淆不建议使用）</p><p>二进制：从java7开始，可以用<code>0b</code>或<code>0B</code>开头表示二进制</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>float：+/- 3.40282347E+38F （有效数字6-7位）</p><p>double：+/- 1.79769313486231570E + 308 (有效数字15位)</p><p>float类型的数值有一个后缀<code>f</code>或<code>F</code>，没有后缀的浮点数值默认为double类型</p><p><code>Double.POSITIVE_INFINITY</code> 表示正无穷大， <code>Double_NEGATIVE_INFINITY</code>表示负无穷大， <code>Double.NaN</code>表示不是一个数字（但是注意不能直接用<code>==</code>来检测一个值是不是NaN，这个判断是永不成立的，应当使用<code>Double.isNaN()</code>方法）</p><h3 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h3><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出后换行：<code>System.out.println()</code><br>输出后不换行：<code>System.out.print()</code></p><h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;教材：Core Java Volume I-Fundamentals (10th edition)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips:   对于有c++基础的同学而言，这一章挺简单的，建议瞟一眼跳了就行&lt;
      
    
    </summary>
    
      <category term="coding" scheme="http://shelah-kuang.github.io/categories/coding/"/>
    
    
      <category term="-java" scheme="http://shelah-kuang.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>终端与shell</title>
    <link href="http://shelah-kuang.github.io/2019/06/22/%E7%BB%88%E7%AB%AF%E4%B8%8Eshell/"/>
    <id>http://shelah-kuang.github.io/2019/06/22/终端与shell/</id>
    <published>2019-06-22T12:59:01.000Z</published>
    <updated>2019-06-22T13:19:32.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html#Implementing-a-Shell" target="_blank" rel="noopener">参考阅读</a></p></blockquote><p>终端默认是“cooked mode”，即自带一个“行编辑器”，只有按下回车键，read系统调用才返回</p><h2 id="shell执行程序"><a href="#shell执行程序" class="headerlink" title="shell执行程序"></a>shell执行程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 管道、重定向、……</span></span><br><span class="line">  execve(...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!endswith(<span class="string">"&amp;"</span>)) &#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html#Implementing-a-Shell&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>崩溃恢复与日志</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E4%B8%8E%E6%97%A5%E5%BF%97/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/崩溃恢复与日志/</id>
    <published>2019-06-21T13:42:10.000Z</published>
    <updated>2019-06-22T12:22:00.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FSCK-The-File-System-Checker"><a href="#FSCK-The-File-System-Checker" class="headerlink" title="FSCK(The File System Checker)"></a>FSCK(The File System Checker)</h2><p>检查的对象：</p><ul><li><p>superblock: making sure the file system size is greater than the number of blocks that have been allocated</p></li><li><p>free blocks: 检查inode指向的block和inode本身的状态，确认和bitmap一致，如果不一致，选择相信inode</p></li><li><p>inode state：检查其数据是否看起来合法，如检查文件类型是否有效，如果出错则删除inode并且随之更改bitmap</p></li><li><p>inode links： 检查链接情况（遍历文件树中看link count与inode中是否一致） (没有链接的inode被移到lost+found目录中)</p></li><li><p>duplicates：checks for duplicate pointers, i.e., cases where two different inodes refer to the same block</p></li><li><p>bad blocks：A pointer is considered “bad” if it obviously points to something outside its valid range</p></li><li><p>directory checks：performs additional integrity checks on the contents of each directory, making sure that “.” and “..” are the first entries, that each inode referred to in a directory entry is allocated, and ensuring that no directory is linked to more than once in the entire hierarchy.</p></li></ul><h2 id="Journaling-write-ahead-logging"><a href="#Journaling-write-ahead-logging" class="headerlink" title="Journaling(write-ahead logging)"></a>Journaling(write-ahead logging)</h2><p>在写之前，在disk的某个确定的位置记录你要做什么，如果发生崩溃，则可以继续执行</p><ol><li><p>Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.</p></li><li><p>Checkpoint: Write the pending metadata and data updates to their final locations in the file system.</p></li></ol><p>为了节约时间，可以让前几个并发的一起写</p><ol><li>Journal write: Write the contents of the transaction (including TxB, metadata, and data) to the log; wait for these writes to complete.</li><li>Journal commit: Write the transaction commit block (containing TxE) to the log; wait for write to complete; transaction is said to be committed.</li><li>Checkpoint: Write the contents of the update (metadata and data) to their final on-disk locations.</li></ol><h4 id="Metadata-Journaling"><a href="#Metadata-Journaling" class="headerlink" title="Metadata Journaling"></a>Metadata Journaling</h4><ol><li>Data write: Write data to final location; wait for completion (the wait is optional; see below for details).</li><li>Journal metadata write: Write the begin block and metadata to the log; wait for writes to complete.</li><li>Journal commit: Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction (including data) is now committed.</li><li>Checkpoint metadata: Write the contents of the metadata update to their final locations within the file system.</li><li>Free: Later, mark the transaction free in journal superblock.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FSCK-The-File-System-Checker&quot;&gt;&lt;a href=&quot;#FSCK-The-File-System-Checker&quot; class=&quot;headerlink&quot; title=&quot;FSCK(The File System Checker)&quot;&gt;&lt;/a&gt;F
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>持久数据的可靠性</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/持久数据的可靠性/</id>
    <published>2019-06-21T13:41:53.000Z</published>
    <updated>2019-06-22T09:32:09.043Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>Redundant Array of Inexpensive Disks(RAID)</code></strong>: 独立磁盘冗余阵列，通常简称为磁盘阵列</p><p><img src="/2019/06/21/持久数据的可靠性/raid.png"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p><strong>capacity</strong>：given a set of N disks each with B blocks, how much useful capacity is available to clients of the RAID</p><p><strong>reliability</strong>：How many disk faults can the given design tolerate</p><p><strong>performance</strong></p><h2 id="RAID-0：striping"><a href="#RAID-0：striping" class="headerlink" title="RAID-0：striping"></a>RAID-0：striping</h2><p>RAID-0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 </p><p><img src="/2019/06/21/持久数据的可靠性/r0.png" height="75%" width="75%"></p><p>将每一行的block称为是一个<strong>stripe</strong></p><p>也可能是按照chunk来排列，比如一个block为4kb，如果我一个chunk取8kb，将是如下情况：</p><p><img src="/2019/06/21/持久数据的可靠性/r01.png" height="50%" width="50%"></p><h2 id="RAID-1-Mirroring"><a href="#RAID-1-Mirroring" class="headerlink" title="RAID-1:Mirroring"></a>RAID-1:Mirroring</h2><p>RAID-1 采用镜像技术,同时在阵列中产生两个完全相同的数据副本，分布在两个不同的磁盘驱动器组上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。</p><p><img src="/2019/06/21/持久数据的可靠性/r1.png" height="75%" width="75%"></p><h3 id="RAID1-0"><a href="#RAID1-0" class="headerlink" title="RAID1+0"></a>RAID1+0</h3><p><img src="/2019/06/21/持久数据的可靠性/1+0.png"></p><h3 id="RAID0-1"><a href="#RAID0-1" class="headerlink" title="RAID0+1"></a>RAID0+1</h3><p><img src="/2019/06/21/持久数据的可靠性/0+1.png"></p><h2 id="RAID-Level-4-Saving-Space-With-Parity"><a href="#RAID-Level-4-Saving-Space-With-Parity" class="headerlink" title="RAID Level 4: Saving Space With Parity"></a>RAID Level 4: Saving Space With Parity</h2><p><img src="/2019/06/21/持久数据的可靠性/r4.png" height="75%" width="75%"></p><p>对每一bit做奇偶校验存在一个专门的磁盘的对应bit上</p><p>对于sequential write，先计算出P，然后直接一次写一个stripe</p><p>对于random wirte，将面临如何一边写一边改P，对应的有两种方式：<br><strong><code>additive parity</code></strong>: 先将其余盘的所有对应的block读出来然后计算P，然后同时写对应block与P，这样的缺点是当disk比较多的时候需要大量的读次数<br><strong><code>subtractive parity</code></strong>: 就是看要覆盖的block和要写的block对应bit是否相同，如相同，则对应p不变，如不同则翻转p值，即$P_{new} = (C_{old} ⊕ C_{new}) ⊕ P_{old}$<br>在性能分析时，我们分析subtractive parity， 虽然可以并行的读data disk 但是由于parity disk只有一个，故而只能依次来进行（small-write problem），同时每个周期需要读一次写一次，故而只有r/2</p><h2 id="RAID-Level-5-Rotating-Parity"><a href="#RAID-Level-5-Rotating-Parity" class="headerlink" title="RAID Level 5: Rotating Parity"></a>RAID Level 5: Rotating Parity</h2><p><img src="/2019/06/21/持久数据的可靠性/r5.png" height="75%" width="75%"></p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>To conclude, if you strictly want performance and do not care about reliability, striping is obviously best. If, however, you want random I/O performance and reliability, mirroring is the best; the cost you pay is in lost capacity. If capacity and reliability are your main goals, then RAID-5 is the winner; the cost you pay is in small-write performance. Finally,if you are always doing sequential I/O and want to maximize capacity,RAID-5 also makes the most sense.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;code&gt;Redundant Array of Inexpensive Disks(RAID)&lt;/code&gt;&lt;/strong&gt;: 独立磁盘冗余阵列，通常简称为磁盘阵列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/06/21/持久数据的可靠性/raid.p
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>FAT与ext2</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/FAT%E4%B8%8Eext2/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/FAT与ext2/</id>
    <published>2019-06-21T13:41:38.000Z</published>
    <updated>2019-06-22T09:12:27.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本blog基本搬运jyy的讲义和slides</p></blockquote><h2 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h2><p>FAT文件系统的基本思想是使用链表管理所有的数据块。FAT文件系统把若干个连续的扇区(sector)作为一个簇(cluster)</p><p>希望表示一个文件，我们只需要知道：文件的第一块的编号,对于每一块，它下一块的编号</p><p>FAT文件系统专门在磁盘中开辟一个区域(File Allocation Table, FAT)，来存储每一块的下一块编号。除了编号之外，还有两种特殊的编号：free (0, 该块可以使用),EOF (-1, 该块代表了某个文件的末尾)</p><p>缺点是文件系统可能碎片化，不利用I/O优化，lseek需要读取大量FAT数据块</p><h2 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h2><p>与上一篇博客中的vsfs基本类似</p><p>采用bitmap进行内存管理</p><p>inode中用多个级别的索引（direct blocks、indirect blocks、double indirect…..）</p><p>目录中顺序存储文件/子目录名字 inode编号<br>inode–rec_len–name_len–file_type–name</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本blog基本搬运jyy的讲义和slides&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;FAT&quot;&gt;&lt;a href=&quot;#FAT&quot; class=&quot;headerlink&quot; title=&quot;FAT&quot;&gt;&lt;/a&gt;FAT&lt;/h2&gt;&lt;p&gt;FAT文件系统的基
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/文件系统/</id>
    <published>2019-06-21T13:41:14.000Z</published>
    <updated>2019-06-22T08:54:29.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>每一个file都有一个<code>low-level name</code>， 一般我们指<strong><code>inode number</code></strong>, </p><p><strong><code>directory</code></strong>：存储a list of pairs  (user-readable name, low-level name)</p><blockquote><p>UNIX/Linux的File System Hierarchy标准规定了文件系统目录树中各个目录的功能：</p><ul><li>/boot - 系统启动数据</li><li>/bin - 应用程序 (bash, ps, grep, …)</li><li>/dev - 设备文件</li><li>/sbin - 系统程序 (mkfs, fdisk, ifconfig, dhclient, …)</li><li>/etc - 配置文件 (= “etcetera”)</li><li>/home - 用户目录</li><li>/lib - 库文件 (libc.so, libpthread.so, …)</li><li>/media - 可移动设备 (cdrom, USB flash ,…)</li><li>/usr - 用户程序 (/usr/bin/, /usr/lib/, /usr/local/)</li><li>/var - 可变文件 (logs, snapshots, …)</li><li>/tmp - 临时文件</li></ul></blockquote><h2 id="File-System-Interface"><a href="#File-System-Interface" class="headerlink" title="File System Interface"></a>File System Interface</h2><h3 id="Creating-files"><a href="#Creating-files" class="headerlink" title="Creating files"></a>Creating files</h3><p>int fd = <strong><code>open</code></strong>(“foo”, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);</p><p>O_CREAT :creates the file  if it does not exist,<br>O_WRONLY: ensures that the file can only be written to, and,<br>O_TRUNC: if the file already exists, truncates it to a size of zero bytes thus removing any existing<br>content </p><h3 id="Reading-And-Writing-Files"><a href="#Reading-And-Writing-Files" class="headerlink" title="Reading And Writing Files"></a>Reading And Writing Files</h3><p><strong><code>cat</code></strong> :dump the contents of the file to the screen.</p><p>…(还有一些 不想抄了)</p><h3 id="Shared-File-Table-Entries-fork-And-dup"><a href="#Shared-File-Table-Entries-fork-And-dup" class="headerlink" title="Shared File Table Entries: fork() And dup()"></a>Shared File Table Entries: fork() And dup()</h3><p>dup() call allows a process to create a new file descriptor that refers to the same underlying open file as an existing descriptor.</p><h3 id="Writing-Immediately-With-fsync"><a href="#Writing-Immediately-With-fsync" class="headerlink" title="Writing Immediately With fsync()"></a>Writing Immediately With fsync()</h3><p><strong><code>fsync(int fd)</code></strong>. When a process calls fsync() for a particular file descriptor, the file system responds by forcing all dirty (i.e., not yet written) data to disk, for the file referred to by the specified file descriptor.</p><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><p><strong><code>rename(char*old, char *new),</code></strong> call is that it is (usually) implemented as an atomic call</p><h3 id="Getting-Information-About-Files"><a href="#Getting-Information-About-Files" class="headerlink" title="Getting Information About Files"></a>Getting Information About Files</h3><p><strong><code>stat()</code></strong> or <strong><code>fstat()</code></strong></p><h3 id="Reading-Directories"><a href="#Reading-Directories" class="headerlink" title="Reading Directories"></a>Reading Directories</h3><p>opendir(), readdir(), and closedir()</p><p>readdir()得到以下结构体：<br><img src="/2019/06/21/文件系统/dirent.png"></p><h3 id="Hard-Links"><a href="#Hard-Links" class="headerlink" title="Hard Links"></a>Hard Links</h3><p><strong><code>link()</code></strong> system call takes two arguments, an old pathname and a new one; when you “link” a new file name to an old one, you essentially create another way to refer to the same file. The command-line program <code>ln</code> is used to do this</p><p>link后的两个指向相同的inode number，对于文件系统而言，对用户可见的名字不同没有关系，因为他们指向相同的内部的结构metadata，这个是根据inode number来查找的</p><p>当你删除一个文件的时候，会调用unlink()，将检查对应inode number对应的reference count（link count），并将其减少1，只有其变为0的时候，才会free掉对应的数据结构</p><h3 id="Symbolic-Links-soft-links"><a href="#Symbolic-Links-soft-links" class="headerlink" title="Symbolic Links(soft links)"></a>Symbolic Links(soft links)</h3><p>The way a symbolic link is formed is by holding the pathname of the linked-to file as the data of the<br>link file</p><h3 id="Making-And-Mounting-A-File-System"><a href="#Making-And-Mounting-A-File-System" class="headerlink" title="Making And Mounting A File System"></a>Making And Mounting A File System</h3><p><strong><code>mkfs</code></strong>：give the tool, as input, a device (such as a disk partition, e.g., /dev/sda1) and a file system type (e.g., ext3), and it simply writes an empty file system, starting with a root directory, onto that disk partition.</p><p><strong><code>mount</code></strong>完成的工作是<strong>把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里</strong>。</p><h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="VSFS-Very-Simple-File-System"><a href="#VSFS-Very-Simple-File-System" class="headerlink" title="VSFS(Very Simple File System)"></a>VSFS(Very Simple File System)</h3><h4 id="Overall-Organization"><a href="#Overall-Organization" class="headerlink" title="Overall Organization"></a>Overall Organization</h4><p><img src="/2019/06/21/文件系统/rg.png"></p><p>我们假设以4kb为一个block，现在我们假设有一个非常小的disk，只有64个block，考虑其应该有的组成<br>a)  首先必然存储数据且应该是大部分block都存储数据<br>b）对于每一个文件，都应该有一个inode<br>c）需要有一个分配结构来追踪每一个data或者inode的block是否为free，有多种实现方式，如链表，此处采用<code>bitmap</code>的方式，每一个bit为0/1表示对应的block是否被占用，此处应有两个bitmap，data和inode各一个<br>d）一个superblock， 用于存储关于这个文件系统的信息，如有多少各inode和data blocks，inode table从哪里开始等（当挂载一个文件系统的时候，首先读superblock的信息来初始化各种参数）</p><h4 id="File-Organization-The-Inode"><a href="#File-Organization-The-Inode" class="headerlink" title="File Organization: The Inode"></a>File Organization: The Inode</h4><p><strong><code>Inode</code></strong>: index node</p><p>每一个inode都会被一个数字所指代（i-number），在操作系统中，给你这个数字，你可以直接计算出在这个磁盘中对应inode的位置</p><p><img src="/2019/06/21/文件系统/nt.png"></p><p>inode有多种存储方式，如下：</p><ul><li>连续存储在文件系统中的某个区域，这样可以直接根据inode的编号计算出inode在磁盘中的位置，这也是实现文件唯一id的一个途径；（上图采用的方式）</li><li>存储在文件头部，文件唯一id = 第一个数据块的编号；</li><li>存储在目录文件中，文件唯一id = 第一个数据块的编号，在支持链接的文件系统中，文件的元数据会有多份拷贝。</li></ul><p>在inode中，几乎存储了所有关于其对应文件的信息，我们将这些信息称为<strong><code>metadata</code></strong>,</p><p>包括</p><ul><li>文件的唯一id；</li><li>文件的类型，用于区分普通文件和目录文件；</li><li>访问权限，就是大家熟知的rwxrwxrwx；</li><li>所有者信息 (uid, gid)，但这在跨系统访问时成为很大的麻烦；</li><li>文件大小；</li><li>文件访问的时间信息：创建时间、访问时间、修改时间；</li><li>链接数量 (刚才已经提到)；</li><li>一些其他信息，例如文件的第一个数据块的编号等</li></ul><p>一种inode存储的信息示例如下：</p><p><img src="/2019/06/21/文件系统/inode.png" height="75%" width="75%"></p><p>在inode中有一个重要信息是指向文件data所在block的地址的指针，一种实现方式是采用<strong><code>direct pointer</code></strong>，但是这样对于较大的文件，存储在多个不同的block中时会比较麻烦，此时一种方式时采用<strong><code>indirect pointer</code></strong>,这个指针指向一个全部存储对应的direct pointer的block，而如果还要更大的话，则可以采用<strong><code>double indirect pointer</code></strong>(即指向一个全是indirect pointer的block)，如果还要更多，可以以此类推<strong><code>triple indirect pointer</code></strong></p><h4 id="Directory-Organization"><a href="#Directory-Organization" class="headerlink" title="Directory Organization"></a>Directory Organization</h4><p>each entry has an inode number, record length (the total bytes for the name plus any left over space), string length (the actual length of the name), and finally the name of the entry.</p><p>目录同样被操作系统认为是一个文件，有对应的inode，只是inode中其类型为directory</p><h4 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free Space Management"></a>Free Space Management</h4><p>在vsfs中，用的是bitmap，还可以用链表来实现，现代操作系统中有更多的实现方式如b-tree</p><h4 id="Access-Paths-Reading-and-Writing"><a href="#Access-Paths-Reading-and-Writing" class="headerlink" title="Access Paths: Reading and Writing"></a>Access Paths: Reading and Writing</h4><p>对于一个路径，如果我们想找到对应的文件或目录的inode值，其值一般会存储在其父目录中，而<strong>/</strong>没有父目录，故而一般在unix系统中设置其inode值为2，找到父目录的inode之后，就根据指针找到其data区域，在data中找到其对应文件的入口，找到后，文件系统就获取的该文件的inode number，之后类似的重复直到找到对应文件为止。在open（）操作中，找到文件后，会把文件的inode读入，并在pre-process open-file table中分配一个fd给这个process。</p><p>打开文件后如执行read操作，则会更新inode中的存储的时间变量，然后回更新fd对应的in-memory open file table，修改文件偏移量</p><p>如果要写文件的话，要先读inode，再读bitmap，再写bitmap，分配后再写data，写完后更新inode</p><h3 id="FAT与ext2"><a href="#FAT与ext2" class="headerlink" title="FAT与ext2"></a>FAT与ext2</h3><p>断章了，见下一篇blog</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;每一个file都有一个&lt;code&gt;low-level name&lt;/code&gt;， 一般我们指&lt;strong&gt;&lt;code&gt;ino
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>IO设备与驱动</title>
    <link href="http://shelah-kuang.github.io/2019/06/21/IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8/"/>
    <id>http://shelah-kuang.github.io/2019/06/21/IO设备与驱动/</id>
    <published>2019-06-21T02:13:42.000Z</published>
    <updated>2019-06-21T13:38:21.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="System-Architecture"><a href="#System-Architecture" class="headerlink" title="System Architecture"></a>System Architecture</h2><p><img src="/2019/06/21/IO设备与驱动/361.png" width="65%" height="50%"></p><p><img src="/2019/06/21/IO设备与驱动/n362.png" width="65%" height="50%"></p><h2 id="A-Canonical-device"><a href="#A-Canonical-device" class="headerlink" title="A Canonical device"></a>A Canonical device</h2><p> <img src="/2019/06/21/IO设备与驱动/362.png" width="65%" height="50%"></p><p>硬件接口 + 内部结构</p><h2 id="A-Canonical-protocol"><a href="#A-Canonical-protocol" class="headerlink" title="A Canonical protocol"></a>A Canonical protocol</h2><p>如上图，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。</p><p>一种典型的协议如下：<br><img src="/2019/06/21/IO设备与驱动/prot.png" width="65%" height="50%"></p><p>对于第一步的while循环，我们称为<strong><code>polling the device (轮询)</code></strong>，在第二步的写数据的时候，如果有main cpu的参与,即称为是<strong><code>programmed I/O(PIO)</code></strong>, 即通过CPU执行I/O端口指令来进行数据的读写的数据交换，</p><h2 id="Lowering-CPU-Overhead-With-Interrupts"><a href="#Lowering-CPU-Overhead-With-Interrupts" class="headerlink" title="Lowering CPU Overhead With Interrupts"></a>Lowering CPU Overhead With Interrupts</h2><p>为了避免PIO模式下，cpu处于轮询状态而导致资源的浪费，可能有以下几种措施：</p><ol><li>加入中断操作（但如果device执行操作很快，加入中断反而可能是效率下降）</li><li>（hybrid，如无法确定device速度）先轮询一会，如果没结束则执行中断</li></ol><h2 id="More-Efficient-Data-Movement-With-DMA"><a href="#More-Efficient-Data-Movement-With-DMA" class="headerlink" title="More Efficient Data Movement With DMA"></a>More Efficient Data Movement With DMA</h2><p><strong><code>DMA(Direct Memory Access)</code></strong>并不负责与计算机系统外的I/O，它的出现主要是为了解决设备访问速度慢的一个缺点：试想我们希望从磁盘中读出海量的数据。</p><p>DMA设备可以看成是只执行memcpy操作的设备</p><blockquote><p>To transfer data to the device, for example, the OS would program the DMA engine by telling it where the data lives in memory, how much data to copy, and which device to send it to. At that point, the OS is done with the transfer and can proceed with other work. When the DMA is complete, the DMA controller raises an interrupt, and the OS thus knows the transfer is complete.</p><p><img src="/2019/06/21/IO设备与驱动/dma.png"></p></blockquote><h2 id="Methods-Of-Device-Interaction"><a href="#Methods-Of-Device-Interaction" class="headerlink" title="Methods Of Device Interaction"></a>Methods Of Device Interaction</h2><p>how the OS actually  communicates with the device</p><blockquote><p>来源：jyy讲义</p><ul><li>端口I/O (Port IO, PIO)，相当于是为I/O设备提供了一个单独的地址空间，通过读/写端口的方式实现设备控制。通常，一个I/O设备的寄存器分为三类：状态寄存器、控制寄存器、数据寄存器。顾名思义，我们可以通过控制寄存器实现设备控制(例如设置设备的模式等)，从数据寄存器读写数据，并且读取状态寄存器来查看设备执行命令的状态。（教材上写的是IO instruction）</li><li>内存映射I/O (Memory-Mapped I/O, MMIO)。给特定的内存地址赋予特殊的含义，从而读/写内存地址就能实现设备的访问。在PA中，显存就是通过这种方式实现的。一方面，内存映射I/O完全可以用来实现状态/控制/数据寄存器，另一方面，在设备从外部看来是一段连续数据时(例如显存)，MMIO能减少I/O指令的数量。</li></ul></blockquote><h2 id="Fitting-Into-The-OS-The-Device-Driver"><a href="#Fitting-Into-The-OS-The-Device-Driver" class="headerlink" title="Fitting Into The OS: The Device Driver"></a>Fitting Into The OS: The Device Driver</h2><p><strong><code>device driver(设备驱动程序)</code></strong>: 用于对设备进行抽象使得更加上层的部分（通常为文件系统）能够以统一的接口来访问这些设备, 设备驱动程序会将对这些接口的调用翻译成设备的指令发送给设备，并等设备完成.</p><p>设备驱动层帮助我们屏蔽了底层设备的具体实现细节(例如寄存器的含义)。同理，如果我们想创建“虚拟”设备，也是非常容易的，只需要为它编写一个驱动程序即可，实现设备的读接口。Linux系统中就有一些虚拟的设备，如<code>/dev/random</code>, <code>/dev/null</code></p><p><img src="/2019/06/21/IO设备与驱动/364.png" height="75%" width="75%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;System-Architecture&quot;&gt;&lt;a href=&quot;#System-Architecture&quot; class=&quot;headerlink&quot; title=&quot;System Architecture&quot;&gt;&lt;/a&gt;System Architecture&lt;/h2&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="OS" scheme="http://shelah-kuang.github.io/categories/OS/"/>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>随机算法</title>
    <link href="http://shelah-kuang.github.io/2019/06/19/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    <id>http://shelah-kuang.github.io/2019/06/19/随机算法/</id>
    <published>2019-06-19T07:15:49.000Z</published>
    <updated>2019-06-19T12:54:42.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>$RandomA(x):$ 对于所有A在x上的随机计算中使用的random bits的最大数量<br>$Prob_{A,x}(C)$: 某一次AA对输入xx的计算CC, 由相应的随机序列的概率决定<br>$Prob(A(x)=y)$: A 对于输入x输出y的概率<br>$Time(C)$: the time complexity of the run C of A on x</p><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><h3 id="Las-Vegas-Algorithms"><a href="#Las-Vegas-Algorithms" class="headerlink" title="Las Vegas Algorithms"></a>Las Vegas Algorithms</h3><p>要么给出问题的正确答案，要么得不到答案</p><p>$$Prob(A(x)=F(x))⩾ \frac{1}{2}$$,and $$Prob(A(x) = “?”) = 1 - Prob(A(x) = F(x)) \leqslant \dfrac{1}{2}.$$</p><h3 id="One-Sided-Error-Monte-Carlo-Algorithms"><a href="#One-Sided-Error-Monte-Carlo-Algorithms" class="headerlink" title="One-Sided-Error Monte Carlo Algorithms"></a>One-Sided-Error Monte Carlo Algorithms</h3><p>for every $x \in L$, $Prob(A(x) = 1) \geqslant \dfrac{1}{2}$, and  for every $x \notin L$, $Prob(A(x) = 0) = 1$<br>跑k次，只要有一次输出1，则其必然为1，若均为0，则出错概率小于$(1/2)^k$, (只会单向出错)</p><h3 id="Two-Sided-Error-Monte-Carlo-Algorithms"><a href="#Two-Sided-Error-Monte-Carlo-Algorithms" class="headerlink" title="Two-Sided-Error Monte Carlo Algorithms"></a>Two-Sided-Error Monte Carlo Algorithms</h3><p>$Prob(A(x)=F(x))⩾ \dfrac{1}{2}+ε$.</p><p>跑t次，输出至少出现了$\lceil t/2 \rceil$ 次的结果</p><h3 id="Unbounded-Error-Monte-Carlo-Algorithms"><a href="#Unbounded-Error-Monte-Carlo-Algorithms" class="headerlink" title="Unbounded-Error Monte Carlo Algorithms"></a>Unbounded-Error Monte Carlo Algorithms</h3><p>$Prob(A(x)=F(x)) &gt; \dfrac{1}{2}$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;$RandomA(x):$ 对于所有A在x上的随机计算中使用的random bits的最大数量&lt;br&gt;$Prob_{A,x}
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>近似算法</title>
    <link href="http://shelah-kuang.github.io/2019/06/19/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <id>http://shelah-kuang.github.io/2019/06/19/近似算法/</id>
    <published>2019-06-19T07:15:37.000Z</published>
    <updated>2019-06-19T13:47:31.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>$$ε_A(x)=\dfrac{|cost(A(x))−OptU(x)∣}{Opt_U(x)}$$</p><p>$$R_A(x)=max{OptU(x)/cost(A(x)),costA(x)/OptU(x)}.$$</p><h2 id="NPO问题分类"><a href="#NPO问题分类" class="headerlink" title="NPO问题分类"></a>NPO问题分类</h2><p><img src="/2019/06/19/近似算法/def.png" alt="def"></p><p>NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)</p><p>NPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)</p><p>NPO(III): 包含所有$U∈NPO$ 满足：</p><ul><li>对某些δ&gt;1存在多项式时间的δ−近似算法</li><li>对某些d&lt;δ不存在多项式时间的的d−近似算法</li><li>i.e.U没有PTAS</li></ul><p>NPO(IV): 包含所有$U∈NPO$满足：</p><p>满足：</p><ul><li>对某些f:N→R+,存在多项式时间的f(n)−近似算法,其中f以某个多项式函数为界<ul><li>对任意$δ∈R^+$不存在任何多项式时间的δ−近似算法<br>e.g.集合覆盖问题</li></ul></li></ul><p>NPO(V): 包含所有$U∈NPO$，满足若存在多项式时间的f(n)−近似算法，则f(n)不以任何多项式函数为界(e.g. TSP, 最大团问题)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;$$ε_A(x)=\dfrac{|cost(A(x))−OptU(x)∣}{Opt_U(x)}$$&lt;/p&gt;
&lt;p&gt;$$R_A
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>数论基础及数论算法</title>
    <link href="http://shelah-kuang.github.io/2019/06/18/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    <id>http://shelah-kuang.github.io/2019/06/18/数论基础及数论算法/</id>
    <published>2019-06-18T13:44:55.000Z</published>
    <updated>2019-06-19T14:38:14.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些基本定理"><a href="#一些基本定理" class="headerlink" title="一些基本定理"></a>一些基本定理</h2><p><strong>除法定理</strong> ： 对于任何整数a与任何正整数n，存在唯一整数q和r，满足$0 \leq r &lt; n$, 且 $a = qn +r$</p><p>$gcd(a,b) = ar+bs$</p><p>如果任意整数a，b都不为0，那么$gcd(a,b)$为a和b的线性组合集{$ax+by: x,y \in Z$}中的最小正元素</p><p>$gcd(a,0) = |a|$</p><p><strong>gcd递归定理</strong>： $gcd(a,b) = gcd (b, a\mod b)$</p><p>若x，y为满足$ax+ny=1$的整数，则a在$Z_n$中的乘法逆元是 x mod n</p><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>求解$d = gcd(a,b) = ax+by$, 算法返回值为$(d,x,y)$</p><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>$Z^*_n = {[a]_n : gcd(a,n)=1}$</p><p>$Z^*_n $的规模表示为$\phi(n)$, 且</p><p>$$\phi(n) = n \prod_{p为能整除n的素数}(1-\frac{1}{p})$$</p><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>计算满足$a_i = a\mod n_i$的a：</p><p>​    取$m_i = n / n_i$(其中$n=n_1n_2<em>…</em>n_k$)<br>​    定义$c_i = m_i(m_i^{-1} \mod n_i)$<br>​    $a = (a_1c_1+a_2c_2+..)\mod n$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些基本定理&quot;&gt;&lt;a href=&quot;#一些基本定理&quot; class=&quot;headerlink&quot; title=&quot;一些基本定理&quot;&gt;&lt;/a&gt;一些基本定理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;除法定理&lt;/strong&gt; ： 对于任何整数a与任何正整数n，存在唯一整数q和r，满足$0 
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>群论基础</title>
    <link href="http://shelah-kuang.github.io/2019/06/18/%E7%BE%A4%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://shelah-kuang.github.io/2019/06/18/群论基础/</id>
    <published>2019-06-18T07:11:04.000Z</published>
    <updated>2019-06-18T13:44:17.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考书籍：</p><ol><li><a href="http://www.phy.pku.edu.cn/~xzli/teaching.html" target="_blank" rel="noopener">群论-李新征讲义</a></li><li>Thomas Judson: Abstract Algebra - Theory and Applications, 2018.</li></ol></blockquote><h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><p> <strong><code>群</code></strong>：设𝐆是一些元素（操作）的集合，记为𝐆 = {⋯，g，⋯}，在𝐆中定义了乘运算，如果𝐆中元素对这种运算满足下面四个条件：<br>1) 封闭性：∀两个元素（操作）的乘积仍属于这类元素（操作）的集合<br>2) 结合律：对∀三个元素（操作）𝐟、𝐠、𝐡，有(𝐟𝐠)𝐡 = 𝐟(𝐠𝐡)<br>3) 有唯一单位元素 e，使得对∀𝐟 ∈ 𝐆，有𝐞𝐟 = 𝐟𝐞 = 𝐟<br>4) 对∀𝐟 ∈ 𝐆，存在且唯一存在$𝐟^{−𝟏}$属于 G，使$𝐟^−𝟏𝐟$ = $ 𝐟𝐟^{−𝟏} $ = 𝐞；<br>这时我们称𝐆是一个群，其中元素是群元，𝐞为其单位元素，$𝐟^{−𝟏}$为𝐟的逆。 </p><p><strong><code>有限群</code></strong>： 群内元素的个数称为群的阶，群阶有限时称为有限群</p><p><strong><code>Abel群</code></strong>：群内的运算可以互换（可以看出abel群的乘法表都是关于对角线对称的）</p><p><strong><code>重排定理</code></strong>：设𝐆 = {⋯，$𝐠{𝛂}$，⋯}，对∀𝐮 ∈ 𝐆，当$ 𝐠<em>𝛂 $取遍𝐆中所有元素时，$𝐮𝐠</em>𝛂$给出且仅仅一次给出𝐆中所有元素。 </p><h2 id="子群与陪集"><a href="#子群与陪集" class="headerlink" title="子群与陪集"></a>子群与陪集</h2><p><strong><code>子群</code></strong>：设 H 是群 G 的一个子集（部分元素的集合），若对群 G 相同的乘法运算，H 也构成一个群，则称 H 为 G 的子群。<br>要证明一个群为子群，只需要证明其封闭性与每个元素唯一逆即可，单位元可以通过封闭性得证，结合律必然成立 </p><p><strong><code>n 阶循环群</code></strong>：它的定义是$a^n = e$，由${a、a^2、⋯ 、a^{n−1}、a^n = e}$组成。这样的群是 Abel 群，乘法可易。</p><p><strong><code>群元的阶</code></strong>：对任意一个有限群𝐆，从中取一个元素𝐚，从𝐚出发作幂操作，总是可以构成𝐆的一个循环子群$𝐙_𝐤$的，这个𝐙𝐤等于${𝐚、𝐚^𝟐、 ⋯、𝐚^{𝐤−𝟏}、𝐚^𝐤 = 𝐞}$，这时称𝐤（满足这个性质的最小的𝐤）为群元𝐚的阶。 </p><p><strong><code>陪集</code></strong>：设𝐇是群𝐆的子群，𝐇 = {$𝐡<em>𝛂$}，由固定的𝐠 ∈ 𝐆，可生成子群𝐇的左陪集：$𝐠𝐇 = {𝐠𝐡</em>𝛂|𝐡<em>𝛂 ∈ 𝐇}$，也可生成子群𝐇的右陪集：𝐇𝐠 = {$𝐡</em>𝛂𝐠|𝐡_𝛂 ∈ 𝐇$}。</p><p><strong><code>陪集定理</code></strong>：设群𝐇是群𝐆的子群，则𝐇的两个左（或右）陪集或者完全相同，或者没有任何公共元素。 </p><p><strong><code>拉格朗日（Lagrange）定理</code></strong>：有限群子群的阶，必为群阶的因子。 </p><h2 id="类与不变子群"><a href="#类与不变子群" class="headerlink" title="类与不变子群"></a>类与不变子群</h2><p><strong><code>共轭</code></strong>：所谓共轭，指的是群𝐆中两个元素𝐟、𝐡，如果在𝐆中存在一个𝐠，使得𝐟、𝐡可以通过$𝐠𝐟𝐠^{−𝟏} = 𝐡$联系起来，则称𝐟、𝐡共轭，记为𝐟~𝐡。 </p><p><strong><code>类</code></strong>：群 G 中所有相互共轭的元素形成的集合，称为群 G 的一个类。<br>1) 一个群中的单位元素自成一类，因为对任意 f 属于 G，$fef^{−1} = e$；<br>2) Abel 群的所有元素都自成一类，因为对任意 f 属于 G，取任意 h 属于 G，$hfh^{−1} = hh^{−1}f = f$；<br>3) 设群元素 f 的阶为 m，即$f^m = e$，则与它同类的元素的阶也为 m</p><p>定理 1.4 有限群的每个类中元素的个数都是群阶的因子。 </p><p><strong><code>共轭子群</code></strong>：设 H 和 K 是群 G 的两个子群，若存在 g 属于 G，使得$𝐊 =𝐠𝐇𝐠^{−𝟏} = {𝐠𝐡𝐠^{−𝟏}|𝐡 ∈ 𝐇}$。这时，称 H 和 K 是共轭子群</p><p><strong><code>正规子群</code></strong>：设 H 是 G 的子群，如果 H 中所有元素的同类元素都属于 H，则称 H是 G 的不变子群（数学上一般称为正规子群）。</p><p>定理 1.5 设 H 是 G 的不变子群，那么对任意固定的 f 属于 G，当$h_α$取遍 H 中所有元素的时候，$fh_αf^{−1}$给出且仅仅一次给出 H 中所有元素<br>实际上，所有 Abel 群的子群都是其不变子群。因为每个元素自成一类，其同类元素自然在这个子群中</p><p>定理 1.6 不变子群的左陪集与右陪集是重合的。<br>不变子群的陪集还有另外一个更加重要的性质，就是两个（非子群的）不同陪集中元素的乘积，必为第三个陪集中的元素。这个说的是什么呢？就是H是G的不变子群，由H，可将G分解为G={g0H、g1H、g2H、…}。这样的话在这一系列的陪集中，取giH与gjH这两个陪集中的元素gihα与gjhβ相乘，结果是这样的：当giH与gjH都不是g0H时，必属于giH与gjH外的另一个陪集；当giH、gjH其中一个是g0H时，必属于giH与gjH中的另一个；giH与gjH都是g0H时，必属于g0H。</p><p><img src="/2019/06/18/群论基础/shanqun.png" alt="shanqun"></p><h2 id="同态与同构"><a href="#同态与同构" class="headerlink" title="同态与同构"></a>同态与同构</h2><p><strong><code>同构映射</code></strong>：若从群 G 到群 F 上，存在一一对应的满映射$\Phi$，且这个映射本身保持群的乘法运算规律不变，也就是说 G 中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同构，记作 G≅F。映射$\Phi$ 称为同构映射。</p><p>群 G 的两个互为共轭的子群H与K，由定义，是存在一个固定的 g 属于 G，使得对任意的hα ∈ H，都有$k_α = gh_αg^{−1} \in K$与之对应。这个对应关系是一对一的，同时单位元素对应单位元素，互逆元素对应互逆元素。所以同一个群的两个共轭子群同构。</p><p><strong><code>同态</code></strong>：设存在从群 G 到群 F 的满映射（注意，没有一对一了）𝚽，且这个映射本身保持群的乘法运算规律不变，也就是说G中两个元素乘积的映射，等于群 G 中两个元素映射的乘积，则称群 G 与群 F 同态，记作 G~F。映射𝚽称为同态映射。 </p><p>同态核：设 G 与 F 同态，那么 G 中与 F 的单位元素对应的所有元素的集合称为同态核。</p><p> （同态核定理）设 G 与 F 同态，则有：<br>1) 同态核 H 是 G 的不变子群；<br>2) 商群 G/H 与 F 同构。 </p><p><img src="/2019/06/18/群论基础/tth1.png" alt="tth1"></p><p><img src="/2019/06/18/群论基础/天天喝.png" alt="tth2"></p><p><strong>第一同态定理</strong>:  若$\varphi:G\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\phi:G\to G/K$是规范同态函数。则存在唯一的同构函数$\eta:G/K\to\varphi(G)$使得$\varphi=\eta\phi$ </p><p>规范同态函数产生的商群与原同态函数的像同构</p><p><strong>第二同态定理</strong>: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\cap N$是$H$的正规子群，且$$H/H\cap N\cong HN/N$$<br><strong>一致性定理</strong>: 设$N$是$G$的正规子群，则$H\mapsto H/N$是包含$N$的子群$H$的集合与$G/N$的子群的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。<br><strong>第三同构定理</strong>: 设$N$和$H$是$G$的正规子群满足$N\subseteq H$,则$$G/H\cong\frac{G/N}{H/N}$$. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考书籍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.phy.pku.edu.cn/~xzli/teaching.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;群论-李新征讲义&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>问求四机考复习</title>
    <link href="http://shelah-kuang.github.io/2019/06/17/%E9%97%AE%E6%B1%82%E5%9B%9B%E6%9C%BA%E8%80%83%E5%A4%8D%E4%B9%A0/"/>
    <id>http://shelah-kuang.github.io/2019/06/17/问求四机考复习/</id>
    <published>2019-06-17T08:12:01.000Z</published>
    <updated>2019-06-21T13:39:15.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机考内容：<br>    线性规划（会提供模板、框架）<br>    KMP（会提供框架）<br>    模拟退火（会提供框架参考）<br>    Miller-Rabin素数测试</p></blockquote><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>TODO</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><blockquote><p> 板子来源：<a href="https://doowzs.com/blog/2019-02-28-simplex-cpp-template/" target="_blank" rel="noopener">https://doowzs.com/blog/2019-02-28-simplex-cpp-template/</a></p></blockquote><p>将A[0][j]设置为目标函数的参数，整个函数为<br>$$<br>f = \sum_{j = 1}^{n} A[0][j]<br>$$<br>第<em>i</em>个约束条件为<br>$$<br>\sum_{j = 1}^n A[i][j] \leq A[i][0]<br>$$<br>运行<code>simplex()</code>的结果若为-1则无解，1则无界，0则代表有解。最优解为$A[0][0]$，v[j]为各个参数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[MAXN+MAXM] = &#123;&#125;;</span><br><span class="line"><span class="keyword">double</span> v[MAXN] = &#123;&#125;;</span><br><span class="line"><span class="keyword">double</span> a[MAXM][MAXN] = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; -EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> x &gt; EPS ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  swap(id[n + r], id[c]);</span><br><span class="line">  <span class="keyword">double</span> x = -a[r][c];</span><br><span class="line">  a[r][c] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[r][i] /= x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sgn(a[i][c]) &amp;&amp; i != r) &#123;</span><br><span class="line">      x = a[i][c];</span><br><span class="line">      a[i][c] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) a[i][j] += x * a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* important: revert symbols of conditions */</span></span><br><span class="line">  <span class="comment">/* bug fixed thanks to TuoMianZiGan */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      a[i][j] *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">  <span class="comment">/* initial-simplex */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[x][i]) &gt; <span class="number">0</span>) &#123; y = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// infeasible</span></span><br><span class="line">    pivot(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* solve-simplex */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[<span class="number">0</span>][i]) &gt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">break</span>; <span class="comment">// finished</span></span><br><span class="line">    <span class="keyword">double</span> w = <span class="number">0</span>, t = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sgn(a[i][x]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        t = -a[i][<span class="number">0</span>] / a[i][x];</span><br><span class="line">        <span class="keyword">if</span> (f || t &lt; w) &#123;</span><br><span class="line">          w = t, y = i, f = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!y) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="comment">// unbounded</span></span><br><span class="line">    pivot(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) v[id[i]] = a[i - n][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>TODO</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h3 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>TODO</p><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><blockquote><p>来源：<a href="https://maxmute.com/oj/" target="_blank" rel="noopener">https://maxmute.com/oj/</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000077</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;s[i] != <span class="string">'\0'</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = next[i];</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = next[j];</span><br><span class="line">    next[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output all occurrences of `s` in `t`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_match</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">  kmp(s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; ;++i, ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'\0'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, j - i); <span class="comment">//found an entry</span></span><br><span class="line">    <span class="keyword">if</span>(t[j] == <span class="string">'\0'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j]) i = next[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><p>POJ 3461</p><h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><h3 id="算法介绍-2"><a href="#算法介绍-2" class="headerlink" title="算法介绍"></a>算法介绍</h3><blockquote><p> 模拟退火算法描述：</p><p>​         若J( Y(i+1) )&gt;= J( Y(i) )  (即移动后得到更优解)，则总是接受该移动</p><p>​         若J( Y(i+1) )&lt; J( Y(i) )  (即移动后的解比当前解要差)，则<strong>以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）</strong></p><p>　　这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。</p><p>　　根据热力学的原理，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：</p><p>　　　　<strong>P(dE) = exp( dE/(kT) )</strong></p><p>　　其中k是一个常数，exp表示自然指数，且dE&lt;0。这条公式说白了就是：温度越高，出现一次能量差为dE的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于dE总是小于0（否则就不叫退火了），因此dE/kT &lt; 0 ，所以P(dE)的函数取值范围是(0,1) 。</p><p>　　随着温度T的降低，P(dE)会逐渐降低。</p><p>　　我们将一次向较差解的移动看做一次温度跳变过程，我们以概率P(dE)来接受这样的移动。</p><p>来源：<a href="http://www.cnblogs.com/heaad/" target="_blank" rel="noopener">http://www.cnblogs.com/heaad/</a></p></blockquote><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* J(y)：在状态y时的评价函数值</span></span><br><span class="line"><span class="comment">* Y(i)：表示当前状态</span></span><br><span class="line"><span class="comment">* Y(i+1)：表示新的状态</span></span><br><span class="line"><span class="comment">* r： 用于控制降温的快慢</span></span><br><span class="line"><span class="comment">* T： 系统的温度，系统初始应该要处于一个高温的状态</span></span><br><span class="line"><span class="comment">* T_min ：温度的下限，若温度T达到T_min，则停止搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>( T &gt; T_min )</span><br><span class="line">&#123;</span><br><span class="line">　　dE = J( Y(i+<span class="number">1</span>) ) - J( Y(i) ) ; </span><br><span class="line">   <span class="keyword">if</span> ( dE &gt;=<span class="number">0</span> ) <span class="comment">//表达移动后得到更优解，则总是接受移动</span></span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　<span class="keyword">else</span>&#123;<span class="comment">// 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">exp</span>( dE/T ) &gt; random( <span class="number">0</span> , <span class="number">1</span> ) )</span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　T = r * T ; <span class="comment">//降温退火 ，0&lt;r&lt;1 。r越大，降温越慢；r越小，降温越快</span></span><br><span class="line">　　<span class="comment">/*</span></span><br><span class="line"><span class="comment">　　* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值</span></span><br><span class="line"><span class="comment">　　*/</span></span><br><span class="line">　　i ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h3><p>todo</p><h2 id="Miller-Rabin素数测试"><a href="#Miller-Rabin素数测试" class="headerlink" title="Miller-Rabin素数测试"></a>Miller-Rabin素数测试</h2><h3 id="算法介绍-3"><a href="#算法介绍-3" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>反复平方法取$a^b \mod n$</p><p><img src="/2019/06/17/问求四机考复习/反复平方法取幂.png" alt="反复平方法取幂"></p><p>利用费马小定理（如果p是一个素数,且0&lt;a&lt;p,则$a^{p-1}%p=1$.）<br>对于待测试的奇数n而言，(n-1)的二进制表示是u的二进制表示后恰好跟着t个0，所以可以先计算$2^u \mod n$,在反复平方t次来计算$2^{n-1}\mod n$.</p><p><img src="/2019/06/17/问求四机考复习/witness.png" alt="witness"></p><p><img src="/2019/06/17/问求四机考复习/rm.png" alt="miller-rabin"></p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exp_mod</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bit[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        bit[i++] = (b &amp; <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i--; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        s = s * s % m;</span><br><span class="line">        <span class="keyword">if</span>(bit[i]) s = s * a % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a,LL n)</span></span>&#123;</span><br><span class="line">    LL m = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( !(m&amp;<span class="number">1</span>) )&#123;</span><br><span class="line">        j++;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL x = exp_mod(a,m,n);</span><br><span class="line">    LL y;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span> || x == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// n may be prime</span></span><br><span class="line">    <span class="keyword">while</span>(j--)&#123;</span><br><span class="line">        y = x * x % n;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x!=<span class="number">1</span> &amp;&amp; x!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// composite</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//may be prime</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n,<span class="keyword">int</span> T=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>( !(n&amp;<span class="number">1</span>) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL a = rand() * (n<span class="number">-2</span>) / RAND_MAX + <span class="number">1</span>; <span class="comment">//[1,n+1]</span></span><br><span class="line">        <span class="keyword">if</span>( Witness(a,n) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目-3"><a href="#相关题目-3" class="headerlink" title="相关题目"></a>相关题目</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2138&amp;tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">HDU2138</a> </p><p>套板子就行了，只不过要看清题目有多个case，然后如果while+scanf来判断输入结束的话，记得加上!=EOF（<del>我才不会说我因为这个tle了很多次呢</del>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;机考内容：&lt;br&gt;    线性规划（会提供模板、框架）&lt;br&gt;    KMP（会提供框架）&lt;br&gt;    模拟退火（会提供框架参考）&lt;br&gt;    Miller-Rabin素数测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线性规划&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="-review" scheme="http://shelah-kuang.github.io/tags/review/"/>
    
  </entry>
  
</feed>
